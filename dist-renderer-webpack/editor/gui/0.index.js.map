{"version":3,"file":"0.index.js","sources":["webpack:///./node_modules/esptool-js/lib/targets/esp32.js"],"sourcesContent":["import { ROM } from \"./rom.js\";\nimport ESP32_STUB from \"./stub_flasher/stub_flasher_32.json\";\nexport class ESP32ROM extends ROM {\n  constructor() {\n    super(...arguments);\n    this.CHIP_NAME = \"ESP32\";\n    this.IMAGE_CHIP_ID = 0;\n    this.EFUSE_RD_REG_BASE = 0x3ff5a000;\n    this.DR_REG_SYSCON_BASE = 0x3ff66000;\n    this.UART_CLKDIV_REG = 0x3ff40014;\n    this.UART_CLKDIV_MASK = 0xfffff;\n    this.UART_DATE_REG_ADDR = 0x60000078;\n    this.XTAL_CLK_DIVIDER = 1;\n    this.FLASH_SIZES = {\n      \"1MB\": 0x00,\n      \"2MB\": 0x10,\n      \"4MB\": 0x20,\n      \"8MB\": 0x30,\n      \"16MB\": 0x40\n    };\n    this.FLASH_WRITE_SIZE = 0x400;\n    this.BOOTLOADER_FLASH_OFFSET = 0x1000;\n    this.SPI_REG_BASE = 0x3ff42000;\n    this.SPI_USR_OFFS = 0x1c;\n    this.SPI_USR1_OFFS = 0x20;\n    this.SPI_USR2_OFFS = 0x24;\n    this.SPI_W0_OFFS = 0x80;\n    this.SPI_MOSI_DLEN_OFFS = 0x28;\n    this.SPI_MISO_DLEN_OFFS = 0x2c;\n    this.TEXT_START = ESP32_STUB.text_start;\n    this.ENTRY = ESP32_STUB.entry;\n    this.DATA_START = ESP32_STUB.data_start;\n    this.ROM_DATA = ESP32_STUB.data;\n    this.ROM_TEXT = ESP32_STUB.text;\n  }\n  async readEfuse(loader, offset) {\n    const addr = this.EFUSE_RD_REG_BASE + 4 * offset;\n    loader.debug(\"Read efuse \" + addr);\n    return await loader.readReg(addr);\n  }\n  async getPkgVersion(loader) {\n    const word3 = await this.readEfuse(loader, 3);\n    let pkgVersion = word3 >> 9 & 0x07;\n    pkgVersion += (word3 >> 2 & 0x1) << 3;\n    return pkgVersion;\n  }\n  async getChipRevision(loader) {\n    const word3 = await this.readEfuse(loader, 3);\n    const word5 = await this.readEfuse(loader, 5);\n    const apbCtlDate = await loader.readReg(this.DR_REG_SYSCON_BASE + 0x7c);\n    const revBit0 = word3 >> 15 & 0x1;\n    const revBit1 = word5 >> 20 & 0x1;\n    const revBit2 = apbCtlDate >> 31 & 0x1;\n    if (revBit0 != 0) {\n      if (revBit1 != 0) {\n        if (revBit2 != 0) {\n          return 3;\n        } else {\n          return 2;\n        }\n      } else {\n        return 1;\n      }\n    }\n    return 0;\n  }\n  async getChipDescription(loader) {\n    const chipDesc = [\"ESP32-D0WDQ6\", \"ESP32-D0WD\", \"ESP32-D2WD\", \"\", \"ESP32-U4WDH\", \"ESP32-PICO-D4\", \"ESP32-PICO-V3-02\"];\n    let chipName = \"\";\n    const pkgVersion = await this.getPkgVersion(loader);\n    const chipRevision = await this.getChipRevision(loader);\n    const rev3 = chipRevision == 3;\n    const single_core = (await this.readEfuse(loader, 3)) & 1 << 0;\n    if (single_core != 0) {\n      chipDesc[0] = \"ESP32-S0WDQ6\";\n      chipDesc[1] = \"ESP32-S0WD\";\n    }\n    if (rev3) {\n      chipDesc[5] = \"ESP32-PICO-V3\";\n    }\n    if (pkgVersion >= 0 && pkgVersion <= 6) {\n      chipName = chipDesc[pkgVersion];\n    } else {\n      chipName = \"Unknown ESP32\";\n    }\n    if (rev3 && (pkgVersion === 0 || pkgVersion === 1)) {\n      chipName += \"-V3\";\n    }\n    return chipName + \" (revision \" + chipRevision + \")\";\n  }\n  async getChipFeatures(loader) {\n    const features = [\"Wi-Fi\"];\n    const word3 = await this.readEfuse(loader, 3);\n    const chipVerDisBt = word3 & 1 << 1;\n    if (chipVerDisBt === 0) {\n      features.push(\" BT\");\n    }\n    const chipVerDisAppCpu = word3 & 1 << 0;\n    if (chipVerDisAppCpu !== 0) {\n      features.push(\" Single Core\");\n    } else {\n      features.push(\" Dual Core\");\n    }\n    const chipCpuFreqRated = word3 & 1 << 13;\n    if (chipCpuFreqRated !== 0) {\n      const chipCpuFreqLow = word3 & 1 << 12;\n      if (chipCpuFreqLow !== 0) {\n        features.push(\" 160MHz\");\n      } else {\n        features.push(\" 240MHz\");\n      }\n    }\n    const pkgVersion = await this.getPkgVersion(loader);\n    if ([2, 4, 5, 6].indexOf(pkgVersion) !== -1) {\n      features.push(\" Embedded Flash\");\n    }\n    if (pkgVersion === 6) {\n      features.push(\" Embedded PSRAM\");\n    }\n    const word4 = await this.readEfuse(loader, 4);\n    const adcVref = word4 >> 8 & 0x1f;\n    if (adcVref !== 0) {\n      features.push(\" VRef calibration in efuse\");\n    }\n    const blk3PartRes = word3 >> 14 & 0x1;\n    if (blk3PartRes !== 0) {\n      features.push(\" BLK3 partially reserved\");\n    }\n    const word6 = await this.readEfuse(loader, 6);\n    const codingScheme = word6 & 0x3;\n    const codingSchemeArr = [\"None\", \"3/4\", \"Repeat (UNSUPPORTED)\", \"Invalid\"];\n    features.push(\" Coding Scheme \" + codingSchemeArr[codingScheme]);\n    return features;\n  }\n  async getCrystalFreq(loader) {\n    const uartDiv = (await loader.readReg(this.UART_CLKDIV_REG)) & this.UART_CLKDIV_MASK;\n    const etsXtal = loader.transport.baudrate * uartDiv / 1000000 / this.XTAL_CLK_DIVIDER;\n    let normXtal;\n    if (etsXtal > 33) {\n      normXtal = 40;\n    } else {\n      normXtal = 26;\n    }\n    if (Math.abs(normXtal - etsXtal) > 1) {\n      loader.info(\"WARNING: Unsupported crystal in use\");\n    }\n    return normXtal;\n  }\n  _d2h(d) {\n    const h = (+d).toString(16);\n    return h.length === 1 ? \"0\" + h : h;\n  }\n  async readMac(loader) {\n    let mac0 = await this.readEfuse(loader, 1);\n    mac0 = mac0 >>> 0;\n    let mac1 = await this.readEfuse(loader, 2);\n    mac1 = mac1 >>> 0;\n    const mac = new Uint8Array(6);\n    mac[0] = mac1 >> 8 & 0xff;\n    mac[1] = mac1 & 0xff;\n    mac[2] = mac0 >> 24 & 0xff;\n    mac[3] = mac0 >> 16 & 0xff;\n    mac[4] = mac0 >> 8 & 0xff;\n    mac[5] = mac0 & 0xff;\n    return this._d2h(mac[0]) + \":\" + this._d2h(mac[1]) + \":\" + this._d2h(mac[2]) + \":\" + this._d2h(mac[3]) + \":\" + this._d2h(mac[4]) + \":\" + this._d2h(mac[5]);\n  }\n}"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;A","sourceRoot":""}