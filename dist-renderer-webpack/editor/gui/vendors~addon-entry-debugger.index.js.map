{"version":3,"file":"vendors~addon-entry-debugger.index.js","sources":["webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/style.css","webpack:///./node_modules/scratch-gui/src/addons/addons/editor-theme3/compatibility.css","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/_runtime_entry.js","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/error.svg?8fa1","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/subthread.svg?adf6","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/warning.svg?12dd","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/log-view.js","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/logs.js","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/performance.js","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/threads.js","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/userscript.js","webpack:///./node_modules/scratch-gui/src/addons/addons/editor-stepping/highlighter.js","webpack:///./node_modules/scratch-gui/src/addons/libraries/common/cs/download-blob.js","webpack:///./node_modules/scratch-gui/src/addons/libraries/common/cs/small-stage.js","webpack:///./node_modules/scratch-gui/src/addons/libraries/thirdparty/cs/chart.min.js","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/close.svg","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/debug.svg","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/delete.svg","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/download-white.svg","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/error.svg","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/logs.svg","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/performance.svg","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/play.svg","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/step.svg","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/subthread.svg","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/threads.svg","webpack:///./node_modules/scratch-gui/src/addons/addons/debugger/icons/warning.svg"],"sourcesContent":["var escape = require(\"../../../../../css-loader/lib/url/escape.js\");\nexports = module.exports = require(\"../../../../../css-loader/lib/css-base.js\")(false);\n// imports\nexports.i(require(\"-!../../../../../css-loader/index.js!../editor-theme3/compatibility.css\"), \"\");\n\n// module\nexports.push([module.id, \"[dir=\\\"ltr\\\"] .sa-debugger-container {\\n  margin-right: 0.2rem;\\n}\\n\\n[dir=\\\"rtl\\\"] .sa-debugger-container {\\n  margin-left: 0.2rem;\\n}\\n\\n.sa-small-stage [class*=\\\"gui_body-wrapper_\\\"]:not(.sa-stage-hidden) .sa-debugger-container {\\n  display: none !important;\\n}\\n\\n.sa-debugger-container [class*=\\\"button_content_\\\"] {\\n  position: relative;\\n}\\n\\n.sa-debugger-unread::after {\\n  content: \\\"\\\";\\n  position: absolute;\\n  top: 1px;\\n  right: 0;\\n  display: block;\\n  width: 6px;\\n  height: 6px;\\n  background-color: var(--editorDarkMode-highlightText, #855cd6);\\n  border-radius: 50%;\\n}\\n\\n.sa-debugger-interface {\\n  display: none;\\n  position: absolute;\\n  z-index: 492;\\n  background-color: var(--ui-modal-background);\\n  color: var(--ui-modal-foreground);\\n  width: 565px;\\n  height: 25rem;\\n}\\n\\n.sa-debugger-interface [class*=\\\"card_header-buttons_\\\"] {\\n  background-color: #29beb8;\\n  border-color: #3aa8a4;\\n}\\n\\n.sa-debugger-interface h1 {\\n  padding: 10px;\\n  z-index: 10;\\n  width: calc(100% - 20px);\\n  font-size: 20px;\\n}\\n\\n.sa-debugger-tabs {\\n  margin: 0;\\n  display: flex;\\n  align-items: center;\\n  padding: 0 15px;\\n  font-size: 0.75rem;\\n}\\n.sa-debugger-tabs li {\\n  margin: 0;\\n  display: flex;\\n  align-items: center;\\n  padding: 0.5em 1em;\\n  background-color: rgba(0, 0, 0, 0.1);\\n  border: 1px solid rgba(0, 0, 0, 0.15);\\n  border-radius: 1rem;\\n  color: white;\\n  cursor: pointer;\\n}\\n.sa-debugger-tabs li + li {\\n  margin-inline-start: 10px;\\n}\\n.sa-debugger-tabs li:hover {\\n  background-color: rgba(0, 0, 0, 0.15);\\n}\\n.sa-debugger-tabs li.sa-debugger-tab-selected {\\n  background-color: white;\\n  background-clip: padding-box;\\n  border-color: rgba(0, 0, 0, 0.25);\\n  color: var(--looks-secondary);\\n}\\n.sa-debugger-tabs li img {\\n  margin: 0;\\n  margin-right: 0.25rem;\\n  width: 1rem;\\n  filter: brightness(0) invert(1);\\n}\\n.sa-debugger-tabs li.sa-debugger-tab-selected img {\\n  filter: none;\\n}\\n\\n.sa-debugger-header-buttons img {\\n  width: 20px;\\n  height: 20px;\\n}\\n\\n.sa-debugger-unpause {\\n  animation: saDebuggerUnpause 2s infinite alternate;\\n}\\n\\n@keyframes saDebuggerUnpause {\\n  0% {\\n    background-color: rgba(0, 0, 0, 0.15);\\n  }\\n  100% {\\n    background-color: rgba(0, 0, 0, 0);\\n  }\\n}\\n\\n.sa-debugger-tab-content {\\n  width: 100%;\\n  height: 100%;\\n  overflow: auto;\\n  cursor: auto;\\n}\\n\\n.sa-debugger-chart {\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n.sa-performance-tab-content {\\n  padding: 15px;\\n}\\n\\n.sa-debugger-log-outer {\\n  height: 100%;\\n}\\n\\n.sa-debugger-log-inner {\\n  position: relative;\\n  overflow-y: auto;\\n  font-size: 12px;\\n  line-height: 1.2;\\n  height: 100%;\\n  contain: strict;\\n}\\n\\n.sa-debugger-log-empty {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  width: 100%;\\n  height: 100%;\\n  font-size: 20px;\\n  font-style: italic;\\n}\\n\\n.sa-debugger-log-end {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 1px;\\n  height: 1px;\\n}\\n\\n.sa-debugger-log {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 20px;\\n  box-sizing: border-box;\\n  display: flex;\\n  align-items: center;\\n  border-bottom: 1px solid var(--ui-black-transparent);\\n  padding-left: 4px;\\n  font-family: monospace;\\n}\\n.sa-debugger-log[data-type=\\\"warn\\\"] {\\n  border-color: hsla(56deg, 100%, 69%, 0.5);\\n  background-color: hsla(56deg, 100%, 69%, 0.3);\\n}\\n.sa-debugger-log[data-type=\\\"error\\\"] {\\n  border-color: hsla(0deg, 100%, 69%, 0.5);\\n  color: red;\\n  background-color: hsla(0deg, 100%, 69%, 0.3);\\n}\\n\\n.sa-debugger-log-repeats {\\n  background-color: hsla(163, 85%, 40%, 1);\\n  color: white;\\n  border-radius: 100px;\\n  padding: 1px 6px;\\n  margin-right: 4px;\\n}\\n\\n.sa-debugger-log-icon {\\n  width: 16px;\\n  height: 16px;\\n  margin-right: 4px;\\n}\\n[data-type=\\\"warn\\\"] .sa-debugger-log-icon {\\n  background-image: url(\" + escape(require(\"./icons/warning.svg\")) + \");\\n}\\n[data-type=\\\"error\\\"] .sa-debugger-log-icon {\\n  background-image: url(\" + escape(require(\"./icons/error.svg\")) + \");\\n}\\n.sa-debugger-threads .sa-debugger-log-icon {\\n  background-image: url(\" + escape(require(\"./icons/subthread.svg\")) + \");\\n}\\n\\n.sa-debugger-log-link {\\n  color: inherit;\\n  cursor: pointer;\\n  opacity: 0.5;\\n  text-decoration: underline;\\n  float: right;\\n  text-align: right;\\n  max-width: 100%;\\n  padding-left: 4px;\\n  margin-right: 4px;\\n  margin-left: auto;\\n}\\n.sa-debugger-log-link:hover {\\n  text-decoration: underline;\\n  color: var(--looks-secondary);\\n  opacity: 1;\\n}\\n.sa-debugger-log-link-unknown {\\n  pointer-events: none;\\n}\\n\\n.sa-debugger-log-text {\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  white-space: pre;\\n}\\n.sa-debugger-log-text-empty {\\n  font-style: italic;\\n}\\n.sa-debugger-log-internal .sa-debugger-log-text {\\n  font-style: italic;\\n}\\n\\n.sa-debugger-thread-indent {\\n  width: calc(16px * var(--level));\\n  margin-right: 4px;\\n}\\n.sa-debugger-thread-title .sa-debugger-thread-indent {\\n  margin: 0;\\n}\\n.sa-debugger-thread-target-name {\\n  font-weight: bold;\\n  margin-right: 8px;\\n}\\n.sa-debugger-thread-running {\\n  background-color: rgba(255, 187, 0, 0.233);\\n  font-weight: bold;\\n}\\n\\n.sa-debugger-block-preview {\\n  padding: 1px 6px;\\n  margin-right: 4px;\\n  background-color: var(--sa-block-colored-background);\\n  color: var(--sa-block-text);\\n}\\n.sa-debugger-block-preview[data-shape=\\\"round\\\"] {\\n  border-radius: 100px;\\n}\\n.sa-debugger-block-preview[data-shape=\\\"stacked\\\"] {\\n  border-radius: 3px;\\n}\\n\\n.sa-debugger-thread-compiled {\\n  font-style: italic;\\n}\\n\\n.sa-debugger-compiler-warning {\\n  position: relative;\\n  display: block;\\n  text-align: center;\\n  height: 24px;\\n  color: var(--link-color);\\n}\\n.sa-debugger-compiler-warning[hidden] {\\n  display: none;\\n}\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../../css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"/* Imported by other addons */\\n\\n.sa-block-color {\\n  --sa-block-colored-background: var(--sa-block-background-primary);\\n  --sa-block-colored-background-secondary: var(--sa-block-field-background);\\n  --sa-block-bright-background: var(--sa-block-background-primary);\\n  --sa-block-text: var(--editorTheme3-blockText, white);\\n  --sa-block-gray-text: white;\\n  --sa-block-colored-text: var(--sa-block-background-primary);\\n  --sa-block-text-on-bright-background: var(--editorTheme3-blockText, white);\\n  --sa-block-input-color: var(--editorTheme3-inputColor, white);\\n  --sa-block-input-text: var(--editorTheme3-inputColor-text, #575e75);\\n}\\n\\n.sa-block-color-motion {\\n  --sa-block-background-primary: var(--editorTheme3-motion-primary, #4c97ff);\\n  --sa-block-background-secondary: var(--editorTheme3-motion-secondary, #4280d7);\\n  --sa-block-background-tertiary: var(--editorTheme3-motion-tertiary, #3373cc);\\n  --sa-block-field-background: var(--editorTheme3-motion-field, #3373cc);\\n}\\n\\n.sa-block-color-looks {\\n  --sa-block-background-primary: var(--editorTheme3-looks-primary, #9966ff);\\n  --sa-block-background-secondary: var(--editorTheme3-looks-secondary, #855cd6);\\n  --sa-block-background-tertiary: var(--editorTheme3-looks-tertiary, #774dcb);\\n  --sa-block-field-background: var(--editorTheme3-looks-field, #774dcb);\\n}\\n\\n.sa-block-color-sounds {\\n  --sa-block-background-primary: var(--editorTheme3-sounds-primary, #cf63cf);\\n  --sa-block-background-secondary: var(--editorTheme3-sounds-secondary, #c94fc9);\\n  --sa-block-background-tertiary: var(--editorTheme3-sounds-tertiary, #bd42bd);\\n  --sa-block-field-background: var(--editorTheme3-sounds-field, #bd42bd);\\n}\\n\\n.sa-block-color-events {\\n  --sa-block-background-primary: var(--editorTheme3-event-primary, #ffbf00);\\n  --sa-block-background-secondary: var(--editorTheme3-event-secondary, #e6ac00);\\n  --sa-block-background-tertiary: var(--editorTheme3-event-tertiary, #cc9900);\\n  --sa-block-field-background: var(--editorTheme3-event-field, #cc9900);\\n}\\n\\n.sa-block-color-control {\\n  --sa-block-background-primary: var(--editorTheme3-control-primary, #ffab19);\\n  --sa-block-background-secondary: var(--editorTheme3-control-secondary, #ec9c13);\\n  --sa-block-background-tertiary: var(--editorTheme3-control-tertiary, #cf8b17);\\n  --sa-block-field-background: var(--editorTheme3-control-field, #cf8b17);\\n}\\n\\n.sa-block-color-sensing {\\n  --sa-block-background-primary: var(--editorTheme3-sensing-primary, #5cb1d6);\\n  --sa-block-background-secondary: var(--editorTheme3-sensing-secondary, #47a8d1);\\n  --sa-block-background-tertiary: var(--editorTheme3-sensing-tertiary, #2e8eb8);\\n  --sa-block-field-background: var(--editorTheme3-sensing-field, #2e8eb8);\\n}\\n\\n.sa-block-color-operators {\\n  --sa-block-background-primary: var(--editorTheme3-operators-primary, #59c059);\\n  --sa-block-background-secondary: var(--editorTheme3-operators-secondary, #46b946);\\n  --sa-block-background-tertiary: var(--editorTheme3-operators-tertiary, #389438);\\n  --sa-block-field-background: var(--editorTheme3-operators-field, #389438);\\n}\\n\\n.sa-block-color-data {\\n  --sa-block-background-primary: var(--editorTheme3-data-primary, #ff8c1a);\\n  --sa-block-background-secondary: var(--editorTheme3-data-secondary, #ff8000);\\n  --sa-block-background-tertiary: var(--editorTheme3-data-tertiary, #db6e00);\\n  --sa-block-field-background: var(--editorTheme3-data-field, #db6e00);\\n}\\n\\n.sa-block-color-data-lists,\\n.sa-block-color-list {\\n  --sa-block-background-primary: var(--editorTheme3-data_lists-primary, #ff661a);\\n  --sa-block-background-secondary: var(--editorTheme3-data_lists-secondary, #ff5500);\\n  --sa-block-background-tertiary: var(--editorTheme3-data_lists-tertiary, #e64d00);\\n  --sa-block-field-background: var(--editorTheme3-data_lists-field, #e64d00);\\n}\\n\\n.sa-block-color-more,\\n.sa-block-color-null {\\n  --sa-block-background-primary: var(--editorTheme3-more-primary, #ff6680);\\n  --sa-block-background-secondary: var(--editorTheme3-more-secondary, #ff4d6a);\\n  --sa-block-background-tertiary: var(--editorTheme3-more-tertiary, #ff3355);\\n  --sa-block-field-background: var(--editorTheme3-more-field, #ff3355);\\n}\\n\\n.sa-block-color-pen {\\n  --sa-block-background-primary: var(--editorTheme3-pen-primary, #0fbd8c);\\n  --sa-block-background-secondary: var(--editorTheme3-pen-secondary, #0da57a);\\n  --sa-block-background-tertiary: var(--editorTheme3-pen-tertiary, #0b8e69);\\n  --sa-block-field-background: var(--editorTheme3-pen-field, #0b8e69);\\n}\\n\\n.sa-block-color-addon-custom-block {\\n  --sa-block-background-primary: var(--editorTheme3-addons-primary, #29beb8);\\n  --sa-block-background-secondary: var(--editorTheme3-addons-secondary, #3aa8a4);\\n  --sa-block-background-tertiary: var(--editorTheme3-addons-tertiary, #3aa8a4);\\n  --sa-block-field-background: var(--editorTheme3-addons-field, #3aa8a4);\\n}\\n\", \"\"]);\n\n// exports\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./style.css\";\nimport _asset from \"!url-loader!./icons/close.svg\";\nimport _asset2 from \"!url-loader!./icons/debug.svg\";\nimport _asset3 from \"!url-loader!./icons/delete.svg\";\nimport _asset4 from \"!url-loader!./icons/download-white.svg\";\nimport _asset5 from \"!url-loader!./icons/error.svg\";\nimport _asset6 from \"!url-loader!./icons/logs.svg\";\nimport _asset7 from \"!url-loader!./icons/performance.svg\";\nimport _asset8 from \"!url-loader!./icons/play.svg\";\nimport _asset9 from \"!url-loader!./icons/step.svg\";\nimport _asset10 from \"!url-loader!./icons/subthread.svg\";\nimport _asset11 from \"!url-loader!./icons/threads.svg\";\nimport _asset12 from \"!url-loader!./icons/warning.svg\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"style.css\": _css,\n  \"icons/close.svg\": _asset,\n  \"icons/debug.svg\": _asset2,\n  \"icons/delete.svg\": _asset3,\n  \"icons/download-white.svg\": _asset4,\n  \"icons/error.svg\": _asset5,\n  \"icons/logs.svg\": _asset6,\n  \"icons/performance.svg\": _asset7,\n  \"icons/play.svg\": _asset8,\n  \"icons/step.svg\": _asset9,\n  \"icons/subthread.svg\": _asset10,\n  \"icons/threads.svg\": _asset11,\n  \"icons/warning.svg\": _asset12\n};","module.exports = __webpack_public_path__ + \"static/assets/476378027ef47e55598ddc471dec85a4.svg\";","module.exports = __webpack_public_path__ + \"static/assets/939350916a00262af1d6799aea01634f.svg\";","module.exports = __webpack_public_path__ + \"static/assets/0e45a28b99a6ff0724db5d8ccc051efe.svg\";","const clamp = (i, min, max) => Math.max(min, Math.min(max, i));\nconst appendSortedElement = (parent, newChild) => {\n  const newChildIndex = +newChild.dataset.index;\n  let foundSpot = false;\n  for (const existingChild of parent.children) {\n    const existingChildIndex = +existingChild.dataset.index;\n    if (existingChildIndex > newChildIndex) {\n      foundSpot = true;\n      parent.insertBefore(newChild, existingChild);\n      break;\n    }\n  }\n  if (!foundSpot) {\n    parent.appendChild(newChild);\n  }\n};\n\n/**\n * LogView: A virtualized row viewer.\n * It efficiently manages row rendering and scrolling.\n *\n * 1. .logs is the place where all the rows live. This is an array of any arbitrary object.\n * 2. Implement generateRow(row). This takes a row from .logs as an argument. This should return\n *    an object with a bunch of DOM elements on it. The \"root\" property must be set, nothing else\n *    is required. This is called when a row becomes visible. It can be called any number of times.\n *    This is where you should setup elements that are immutable for a given row. LogView will\n *    move the root element to the right spot for you.\n * 3. Implement renderRow(elements, row). This will be called with the result returned by\n *    generateRow() and the row in .logs any time a row is changed, including the first render.\n *    It can be called any number of times. This is where you should update any dynamic elements.\n * 4. Whenever you update .logs without using the helper methods such as append(), call\n *    queueUpdateContent().\n */\nclass LogView {\n  constructor() {\n    this.rows = [];\n    this.canAutoScrollToEnd = true;\n    this.rowHeight = 20;\n    this.outerElement = document.createElement(\"div\");\n    this.outerElement.className = \"sa-debugger-log-outer\";\n    this.innerElement = document.createElement(\"div\");\n    this.innerElement.className = \"sa-debugger-log-inner\";\n    this.outerElement.appendChild(this.innerElement);\n    this.innerElement.addEventListener(\"scroll\", this._handleScroll.bind(this), {\n      passive: true\n    });\n    this.innerElement.addEventListener(\"wheel\", this._handleWheel.bind(this), {\n      passive: true\n    });\n    this.endElement = document.createElement(\"div\");\n    this.endElement.className = \"sa-debugger-log-end\";\n    this.endElement.dataset.index = \"-1\";\n    this.innerElement.appendChild(this.endElement);\n    this.placeholderElement = document.createElement(\"div\");\n    this.placeholderElement.className = \"sa-debugger-log-empty\";\n    this.visible = false;\n    this.isScrolledToEnd = true;\n    this.scrollTopWhenHidden = \"end\";\n    this.scrollTop = 0;\n    this.updateContentQueued = false;\n    this.scrollToEndQueued = false;\n    this.oldLength = -1;\n    this.rowToMetadata = new Map();\n  }\n  append(log) {\n    this.queueUpdateContent();\n    this._queueScrollToEnd();\n    this.rows.push(log);\n    const MAX_LOGS = 200000;\n    while (this.rows.length > MAX_LOGS) {\n      this.rows.shift();\n    }\n  }\n  clear() {\n    this.rows.length = 0;\n    this.scrollTop = 0;\n    this.isScrolledToEnd = true;\n    this.queueUpdateContent();\n  }\n  show() {\n    this.visible = true;\n    this.height = this.innerElement.offsetHeight;\n    this.queueUpdateContent();\n    if (this.scrollTopWhenHidden === \"end\") {\n      this._queueScrollToEnd();\n    } else {\n      this.innerElement.scrollTop = this.scrollTopWhenHidden;\n    }\n  }\n  hide() {\n    this.visible = false;\n    this.scrollTopWhenHidden = this.isScrolledToEnd ? \"end\" : this.scrollTop;\n  }\n  _handleScroll(e) {\n    this.scrollTop = e.target.scrollTop;\n    this.isScrolledToEnd = e.target.scrollTop + 5 >= e.target.scrollHeight - e.target.clientHeight;\n    this.queueUpdateContent();\n  }\n  _handleWheel(e) {\n    if (e.deltaY < 0) {\n      this.isScrolledToEnd = false;\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @param {number} [margin] # of pixels on top and bottom that are not considered part of the view\n   * @returns {boolean}\n   */\n  isInView(index) {\n    let margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const topEdgeFromTop = index * this.rowHeight;\n    const bottomEdgeFromTop = topEdgeFromTop + this.rowHeight;\n    const viewportStart = this.scrollTop;\n    const viewportEnd = viewportStart + this.height;\n    return topEdgeFromTop >= viewportStart + margin && bottomEdgeFromTop <= viewportEnd - margin;\n  }\n\n  /**\n   * @param {number} index\n   */\n  scrollTo(index) {\n    // There is one extra pixel from this.endElement\n    const maximumScrollTop = Math.max(0, this.rows.length * this.rowHeight - this.height + 1);\n\n    // Try to leave the item above slightly visible to make it more obvious to the user that they can\n    // still scroll.\n    this.scrollTop = Math.min(maximumScrollTop, index * this.rowHeight - this.rowHeight * 0.3);\n    this.innerElement.scrollTop = this.scrollTop;\n  }\n  _queueScrollToEnd() {\n    if (this.visible && this.canAutoScrollToEnd && this.isScrolledToEnd && !this.scrollToEndQueued) {\n      this.scrollToEndQueued = true;\n      queueMicrotask(() => {\n        this.scrollToEndQueued = false;\n        if (this.isScrolledToEnd) {\n          const scrollEnd = this.innerElement.scrollHeight - this.innerElement.offsetHeight;\n          this.innerElement.scrollTop = scrollEnd;\n          this.scrollTop = scrollEnd;\n        }\n      });\n    }\n  }\n  queueUpdateContent() {\n    if (this.visible && !this.updateContentQueued) {\n      this.updateContentQueued = true;\n      queueMicrotask(() => {\n        this.updateContentQueued = false;\n        this.updateContent();\n      });\n    }\n  }\n  generateRow(row) {\n    // to be implemented by users\n  }\n  renderRow(elements, row) {\n    // to be implemented by users\n  }\n  updateContent() {\n    if (this.rows.length !== this.oldLength) {\n      this.oldLength = this.rows.length;\n      const totalHeight = this.rows.length * this.rowHeight;\n      this.endElement.style.transform = \"translateY(\".concat(totalHeight, \"px)\");\n      if (this.rows.length) {\n        this.placeholderElement.remove();\n      } else {\n        this.innerElement.appendChild(this.placeholderElement);\n        for (const metadata of this.rowToMetadata.values()) {\n          metadata.elements.root.remove();\n        }\n        this.rowToMetadata.clear();\n      }\n    }\n    if (this.rows.length === 0) {\n      return;\n    }\n\n    // For better compatibility with asynchronous scrolling, we'll render a few extra rows in either direction.\n    const EXTRA_ROWS_ABOVE = 5;\n    const EXTRA_ROWS_BELOW = 5;\n    const scrollStartIndex = Math.floor(this.scrollTop / this.rowHeight);\n    const rowsVisible = Math.ceil(this.height / this.rowHeight);\n    const startIndex = clamp(scrollStartIndex - EXTRA_ROWS_BELOW, 0, this.rows.length);\n    const endIndex = clamp(scrollStartIndex + rowsVisible + EXTRA_ROWS_ABOVE, 0, this.rows.length);\n    const allVisibleRows = new Set();\n    const newElements = [];\n    for (let i = startIndex; i < endIndex; i++) {\n      const row = this.rows[i];\n      allVisibleRows.add(row);\n      let metadata = this.rowToMetadata.get(row);\n      if (!metadata) {\n        const elements = this.generateRow(row);\n        newElements.push(elements.root);\n        metadata = {\n          stringify: null,\n          elements\n        };\n        this.rowToMetadata.set(row, metadata);\n      }\n      const currentStringify = JSON.stringify(row);\n      if (currentStringify !== metadata.stringify) {\n        metadata.stringify = currentStringify;\n        this.renderRow(metadata.elements, row);\n      }\n      const root = metadata.elements.root;\n      root.style.transform = \"translateY(\".concat(i * this.rowHeight, \"px)\");\n      root.dataset.index = i;\n    }\n    for (const [row, metadata] of this.rowToMetadata.entries()) {\n      if (!allVisibleRows.has(row)) {\n        metadata.elements.root.remove();\n        this.rowToMetadata.delete(row);\n      }\n    }\n    for (const root of newElements) {\n      appendSortedElement(this.innerElement, root);\n    }\n  }\n}\nexport default LogView;","import downloadBlob from \"../../libraries/common/cs/download-blob.js\";\nimport LogView from \"./log-view.js\";\nexport default async function createLogsTab(_ref) {\n  let {\n    debug,\n    addon,\n    console,\n    msg\n  } = _ref;\n  const vm = addon.tab.traps.vm;\n  const tab = debug.createHeaderTab({\n    text: msg(\"tab-logs\"),\n    icon: addon.self.getResource(\"/icons/logs.svg\") /* rewritten by pull.js */\n  });\n  const logView = new LogView();\n  logView.placeholderElement.textContent = msg(\"no-logs\");\n  const getInputOfBlock = (targetId, blockId) => {\n    var _Object$values$;\n    const target = vm.runtime.getTargetById(targetId);\n    if (!target) {\n      return null;\n    }\n    const block = debug.getBlock(target, blockId);\n    if (!block) {\n      return null;\n    }\n    return (_Object$values$ = Object.values(block.inputs)[0]) === null || _Object$values$ === void 0 ? void 0 : _Object$values$.block;\n  };\n  logView.generateRow = row => {\n    const root = document.createElement(\"div\");\n    root.className = \"sa-debugger-log\";\n    if (row.internal) {\n      root.classList.add(\"sa-debugger-log-internal\");\n    }\n    root.dataset.type = row.type;\n    const icon = document.createElement(\"div\");\n    icon.className = \"sa-debugger-log-icon\";\n    if (row.type === \"warn\" || row.type === \"error\") {\n      icon.title = msg(\"icon-\" + row.type);\n    }\n    root.appendChild(icon);\n    const repeats = document.createElement(\"div\");\n    repeats.className = \"sa-debugger-log-repeats\";\n    repeats.style.display = \"none\";\n    root.appendChild(repeats);\n    if (row.preview && row.blockId && row.targetInfo) {\n      const originalId = row.targetInfo.originalId;\n      const inputBlock = getInputOfBlock(originalId, row.blockId);\n      if (inputBlock) {\n        const preview = debug.createBlockPreview(originalId, inputBlock);\n        if (preview) {\n          root.appendChild(preview);\n        }\n      }\n    }\n    const text = document.createElement(\"div\");\n    text.className = \"sa-debugger-log-text\";\n    if (row.text.length === 0) {\n      text.classList.add(\"sa-debugger-log-text-empty\");\n      text.textContent = msg(\"empty-string\");\n    } else {\n      text.textContent = row.text;\n      text.title = row.text;\n    }\n    root.appendChild(text);\n    if (row.targetInfo && row.blockId) {\n      root.appendChild(debug.createBlockLink(row.targetInfo, row.blockId));\n    }\n    return {\n      root,\n      repeats\n    };\n  };\n  logView.renderRow = (elements, row) => {\n    const {\n      repeats\n    } = elements;\n    if (row.count > 1) {\n      repeats.style.display = \"\";\n      repeats.textContent = row.count;\n    }\n  };\n  const exportButton = debug.createHeaderButton({\n    text: msg(\"export\"),\n    icon: addon.self.getResource(\"/icons/download-white.svg\") /* rewritten by pull.js */,\n    description: msg(\"export-desc\")\n  });\n  const downloadText = (filename, text) => {\n    downloadBlob(filename, new Blob([text], {\n      type: \"text/plain\"\n    }));\n  };\n  exportButton.element.addEventListener(\"click\", async e => {\n    const defaultFormat = \"{sprite}: {content} ({type})\";\n    const exportFormat = e.shiftKey ? await addon.tab.prompt(msg(\"export\"), msg(\"enter-format\"), defaultFormat, {\n      useEditorClasses: true\n    }) : defaultFormat;\n    if (!exportFormat) return;\n    const file = logView.rows.map(_ref2 => {\n      let {\n        text,\n        targetInfo,\n        type,\n        count\n      } = _ref2;\n      return (exportFormat.replace(/\\{(sprite|type|content)\\}/g, (_, match) => ({\n        sprite: targetInfo ? targetInfo.name : msg(\"unknown-sprite\"),\n        type,\n        content: text\n      })[match]) + \"\\n\").repeat(count);\n    }).join(\"\");\n    downloadText(\"logs.txt\", file);\n  });\n  const trashButton = debug.createHeaderButton({\n    text: msg(\"clear\"),\n    icon: addon.self.getResource(\"/icons/delete.svg\") /* rewritten by pull.js */\n  });\n  trashButton.element.addEventListener(\"click\", () => {\n    clearLogs();\n  });\n  const areLogsEqual = (a, b) => a.text === b.text && a.type === b.type && a.internal === b.internal && a.blockId === b.blockId && a.targetId === b.targetId;\n  const addLog = (text, thread, type) => {\n    const log = {\n      text,\n      type,\n      count: 1,\n      preview: true\n    };\n    if (thread) {\n      log.blockId = thread.peekStack();\n      const targetId = thread.target.id;\n      log.targetId = targetId;\n      log.targetInfo = debug.getTargetInfoById(targetId);\n    }\n    if (type === \"internal\") {\n      log.internal = true;\n      log.preview = false;\n      log.type = \"log\";\n    }\n    if (type === \"internal-warn\") {\n      log.internal = true;\n      log.type = \"warn\";\n    }\n    const previousLog = logView.rows[logView.rows.length - 1];\n    if (previousLog && areLogsEqual(log, previousLog)) {\n      previousLog.count++;\n      logView.queueUpdateContent();\n    } else {\n      logView.append(log);\n    }\n    if (!logView.visible && !log.internal) {\n      debug.setHasUnreadMessage(true);\n    }\n  };\n  const clearLogs = () => {\n    logView.clear();\n  };\n  const show = () => {\n    logView.show();\n    debug.setHasUnreadMessage(false);\n  };\n  const hide = () => {\n    logView.hide();\n  };\n  return {\n    tab,\n    content: logView.outerElement,\n    buttons: [exportButton, trashButton],\n    show,\n    hide,\n    addLog,\n    clearLogs\n  };\n}","import { onPauseChanged, isPaused } from \"./module.js\";\nimport \"../../libraries/thirdparty/cs/chart.min.js\";\nexport default async function createPerformanceTab(_ref) {\n  let {\n    debug,\n    addon,\n    console,\n    msg\n  } = _ref;\n  const vm = addon.tab.traps.vm;\n\n  // In optimized graphs everything still looks good\n  const fancyGraphs = addon.settings.get(\"fancy_graphs\");\n  const lineWidth = fancyGraphs ? 1 : 2;\n  const lineColor = fancyGraphs ? \"hsla(163, 85%, 40%, 0.5)\" : \"hsla(163, 85%, 40%, 1)\";\n  const tab = debug.createHeaderTab({\n    text: msg(\"tab-performance\"),\n    icon: addon.self.getResource(\"/icons/performance.svg\") /* rewritten by pull.js */\n  });\n  const content = Object.assign(document.createElement(\"div\"), {\n    className: \"sa-performance-tab-content\"\n  });\n  const createChart = _ref2 => {\n    let {\n      title\n    } = _ref2;\n    const titleElement = Object.assign(document.createElement(\"h2\"), {\n      textContent: title\n    });\n    const canvas = Object.assign(document.createElement(\"canvas\"), {\n      className: \"sa-debugger-chart\"\n    });\n    return {\n      title: titleElement,\n      canvas\n    };\n  };\n  const now = () => performance.now();\n\n  // We'll guess that requestAnimationFrame is probably 60, but even if it's not, it's not a big deal.\n  const getMaxFps = () => vm.runtime.frameLoop.framerate === 0 ? 60 : vm.runtime.frameLoop.framerate;\n  const NUMBER_OF_POINTS = 20;\n  // An array like [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n  const labels = Array.from(Array(NUMBER_OF_POINTS).keys()).reverse();\n  const fpsElements = createChart({\n    title: msg(\"performance-framerate-title\")\n  });\n  const fpsChart = new Chart(fpsElements.canvas.getContext(\"2d\"), {\n    type: \"line\",\n    data: {\n      labels,\n      datasets: [{\n        data: Array(NUMBER_OF_POINTS).fill(-1),\n        borderWidth: lineWidth,\n        fill: fancyGraphs,\n        backgroundColor: \"#29beb8\",\n        borderColor: lineColor\n      }]\n    },\n    options: {\n      animation: fancyGraphs,\n      scales: {\n        y: {\n          suggestedMax: getMaxFps(),\n          min: 0\n        }\n      },\n      plugins: {\n        legend: {\n          display: false\n        },\n        tooltip: {\n          callbacks: {\n            label: context => msg(\"performance-framerate-graph-tooltip\", {\n              fps: context.parsed.y\n            })\n          }\n        }\n      }\n    }\n  });\n  const clonesElements = createChart({\n    title: msg(\"performance-clonecount-title\")\n  });\n  const performanceClonesChart = new Chart(clonesElements.canvas.getContext(\"2d\"), {\n    type: \"line\",\n    data: {\n      labels,\n      datasets: [{\n        data: Array(NUMBER_OF_POINTS).fill(-1),\n        borderWidth: lineWidth,\n        fill: fancyGraphs,\n        backgroundColor: \"#29beb8\",\n        borderColor: lineColor\n      }]\n    },\n    options: {\n      animation: fancyGraphs,\n      scales: {\n        y: {\n          suggestedMax: 300,\n          min: 0\n        }\n      },\n      plugins: {\n        legend: {\n          display: false\n        },\n        tooltip: {\n          callbacks: {\n            label: context => msg(\"performance-clonecount-graph-tooltip\", {\n              clones: context.parsed.y\n            })\n          }\n        }\n      }\n    }\n  });\n\n  // Holds the times of each frame drawn in the last second.\n  // The length of this list is effectively the FPS.\n  const renderTimes = [];\n\n  // The last time we pushed a new datapoint to the graph\n  let lastFpsTime = now() + 3000;\n  debug.addAfterStepCallback(() => {\n    if (isPaused()) {\n      return;\n    }\n    const time = now();\n\n    // Remove all frame times older than 1 second in renderTimes\n    while (renderTimes.length > 0 && renderTimes[0] <= time - 1000) renderTimes.shift();\n    renderTimes.push(time);\n    if (time - lastFpsTime > 1000) {\n      lastFpsTime = time;\n      const maxFps = getMaxFps();\n      const fpsData = fpsChart.data.datasets[0].data;\n      fpsData.shift();\n      fpsData.push(Math.min(renderTimes.length, maxFps));\n      // Incase we switch between 30FPS and 60FPS, update the max height of the chart.\n      fpsChart.options.scales.y.suggestedMax = maxFps;\n      const clonesData = performanceClonesChart.data.datasets[0].data;\n      clonesData.shift();\n      clonesData.push(vm.runtime._cloneCounter);\n      if (isVisible) {\n        fpsChart.update();\n        performanceClonesChart.update();\n      }\n    }\n  });\n  content.appendChild(fpsElements.title);\n  content.appendChild(fpsElements.canvas);\n  content.appendChild(clonesElements.title);\n  content.appendChild(clonesElements.canvas);\n  let pauseTime = 0;\n  onPauseChanged(paused => {\n    if (paused) {\n      pauseTime = now();\n    } else {\n      const dt = now() - pauseTime;\n      lastFpsTime += dt;\n      for (var i = 0; i < renderTimes.length; i++) {\n        renderTimes[i] += dt;\n      }\n    }\n  });\n  let isVisible = false;\n  const show = () => {\n    isVisible = true;\n  };\n  const hide = () => {\n    isVisible = false;\n  };\n  return {\n    tab,\n    content,\n    buttons: [],\n    show,\n    hide\n  };\n}","import { onPauseChanged, isPaused, singleStep, onSingleStep, getRunningThread } from \"./module.js\";\nimport LogView from \"./log-view.js\";\nimport Highlighter from \"../editor-stepping/highlighter.js\";\nconst concatInPlace = (copyInto, copyFrom) => {\n  for (const i of copyFrom) {\n    copyInto.push(i);\n  }\n};\nexport default async function createThreadsTab(_ref) {\n  let {\n    debug,\n    addon,\n    console,\n    msg\n  } = _ref;\n  const vm = addon.tab.traps.vm;\n  const tab = debug.createHeaderTab({\n    text: msg(\"tab-threads\"),\n    icon: addon.self.getResource(\"/icons/threads.svg\") /* rewritten by pull.js */\n  });\n  const logView = new LogView();\n  logView.canAutoScrollToEnd = false;\n  logView.outerElement.classList.add(\"sa-debugger-threads\");\n  logView.placeholderElement.textContent = msg(\"no-threads-running\");\n  const highlighter = new Highlighter(10, \"#ff0000\");\n  logView.generateRow = row => {\n    const root = document.createElement(\"div\");\n    root.className = \"sa-debugger-log\";\n    const isHeader = row.type === \"thread-header\";\n    const indenter = document.createElement(\"div\");\n    indenter.className = \"sa-debugger-thread-indent\";\n    indenter.style.setProperty(\"--level\", isHeader ? row.depth : row.depth + 1);\n    root.appendChild(indenter);\n    if (isHeader) {\n      root.classList.add(\"sa-debugger-thread-title\");\n      if (row.depth > 0) {\n        const icon = document.createElement(\"div\");\n        icon.className = \"sa-debugger-log-icon\";\n        root.appendChild(icon);\n      }\n      const name = document.createElement(\"div\");\n      name.textContent = row.targetName;\n      name.className = \"sa-debugger-thread-target-name\";\n      root.appendChild(name);\n      const id = document.createElement(\"div\");\n      id.className = \"sa-debugger-thread-id\";\n      id.textContent = msg(\"thread\", {\n        id: row.id\n      });\n      root.appendChild(id);\n    }\n    if (row.type === \"thread-stack\") {\n      const preview = debug.createBlockPreview(row.targetId, row.blockId);\n      if (preview) {\n        root.appendChild(preview);\n      }\n    }\n    if (row.type === \"compiled\") {\n      const el = document.createElement('div');\n      el.className = \"sa-debugger-thread-compiled\";\n      el.textContent = \"Compiled threads can't be stepped and have no stack information.\";\n      root.appendChild(el);\n    }\n    if (row.targetId && row.blockId) {\n      root.appendChild(debug.createBlockLink(debug.getTargetInfoById(row.targetId), row.blockId));\n    }\n    return {\n      root\n    };\n  };\n  logView.renderRow = (elements, row) => {\n    const {\n      root\n    } = elements;\n    root.classList.toggle(\"sa-debugger-thread-running\", !!row.running);\n  };\n  let threadInfoCache = new WeakMap();\n  const allThreadIds = new WeakMap();\n  let nextThreadId = 1;\n  const getThreadId = thread => {\n    if (!allThreadIds.has(thread)) {\n      allThreadIds.set(thread, nextThreadId++);\n    }\n    return allThreadIds.get(thread);\n  };\n  const updateContent = () => {\n    if (!logView.visible) {\n      return;\n    }\n    const newRows = [];\n    const threads = vm.runtime.threads;\n    const visitedThreads = new Set();\n    const runningThread = getRunningThread();\n    const createThreadInfo = (thread, depth) => {\n      if (visitedThreads.has(thread)) {\n        return [];\n      }\n      visitedThreads.add(thread);\n      const id = getThreadId(thread);\n      const target = thread.target;\n      if (!threadInfoCache.has(thread)) {\n        threadInfoCache.set(thread, {\n          headerItem: {\n            type: \"thread-header\",\n            depth,\n            targetName: target.getName(),\n            id\n          },\n          compiledItem: thread.isCompiled ? {\n            type: \"compiled\",\n            depth: 1\n          } : null,\n          blockCache: new WeakMap()\n        });\n      }\n      const cacheInfo = threadInfoCache.get(thread);\n      const createBlockInfo = (block, stackFrameIdx) => {\n        const blockId = block.id;\n        if (!block) return;\n        const stackFrame = thread.stackFrames[stackFrameIdx];\n        if (!cacheInfo.blockCache.has(block)) {\n          cacheInfo.blockCache.set(block, {});\n        }\n        const blockInfoMap = cacheInfo.blockCache.get(block);\n        let blockInfo = blockInfoMap[stackFrameIdx];\n        if (!blockInfo) {\n          blockInfo = blockInfoMap[stackFrameIdx] = {\n            type: \"thread-stack\",\n            depth,\n            targetId: target.id,\n            blockId\n          };\n        }\n        blockInfo.running = thread === runningThread && (thread.isCompiled || blockId === runningThread.peekStack() && stackFrameIdx === runningThread.stackFrames.length - 1);\n        const result = [blockInfo];\n        if (stackFrame && stackFrame.executionContext && stackFrame.executionContext.startedThreads) {\n          for (const thread of stackFrame.executionContext.startedThreads) {\n            concatInPlace(result, createThreadInfo(thread, depth + 1));\n          }\n        }\n        return result;\n      };\n      const topBlock = debug.getBlock(thread.target, thread.topBlock);\n      const result = [cacheInfo.headerItem];\n      if (topBlock) {\n        concatInPlace(result, createBlockInfo(topBlock, 0));\n        for (let i = 0; i < thread.stack.length; i++) {\n          const blockId = thread.stack[i];\n          if (blockId === topBlock.id) continue;\n          const block = debug.getBlock(thread.target, blockId);\n          if (block) {\n            concatInPlace(result, createBlockInfo(block, i));\n          }\n        }\n      }\n      if (cacheInfo.compiledItem) {\n        result.push(cacheInfo.compiledItem);\n      }\n      return result;\n    };\n    for (let i = 0; i < threads.length; i++) {\n      const thread = threads[i];\n      // Do not display threads used to update variable and list monitors.\n      if (thread.updateMonitor) {\n        continue;\n      }\n      concatInPlace(newRows, createThreadInfo(thread, 0));\n    }\n    logView.rows = newRows;\n    logView.queueUpdateContent();\n  };\n  debug.addAfterStepCallback(() => {\n    updateContent();\n    const runningThread = getRunningThread();\n    if (runningThread) {\n      highlighter.setGlowingThreads([runningThread]);\n    } else {\n      highlighter.setGlowingThreads([]);\n    }\n  });\n  const stepButton = debug.createHeaderButton({\n    text: msg(\"step\"),\n    icon: addon.self.getResource(\"/icons/step.svg\") /* rewritten by pull.js */,\n    description: msg(\"step-desc\")\n  });\n  stepButton.element.addEventListener(\"click\", () => {\n    singleStep();\n  });\n  const handlePauseChanged = paused => {\n    stepButton.element.style.display = paused ? \"\" : \"none\";\n    updateContent();\n  };\n  handlePauseChanged(isPaused());\n  onPauseChanged(handlePauseChanged);\n  onSingleStep(() => {\n    updateContent();\n    queueMicrotask(() => {\n      const runningIndex = logView.rows.findIndex(i => i.running);\n      if (runningIndex !== -1 && !logView.isInView(runningIndex, logView.rowHeight)) {\n        // Try to show the entire thread if we can fit it on screen\n        let found = false;\n        const maxScrollback = Math.floor(logView.height / logView.rowHeight);\n        for (let i = 1; i < maxScrollback; i++) {\n          const checkIndex = runningIndex - i;\n          if (logView.rows[checkIndex].type === \"thread-header\") {\n            logView.scrollTo(checkIndex);\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          // We somehow couldn't find the header or the stack is too big for us to show the header\n          // and the current stack item at the same time. Settle for showing as much of the stack\n          // as we can while also leaving some room on the bottom for the stack to grow.\n          logView.scrollTo(Math.max(0, runningIndex - maxScrollback + 5));\n        }\n      }\n    });\n  });\n  const show = () => {\n    logView.show();\n    updateContent();\n  };\n  const hide = () => {\n    logView.hide();\n  };\n  return {\n    tab,\n    content: logView.outerElement,\n    buttons: [stepButton],\n    show,\n    hide\n  };\n}","import { isPaused, setPaused, onPauseChanged, setup } from \"./module.js\";\nimport createLogsTab from \"./logs.js\";\nimport createThreadsTab from \"./threads.js\";\nimport createPerformanceTab from \"./performance.js\";\nimport Utils from \"../find-bar/blockly/Utils.js\";\nimport addSmallStageClass from \"../../libraries/common/cs/small-stage.js\";\nconst removeAllChildren = element => {\n  while (element.firstChild) {\n    element.removeChild(element.firstChild);\n  }\n};\nexport default async function (_ref) {\n  let {\n    addon,\n    console,\n    msg\n  } = _ref;\n  setup(addon);\n  let logsTab;\n  const messagesLoggedBeforeLogsTabLoaded = [];\n  const logMessage = function logMessage() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (logsTab) {\n      logsTab.addLog(...args);\n    } else {\n      messagesLoggedBeforeLogsTabLoaded.push(args);\n    }\n  };\n  let hasLoggedPauseError = false;\n  const pause = (_, thread) => {\n    if (addon.tab.redux.state.scratchGui.mode.isPlayerOnly) {\n      if (!hasLoggedPauseError) {\n        logMessage(msg(\"cannot-pause-player\"), thread, \"error\");\n        hasLoggedPauseError = true;\n      }\n      return;\n    }\n    setPaused(true);\n    setInterfaceVisible(true);\n  };\n  addon.tab.addBlock(\"\\u200B\\u200Bbreakpoint\\u200B\\u200B\", {\n    args: [],\n    displayName: msg(\"block-breakpoint\"),\n    callback: pause\n  });\n  addon.tab.addBlock(\"\\u200B\\u200Blog\\u200B\\u200B %s\", {\n    args: [\"content\"],\n    displayName: msg(\"block-log\"),\n    callback: (_ref2, thread) => {\n      let {\n        content\n      } = _ref2;\n      logMessage(content, thread, \"log\");\n    }\n  });\n  addon.tab.addBlock(\"\\u200B\\u200Bwarn\\u200B\\u200B %s\", {\n    args: [\"content\"],\n    displayName: msg(\"block-warn\"),\n    callback: (_ref3, thread) => {\n      let {\n        content\n      } = _ref3;\n      logMessage(content, thread, \"warn\");\n    }\n  });\n  addon.tab.addBlock(\"\\u200B\\u200Berror\\u200B\\u200B %s\", {\n    args: [\"content\"],\n    displayName: msg(\"block-error\"),\n    callback: (_ref4, thread) => {\n      let {\n        content\n      } = _ref4;\n      logMessage(content, thread, \"error\");\n    }\n  });\n  const vm = addon.tab.traps.vm;\n  await new Promise((resolve, reject) => {\n    if (vm.editingTarget) return resolve();\n    vm.runtime.once(\"PROJECT_LOADED\", resolve);\n  });\n  const ScratchBlocks = await addon.tab.traps.getBlockly();\n  const debuggerButtonOuter = document.createElement(\"div\");\n  debuggerButtonOuter.className = \"sa-debugger-container\";\n  const debuggerButton = document.createElement(\"div\");\n  debuggerButton.className = addon.tab.scratchClass(\"button_outlined-button\", \"stage-header_stage-button\");\n  const debuggerButtonContent = document.createElement(\"div\");\n  debuggerButtonContent.className = addon.tab.scratchClass(\"button_content\");\n  const debuggerButtonImage = document.createElement(\"img\");\n  debuggerButtonImage.className = addon.tab.scratchClass(\"stage-header_stage-button-icon\");\n  debuggerButtonImage.draggable = false;\n  debuggerButtonImage.src = addon.self.getResource(\"/icons/debug.svg\") /* rewritten by pull.js */;\n  debuggerButtonContent.appendChild(debuggerButtonImage);\n  debuggerButton.appendChild(debuggerButtonContent);\n  debuggerButtonOuter.appendChild(debuggerButton);\n  debuggerButton.addEventListener(\"click\", () => setInterfaceVisible(true));\n  const setHasUnreadMessage = unreadMessage => {\n    debuggerButtonContent.classList.toggle(\"sa-debugger-unread\", unreadMessage);\n  };\n  const interfaceContainer = Object.assign(document.createElement(\"div\"), {\n    className: addon.tab.scratchClass(\"card_card\", {\n      others: \"sa-debugger-interface\"\n    })\n  });\n  const interfaceHeader = Object.assign(document.createElement(\"div\"), {\n    className: addon.tab.scratchClass(\"card_header-buttons\")\n  });\n  const tabListElement = Object.assign(document.createElement(\"ul\"), {\n    className: \"sa-debugger-tabs\"\n  });\n  const buttonContainerElement = Object.assign(document.createElement(\"div\"), {\n    className: addon.tab.scratchClass(\"card_header-buttons-right\", {\n      others: \"sa-debugger-header-buttons\"\n    })\n  });\n  const tabContentContainer = Object.assign(document.createElement(\"div\"), {\n    className: \"sa-debugger-tab-content\"\n  });\n  const compilerWarning = document.createElement(\"a\");\n  compilerWarning.addEventListener(\"click\", () => {\n    addon.tab.redux.dispatch({\n      type: \"scratch-gui/modals/OPEN_MODAL\",\n      modal: \"settingsModal\"\n    });\n  });\n  compilerWarning.className = \"sa-debugger-log sa-debugger-compiler-warning\";\n  compilerWarning.textContent = \"The debugger works best when the compiler is disabled.\";\n  const updateCompilerWarningVisibility = () => {\n    compilerWarning.hidden = !vm.runtime.compilerOptions.enabled;\n  };\n  vm.on(\"COMPILER_OPTIONS_CHANGED\", updateCompilerWarningVisibility);\n  updateCompilerWarningVisibility();\n  let isInterfaceVisible = false;\n  const setInterfaceVisible = _isVisible => {\n    isInterfaceVisible = _isVisible;\n    interfaceContainer.style.display = isInterfaceVisible ? \"flex\" : \"\";\n    if (isInterfaceVisible) {\n      activeTab.show();\n    } else {\n      activeTab.hide();\n    }\n  };\n  let mouseOffsetX = 0;\n  let mouseOffsetY = 0;\n  let lastX = 0;\n  let lastY = 0;\n  const handleStartDrag = e => {\n    e.preventDefault();\n    mouseOffsetX = e.clientX - interfaceContainer.offsetLeft;\n    mouseOffsetY = e.clientY - interfaceContainer.offsetTop;\n    lastX = e.clientX;\n    lastY = e.clientY;\n    document.addEventListener(\"mouseup\", handleStopDrag);\n    document.addEventListener(\"mousemove\", handleDragInterface);\n  };\n  const handleStopDrag = () => {\n    document.removeEventListener(\"mouseup\", handleStopDrag);\n    document.removeEventListener(\"mousemove\", handleDragInterface);\n  };\n  const moveInterface = (x, y) => {\n    lastX = x;\n    lastY = y;\n    const width = (document.documentElement.clientWidth || document.body.clientWidth) - 1;\n    const height = (document.documentElement.clientHeight || document.body.clientHeight) - 1;\n    const clampedX = Math.max(0, Math.min(x - mouseOffsetX, width - interfaceContainer.offsetWidth));\n    const clampedY = Math.max(0, Math.min(y - mouseOffsetY, height - interfaceContainer.offsetHeight));\n    interfaceContainer.style.left = clampedX + \"px\";\n    interfaceContainer.style.top = clampedY + \"px\";\n  };\n  const handleDragInterface = e => {\n    e.preventDefault();\n    moveInterface(e.clientX, e.clientY);\n  };\n  window.addEventListener(\"resize\", () => {\n    moveInterface(lastX, lastY);\n  });\n  interfaceHeader.addEventListener(\"mousedown\", handleStartDrag);\n  interfaceHeader.append(tabListElement, buttonContainerElement);\n  interfaceContainer.append(interfaceHeader, compilerWarning, tabContentContainer);\n  document.body.append(interfaceContainer);\n  const createHeaderButton = _ref5 => {\n    let {\n      text,\n      icon,\n      description\n    } = _ref5;\n    const button = Object.assign(document.createElement(\"div\"), {\n      className: addon.tab.scratchClass(\"card_shrink-expand-button\"),\n      draggable: false\n    });\n    if (description) {\n      button.title = description;\n    }\n    const imageElement = Object.assign(document.createElement(\"img\"), {\n      src: icon,\n      draggable: false\n    });\n    const textElement = Object.assign(document.createElement(\"span\"), {\n      textContent: text\n    });\n    button.appendChild(imageElement);\n    button.appendChild(textElement);\n    return {\n      element: button,\n      image: imageElement,\n      text: textElement\n    };\n  };\n  const createHeaderTab = _ref6 => {\n    let {\n      text,\n      icon\n    } = _ref6;\n    const tab = document.createElement(\"li\");\n    const imageElement = Object.assign(addon.tab.recolorable(), {\n      src: icon,\n      draggable: false\n    });\n    const textElement = Object.assign(document.createElement(\"span\"), {\n      textContent: text\n    });\n    tab.appendChild(imageElement);\n    tab.appendChild(textElement);\n    return {\n      element: tab,\n      image: imageElement,\n      text: textElement\n    };\n  };\n  const unpauseButton = createHeaderButton({\n    text: msg(\"unpause\"),\n    icon: addon.self.getResource(\"/icons/play.svg\") /* rewritten by pull.js */\n  });\n  unpauseButton.element.classList.add(\"sa-debugger-unpause\");\n  unpauseButton.element.addEventListener(\"click\", () => setPaused(false));\n  const updateUnpauseVisibility = paused => {\n    unpauseButton.element.style.display = paused ? \"\" : \"none\";\n  };\n  updateUnpauseVisibility(isPaused());\n  onPauseChanged(updateUnpauseVisibility);\n  const closeButton = createHeaderButton({\n    text: msg(\"close\"),\n    icon: addon.self.getResource(\"/icons/close.svg\") /* rewritten by pull.js */\n  });\n  closeButton.element.addEventListener(\"click\", () => setInterfaceVisible(false));\n  const originalStep = vm.runtime._step;\n  const afterStepCallbacks = [];\n  vm.runtime._step = function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    const ret = originalStep.call(this, ...args);\n    for (const cb of afterStepCallbacks) {\n      cb();\n    }\n    return ret;\n  };\n  const addAfterStepCallback = cb => {\n    afterStepCallbacks.push(cb);\n  };\n  const getBlock = (target, id) => target.blocks.getBlock(id) || vm.runtime.flyoutBlocks.getBlock(id);\n  const getTargetInfoById = id => {\n    const target = vm.runtime.getTargetById(id);\n    if (target) {\n      let name = target.getName();\n      let original = target;\n      if (!target.isOriginal) {\n        name = msg(\"clone-of\", {\n          sprite: name\n        });\n        original = target.sprite.clones[0];\n      }\n      return {\n        exists: true,\n        originalId: original.id,\n        name\n      };\n    }\n    return {\n      exists: false,\n      original: null,\n      name: msg(\"unknown-sprite\")\n    };\n  };\n  const createBlockLink = (targetInfo, blockId) => {\n    const link = document.createElement(\"a\");\n    link.className = \"sa-debugger-log-link\";\n    const {\n      exists,\n      name,\n      originalId\n    } = targetInfo;\n    link.textContent = name;\n    if (exists) {\n      // We use mousedown instead of click so that you can still go to blocks when logs are rapidly scrolling\n      link.addEventListener(\"mousedown\", () => {\n        switchToSprite(originalId);\n        activateCodeTab();\n        goToBlock(blockId);\n      });\n    } else {\n      link.classList.add(\"sa-debugger-log-link-unknown\");\n    }\n    return link;\n  };\n  const switchToSprite = targetId => {\n    if (targetId !== vm.editingTarget.id) {\n      if (vm.runtime.getTargetById(targetId)) {\n        vm.setEditingTarget(targetId);\n      }\n    }\n  };\n  const activateCodeTab = () => {\n    const redux = addon.tab.redux;\n    if (redux.state.scratchGui.editorTab.activeTabIndex !== 0) {\n      redux.dispatch({\n        type: \"scratch-gui/navigation/ACTIVATE_TAB\",\n        activeTabIndex: 0\n      });\n    }\n  };\n  const goToBlock = blockId => {\n    const workspace = Blockly.getMainWorkspace();\n    const block = workspace.getBlockById(blockId);\n    if (!block) return;\n\n    // Don't scroll to blocks in the flyout\n    if (block.workspace.isFlyout) return;\n    new Utils(addon).scrollBlockIntoView(blockId);\n  };\n\n  /**\n   * @param {string} procedureCode\n   * @returns {string}\n   */\n  const formatProcedureCode = procedureCode => {\n    const customBlock = addon.tab.getCustomBlock(procedureCode);\n    if (customBlock) {\n      procedureCode = customBlock.displayName;\n    }\n    // May be slightly incorrect in some edge cases.\n    return procedureCode.replace(/%[nbs]/g, \"()\");\n  };\n\n  // May be slightly incorrect in some edge cases.\n  const formatBlocklyBlockData = jsonData => {\n    // For sample jsonData, see:\n    // https://github.com/scratchfoundation/scratch-blocks/blob/0bd1a17e66a779ec5d11f4a00c43784e3ac7a7b8/blocks_vertical/motion.js\n    // https://github.com/scratchfoundation/scratch-blocks/blob/0bd1a17e66a779ec5d11f4a00c43784e3ac7a7b8/blocks_vertical/control.js\n\n    const processSegment = index => {\n      const message = jsonData[\"message\".concat(index)];\n      const args = jsonData[\"args\".concat(index)];\n      if (!message) {\n        return null;\n      }\n      const parts = message.split(/%\\d+/g);\n      let formattedMessage = \"\";\n      for (let i = 0; i < parts.length; i++) {\n        formattedMessage += parts[i];\n        const argInfo = args && args[i];\n        if (argInfo) {\n          const type = argInfo.type;\n          if (type === \"field_vertical_separator\") {\n            // no-op\n          } else if (type === \"field_image\") {\n            const src = argInfo.src;\n            if (src.endsWith(\"rotate-left.svg\")) {\n              formattedMessage += msg(\"/_general/blocks/anticlockwise\");\n            } else if (src.endsWith(\"rotate-right.svg\")) {\n              formattedMessage += msg(\"/_general/blocks/clockwise\");\n            } else if (src.endsWith(\"green-flag.svg\")) {\n              formattedMessage += msg(\"/_general/blocks/green-flag\");\n            }\n          } else {\n            formattedMessage += \"()\";\n          }\n        }\n      }\n      return formattedMessage;\n    };\n    const parts = [];\n    let i = 0;\n    // The jsonData doesn't directly tell us how many segments it has, so we have to\n    // just keep looping until one doesn't exist.\n    while (true) {\n      const nextSegment = processSegment(i);\n      if (nextSegment) {\n        parts.push(nextSegment);\n      } else {\n        break;\n      }\n      i++;\n    }\n    return parts.join(\" \");\n  };\n  const createBlockPreview = (targetId, blockId) => {\n    const target = vm.runtime.getTargetById(targetId);\n    if (!target) {\n      return null;\n    }\n    const block = getBlock(target, blockId);\n    if (!block || block.opcode === \"text\") {\n      return null;\n    }\n    let text;\n    let category;\n    let shape;\n    let color;\n    if (block.opcode === \"data_variable\" || block.opcode === \"data_listcontents\" || block.opcode === \"argument_reporter_string_number\" || block.opcode === \"argument_reporter_boolean\") {\n      text = Object.values(block.fields)[0].value;\n      if (block.opcode === \"data_variable\") {\n        category = \"data\";\n      } else if (block.opcode === \"data_listcontents\") {\n        category = \"list\";\n      } else {\n        category = \"more\";\n      }\n      shape = \"round\";\n    } else if (block.opcode === \"procedures_call\") {\n      const proccode = block.mutation.proccode;\n      text = formatProcedureCode(proccode);\n      const customBlock = addon.tab.getCustomBlock(proccode);\n      if (customBlock) {\n        category = \"addon-custom-block\";\n      } else {\n        category = \"more\";\n      }\n    } else if (block.opcode === \"procedures_definition\") {\n      const prototypeBlockId = block.inputs.custom_block.block;\n      const prototypeBlock = getBlock(target, prototypeBlockId);\n      const proccode = prototypeBlock.mutation.proccode;\n      text = ScratchBlocks.ScratchMsgs.translate(\"PROCEDURES_DEFINITION\", \"define %1\").replace(\"%1\", formatProcedureCode(proccode));\n      category = \"more\";\n    } else {\n      var _jsonData;\n      // Try to call things like https://github.com/scratchfoundation/scratch-blocks/blob/0bd1a17e66a779ec5d11f4a00c43784e3ac7a7b8/blocks_vertical/operators.js#L36\n      var jsonData;\n      const fakeBlock = {\n        jsonInit(data) {\n          jsonData = data;\n        }\n      };\n      const blockConstructor = ScratchBlocks.Blocks[block.opcode];\n      if (blockConstructor) {\n        try {\n          blockConstructor.init.call(fakeBlock);\n        } catch (e) {\n          // ignore\n        }\n      }\n      if (!jsonData) {\n        return null;\n      }\n      text = formatBlocklyBlockData(jsonData);\n      if (!text) {\n        return null;\n      }\n      category = (_jsonData = jsonData) !== null && _jsonData !== void 0 && _jsonData.extensions.includes(\"default_extension_colors\") ? \"pen\" : jsonData.category;\n      const isStatement = jsonData.extensions && (jsonData.extensions.includes(\"shape_statement\") || jsonData.extensions.includes(\"shape_hat\") || jsonData.extensions.includes(\"shape_end\")) || \"previousStatement\" in jsonData || \"nextStatement\" in jsonData;\n      shape = isStatement ? \"stacked\" : \"round\";\n      color = jsonData.colour;\n    }\n    if (!text) {\n      return null;\n    }\n    const element = document.createElement(\"span\");\n    element.className = \"sa-debugger-block-preview sa-block-color\";\n    element.textContent = text;\n    element.dataset.shape = shape;\n    const COLOR_CLASSES = [\"motion\", \"looks\", \"sounds\", \"events\", \"control\", \"sensing\", \"operators\", \"data\", \"data-lists\", \"list\", \"more\", \"pen\", \"addon-custom-block\"];\n    if (COLOR_CLASSES.includes(category)) {\n      element.classList.add(\"sa-block-color-\".concat(category));\n    } else if (color) {\n      element.style.setProperty('--sa-block-colored-background', color);\n    }\n    return element;\n  };\n  const api = {\n    debug: {\n      createHeaderButton,\n      createHeaderTab,\n      setHasUnreadMessage,\n      addAfterStepCallback,\n      getBlock,\n      getTargetInfoById,\n      createBlockLink,\n      createBlockPreview\n    },\n    addon,\n    msg,\n    console\n  };\n  logsTab = await createLogsTab(api);\n  const threadsTab = await createThreadsTab(api);\n  const performanceTab = await createPerformanceTab(api);\n  const allTabs = [logsTab, threadsTab, performanceTab];\n  for (const message of messagesLoggedBeforeLogsTabLoaded) {\n    logsTab.addLog(...message);\n  }\n  messagesLoggedBeforeLogsTabLoaded.length = 0;\n  let activeTab;\n  const setActiveTab = tab => {\n    if (tab === activeTab) return;\n    const selectedClass = \"sa-debugger-tab-selected\";\n    if (activeTab) {\n      activeTab.hide();\n      activeTab.tab.element.classList.remove(selectedClass);\n    }\n    tab.tab.element.classList.add(selectedClass);\n    activeTab = tab;\n    removeAllChildren(tabContentContainer);\n    tabContentContainer.appendChild(tab.content);\n    removeAllChildren(buttonContainerElement);\n    buttonContainerElement.appendChild(unpauseButton.element);\n    for (const button of tab.buttons) {\n      buttonContainerElement.appendChild(button.element);\n    }\n    buttonContainerElement.appendChild(closeButton.element);\n    if (isInterfaceVisible) {\n      activeTab.show();\n    }\n  };\n  for (const tab of allTabs) {\n    tab.tab.element.addEventListener(\"click\", () => {\n      setActiveTab(tab);\n    });\n    tabListElement.appendChild(tab.tab.element);\n  }\n  setActiveTab(allTabs[0]);\n  addSmallStageClass();\n  const ogGreenFlag = vm.runtime.greenFlag;\n  vm.runtime.greenFlag = function () {\n    if (addon.settings.get(\"log_clear_greenflag\")) {\n      logsTab.clearLogs();\n    }\n    if (addon.settings.get(\"log_greenflag\")) {\n      logsTab.addLog(msg(\"log-msg-flag-clicked\"), null, \"internal\");\n    }\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    return ogGreenFlag.call(this, ...args);\n  };\n  const ogMakeClone = vm.runtime.targets[0].constructor.prototype.makeClone;\n  vm.runtime.targets[0].constructor.prototype.makeClone = function () {\n    if (addon.settings.get(\"log_failed_clone_creation\") && !vm.runtime.clonesAvailable()) {\n      logsTab.addLog(msg(\"log-msg-clone-cap\", {\n        sprite: this.getName()\n      }), vm.runtime.sequencer.activeThread, \"internal-warn\");\n    }\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    var clone = ogMakeClone.call(this, ...args);\n    if (addon.settings.get(\"log_clone_create\") && clone) {\n      logsTab.addLog(msg(\"log-msg-clone-created\", {\n        sprite: this.getName()\n      }), vm.runtime.sequencer.activeThread, \"internal\");\n    }\n    return clone;\n  };\n  const ogStartHats = vm.runtime.startHats;\n  vm.runtime.startHats = function (hat, optMatchFields) {\n    if (addon.settings.get(\"log_broadcasts\") && hat === \"event_whenbroadcastreceived\") {\n      logsTab.addLog(msg(\"log-msg-broadcasted\", {\n        broadcast: optMatchFields.BROADCAST_OPTION\n      }), vm.runtime.sequencer.activeThread, \"internal\");\n    }\n    for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n      args[_key5 - 2] = arguments[_key5];\n    }\n    return ogStartHats.call(this, hat, optMatchFields, ...args);\n  };\n  while (true) {\n    await addon.tab.waitForElement('[class^=\"stage-header_stage-size-row\"], [class^=\"stage-header_fullscreen-buttons-row_\"]', {\n      markAsSeen: true,\n      reduxEvents: [\"scratch-gui/mode/SET_PLAYER\", \"scratch-gui/mode/SET_FULL_SCREEN\", \"fontsLoaded/SET_FONTS_LOADED\", \"scratch-gui/locales/SELECT_LOCALE\"]\n    });\n    if (addon.tab.editorMode === \"editor\") {\n      addon.tab.appendToSharedSpace({\n        space: \"stageHeader\",\n        element: debuggerButtonOuter,\n        order: 0\n      });\n    } else {\n      debuggerButtonOuter.remove();\n      setInterfaceVisible(false);\n    }\n  }\n}","const SVG_NS = \"http://www.w3.org/2000/svg\";\nconst containerSvg = document.createElementNS(SVG_NS, \"svg\");\n// unfortunately we can't use display: none on this as that breaks filters\ncontainerSvg.style.position = \"fixed\";\ncontainerSvg.style.top = \"-999999px\";\ncontainerSvg.style.width = \"0\";\ncontainerSvg.style.height = \"0\";\ndocument.body.appendChild(containerSvg);\nlet nextGlowerId = 0;\nconst highlightsPerElement = new WeakMap();\nconst getHighlightersForElement = element => {\n  if (!highlightsPerElement.get(element)) {\n    highlightsPerElement.set(element, new Set());\n  }\n  return highlightsPerElement.get(element);\n};\nconst updateHighlight = (element, highlighters) => {\n  let result;\n  for (const i of highlighters) {\n    if (!result || i.priority > result.priority) {\n      result = i;\n    }\n  }\n  if (result) {\n    element.style.filter = result.filter;\n  } else {\n    element.style.filter = \"\";\n  }\n};\nconst addHighlight = (element, highlighter) => {\n  const highlighters = getHighlightersForElement(element);\n  highlighters.add(highlighter);\n  updateHighlight(element, highlighters);\n};\nconst removeHighlight = (element, highlighter) => {\n  const highlighters = getHighlightersForElement(element);\n  highlighters.delete(highlighter);\n  updateHighlight(element, highlighters);\n};\nclass Highlighter {\n  constructor(priority, color) {\n    this.priority = priority;\n    const id = \"sa_glower_filter\".concat(nextGlowerId++);\n    this.filter = \"url(\\\"#\".concat(id, \"\\\")\");\n    this.previousElements = new Set();\n    const filterElement = document.createElementNS(SVG_NS, \"filter\");\n    filterElement.id = id;\n    filterElement.setAttribute(\"width\", \"180%\");\n    filterElement.setAttribute(\"height\", \"160%\");\n    filterElement.setAttribute(\"x\", \"-40%\");\n    filterElement.setAttribute(\"y\", \"-30%\");\n    const filterBlur = document.createElementNS(SVG_NS, \"feGaussianBlur\");\n    filterBlur.setAttribute(\"in\", \"SourceGraphic\");\n    filterBlur.setAttribute(\"stdDeviation\", \"4\");\n    filterElement.appendChild(filterBlur);\n    const filterTransfer = document.createElementNS(SVG_NS, \"feComponentTransfer\");\n    filterTransfer.setAttribute(\"result\", \"outBlur\");\n    filterElement.appendChild(filterTransfer);\n    const filterTransferTable = document.createElementNS(SVG_NS, \"feFuncA\");\n    filterTransferTable.setAttribute(\"type\", \"table\");\n    filterTransferTable.setAttribute(\"tableValues\", \"0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\");\n    filterTransfer.appendChild(filterTransferTable);\n    const filterFlood = document.createElementNS(SVG_NS, \"feFlood\");\n    filterFlood.setAttribute(\"flood-opacity\", \"1\");\n    filterFlood.setAttribute(\"result\", \"outColor\");\n    filterElement.appendChild(filterFlood);\n    this.filterFlood = filterFlood;\n    const filterComposite = document.createElementNS(SVG_NS, \"feComposite\");\n    filterComposite.setAttribute(\"in\", \"outColor\");\n    filterComposite.setAttribute(\"in2\", \"outBlur\");\n    filterComposite.setAttribute(\"operator\", \"in\");\n    filterComposite.setAttribute(\"result\", \"outGlow\");\n    filterElement.appendChild(filterComposite);\n    const filterFinalComposite = document.createElementNS(SVG_NS, \"feComposite\");\n    filterFinalComposite.setAttribute(\"in\", \"SourceGraphic\");\n    filterFinalComposite.setAttribute(\"in2\", \"outGlow\");\n    filterFinalComposite.setAttribute(\"operator\", \"over\");\n    filterElement.appendChild(filterFinalComposite);\n    containerSvg.appendChild(filterElement);\n    this.setColor(color);\n  }\n  setColor(color) {\n    this.filterFlood.setAttribute(\"flood-color\", color);\n  }\n  setGlowingThreads(threads) {\n    const elementsToHighlight = new Set();\n    const workspace = Blockly.getMainWorkspace();\n    if (workspace) {\n      for (const thread of threads) {\n        thread.stack.forEach(blockId => {\n          const block = workspace.getBlockById(blockId);\n          if (!block) {\n            return;\n          }\n          const childblock = thread.stack.find(i => {\n            let b = block;\n            while (b.childBlocks_.length) {\n              b = b.childBlocks_[b.childBlocks_.length - 1];\n              if (i === b.id) return true;\n            }\n            return false;\n          });\n          if (!childblock && block.svgPath_) {\n            const svgPath = block.svgPath_;\n            elementsToHighlight.add(svgPath);\n          }\n        });\n      }\n    }\n    for (const element of this.previousElements) {\n      if (!elementsToHighlight.has(element)) {\n        removeHighlight(element, this);\n      }\n    }\n    for (const element of elementsToHighlight) {\n      if (!this.previousElements.has(element)) {\n        addHighlight(element, this);\n      }\n    }\n    this.previousElements = elementsToHighlight;\n  }\n}\nexport default Highlighter;","// From https://github.com/scratchfoundation/scratch-gui/blob/develop/src/lib/download-blob.js\nexport default (filename, blob) => {\n  const downloadLink = document.createElement(\"a\");\n  document.body.appendChild(downloadLink);\n\n  // Use special ms version if available to get it working on Edge.\n  if (navigator.msSaveOrOpenBlob) {\n    navigator.msSaveOrOpenBlob(blob, filename);\n    return;\n  }\n  if (\"download\" in HTMLAnchorElement.prototype) {\n    const url = window.URL.createObjectURL(blob);\n    downloadLink.href = url;\n    downloadLink.download = filename;\n    downloadLink.type = blob.type;\n    downloadLink.click();\n    // remove the link after a timeout to prevent a crash on iOS 13 Safari\n    window.setTimeout(() => {\n      document.body.removeChild(downloadLink);\n      window.URL.revokeObjectURL(url);\n    }, 1000);\n  } else {\n    // iOS 12 Safari, open a new page and set href to data-uri\n    let popup = window.open(\"\", \"_blank\");\n    const reader = new FileReader();\n    reader.onloadend = function () {\n      popup.location.href = reader.result;\n      popup = null;\n    };\n    reader.readAsDataURL(blob);\n  }\n};","export default function addSmallStageClass() {\n  // TW: no-op; sa-small-stage class is handled by scratch-gui\n}","function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */\n!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : (t = \"undefined\" != typeof globalThis ? globalThis : t || self).Chart = e();\n}(this, function () {\n  \"use strict\";\n\n  function t() {}\n  const e = function () {\n    let t = 0;\n    return function () {\n      return t++;\n    };\n  }();\n  function i(t) {\n    return null == t;\n  }\n  function s(t) {\n    if (Array.isArray && Array.isArray(t)) return !0;\n    const e = Object.prototype.toString.call(t);\n    return \"[object\" === e.slice(0, 7) && \"Array]\" === e.slice(-6);\n  }\n  function n(t) {\n    return null !== t && \"[object Object]\" === Object.prototype.toString.call(t);\n  }\n  const o = t => (\"number\" == typeof t || t instanceof Number) && isFinite(+t);\n  function a(t, e) {\n    return o(t) ? t : e;\n  }\n  function r(t, e) {\n    return void 0 === t ? e : t;\n  }\n  const l = (t, e) => \"string\" == typeof t && t.endsWith(\"%\") ? parseFloat(t) / 100 : t / e,\n    h = (t, e) => \"string\" == typeof t && t.endsWith(\"%\") ? parseFloat(t) / 100 * e : +t;\n  function c(t, e, i) {\n    if (t && \"function\" == typeof t.call) return t.apply(i, e);\n  }\n  function d(t, e, i, o) {\n    let a, r, l;\n    if (s(t)) {\n      if (r = t.length, o) for (a = r - 1; a >= 0; a--) e.call(i, t[a], a);else for (a = 0; a < r; a++) e.call(i, t[a], a);\n    } else if (n(t)) for (l = Object.keys(t), r = l.length, a = 0; a < r; a++) e.call(i, t[l[a]], l[a]);\n  }\n  function u(t, e) {\n    let i, s, n, o;\n    if (!t || !e || t.length !== e.length) return !1;\n    for (i = 0, s = t.length; i < s; ++i) if (n = t[i], o = e[i], n.datasetIndex !== o.datasetIndex || n.index !== o.index) return !1;\n    return !0;\n  }\n  function f(t) {\n    if (s(t)) return t.map(f);\n    if (n(t)) {\n      const e = Object.create(null),\n        i = Object.keys(t),\n        s = i.length;\n      let n = 0;\n      for (; n < s; ++n) e[i[n]] = f(t[i[n]]);\n      return e;\n    }\n    return t;\n  }\n  function g(t) {\n    return -1 === [\"__proto__\", \"prototype\", \"constructor\"].indexOf(t);\n  }\n  function p(t, e, i, s) {\n    if (!g(t)) return;\n    const o = e[t],\n      a = i[t];\n    n(o) && n(a) ? m(o, a, s) : e[t] = f(a);\n  }\n  function m(t, e, i) {\n    const o = s(e) ? e : [e],\n      a = o.length;\n    if (!n(t)) return t;\n    const r = (i = i || {}).merger || p;\n    for (let s = 0; s < a; ++s) {\n      if (!n(e = o[s])) continue;\n      const a = Object.keys(e);\n      for (let s = 0, n = a.length; s < n; ++s) r(a[s], t, e, i);\n    }\n    return t;\n  }\n  function b(t, e) {\n    return m(t, e, {\n      merger: x\n    });\n  }\n  function x(t, e, i) {\n    if (!g(t)) return;\n    const s = e[t],\n      o = i[t];\n    n(s) && n(o) ? b(s, o) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = f(o));\n  }\n  const _ = {\n    \"\": t => t,\n    x: t => t.x,\n    y: t => t.y\n  };\n  function y(t, e) {\n    const i = _[e] || (_[e] = function (t) {\n      const e = v(t);\n      return t => {\n        for (const i of e) {\n          if (\"\" === i) break;\n          t = t && t[i];\n        }\n        return t;\n      };\n    }(e));\n    return i(t);\n  }\n  function v(t) {\n    const e = t.split(\".\"),\n      i = [];\n    let s = \"\";\n    for (const t of e) s += t, s.endsWith(\"\\\\\") ? s = s.slice(0, -1) + \".\" : (i.push(s), s = \"\");\n    return i;\n  }\n  function w(t) {\n    return t.charAt(0).toUpperCase() + t.slice(1);\n  }\n  const M = t => void 0 !== t,\n    k = t => \"function\" == typeof t,\n    S = (t, e) => {\n      if (t.size !== e.size) return !1;\n      for (const i of t) if (!e.has(i)) return !1;\n      return !0;\n    };\n  function P(t) {\n    return \"mouseup\" === t.type || \"click\" === t.type || \"contextmenu\" === t.type;\n  }\n  const D = Math.PI,\n    O = 2 * D,\n    C = O + D,\n    A = Number.POSITIVE_INFINITY,\n    T = D / 180,\n    L = D / 2,\n    E = D / 4,\n    R = 2 * D / 3,\n    I = Math.log10,\n    z = Math.sign;\n  function F(t) {\n    const e = Math.round(t);\n    t = N(t, e, t / 1e3) ? e : t;\n    const i = Math.pow(10, Math.floor(I(t))),\n      s = t / i;\n    return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * i;\n  }\n  function V(t) {\n    const e = [],\n      i = Math.sqrt(t);\n    let s;\n    for (s = 1; s < i; s++) t % s == 0 && (e.push(s), e.push(t / s));\n    return i === (0 | i) && e.push(i), e.sort((t, e) => t - e).pop(), e;\n  }\n  function B(t) {\n    return !isNaN(parseFloat(t)) && isFinite(t);\n  }\n  function N(t, e, i) {\n    return Math.abs(t - e) < i;\n  }\n  function W(t, e) {\n    const i = Math.round(t);\n    return i - e <= t && i + e >= t;\n  }\n  function j(t, e, i) {\n    let s, n, o;\n    for (s = 0, n = t.length; s < n; s++) o = t[s][i], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o));\n  }\n  function H(t) {\n    return t * (D / 180);\n  }\n  function $(t) {\n    return t * (180 / D);\n  }\n  function Y(t) {\n    if (!o(t)) return;\n    let e = 1,\n      i = 0;\n    for (; Math.round(t * e) / e !== t;) e *= 10, i++;\n    return i;\n  }\n  function U(t, e) {\n    const i = e.x - t.x,\n      s = e.y - t.y,\n      n = Math.sqrt(i * i + s * s);\n    let o = Math.atan2(s, i);\n    return o < -.5 * D && (o += O), {\n      angle: o,\n      distance: n\n    };\n  }\n  function X(t, e) {\n    return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));\n  }\n  function q(t, e) {\n    return (t - e + C) % O - D;\n  }\n  function K(t) {\n    return (t % O + O) % O;\n  }\n  function G(t, e, i, s) {\n    const n = K(t),\n      o = K(e),\n      a = K(i),\n      r = K(o - n),\n      l = K(a - n),\n      h = K(n - o),\n      c = K(n - a);\n    return n === o || n === a || s && o === a || r > l && h < c;\n  }\n  function Z(t, e, i) {\n    return Math.max(e, Math.min(i, t));\n  }\n  function J(t) {\n    return Z(t, -32768, 32767);\n  }\n  function Q(t, e, i) {\n    let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-6;\n    return t >= Math.min(e, i) - s && t <= Math.max(e, i) + s;\n  }\n  function tt(t, e, i) {\n    i = i || (i => t[i] < e);\n    let s,\n      n = t.length - 1,\n      o = 0;\n    for (; n - o > 1;) s = o + n >> 1, i(s) ? o = s : n = s;\n    return {\n      lo: o,\n      hi: n\n    };\n  }\n  const et = (t, e, i, s) => tt(t, i, s ? s => t[s][e] <= i : s => t[s][e] < i),\n    it = (t, e, i) => tt(t, i, s => t[s][e] >= i);\n  function st(t, e, i) {\n    let s = 0,\n      n = t.length;\n    for (; s < n && t[s] < e;) s++;\n    for (; n > s && t[n - 1] > i;) n--;\n    return s > 0 || n < t.length ? t.slice(s, n) : t;\n  }\n  const nt = [\"push\", \"pop\", \"shift\", \"splice\", \"unshift\"];\n  function ot(t, e) {\n    t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, \"_chartjs\", {\n      configurable: !0,\n      enumerable: !1,\n      value: {\n        listeners: [e]\n      }\n    }), nt.forEach(e => {\n      const i = \"_onData\" + w(e),\n        s = t[e];\n      Object.defineProperty(t, e, {\n        configurable: !0,\n        enumerable: !1,\n        value() {\n          for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {\n            e[_key] = arguments[_key];\n          }\n          const n = s.apply(this, e);\n          return t._chartjs.listeners.forEach(t => {\n            \"function\" == typeof t[i] && t[i](...e);\n          }), n;\n        }\n      });\n    }));\n  }\n  function at(t, e) {\n    const i = t._chartjs;\n    if (!i) return;\n    const s = i.listeners,\n      n = s.indexOf(e);\n    -1 !== n && s.splice(n, 1), s.length > 0 || (nt.forEach(e => {\n      delete t[e];\n    }), delete t._chartjs);\n  }\n  function rt(t) {\n    const e = new Set();\n    let i, s;\n    for (i = 0, s = t.length; i < s; ++i) e.add(t[i]);\n    return e.size === s ? t : Array.from(e);\n  }\n  const lt = \"undefined\" == typeof window ? function (t) {\n    return t();\n  } : window.requestAnimationFrame;\n  function ht(t, e, i) {\n    const s = i || (t => Array.prototype.slice.call(t));\n    let n = !1,\n      o = [];\n    return function () {\n      for (var _len2 = arguments.length, i = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        i[_key2] = arguments[_key2];\n      }\n      o = s(i), n || (n = !0, lt.call(window, () => {\n        n = !1, t.apply(e, o);\n      }));\n    };\n  }\n  function ct(t, e) {\n    let i;\n    return function () {\n      for (var _len3 = arguments.length, s = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        s[_key3] = arguments[_key3];\n      }\n      return e ? (clearTimeout(i), i = setTimeout(t, e, s)) : t.apply(this, s), e;\n    };\n  }\n  const dt = t => \"start\" === t ? \"left\" : \"end\" === t ? \"right\" : \"center\",\n    ut = (t, e, i) => \"start\" === t ? e : \"end\" === t ? i : (e + i) / 2,\n    ft = (t, e, i, s) => t === (s ? \"left\" : \"right\") ? i : \"center\" === t ? (e + i) / 2 : e;\n  function gt(t, e, i) {\n    const s = e.length;\n    let n = 0,\n      o = s;\n    if (t._sorted) {\n      const {\n          iScale: a,\n          _parsed: r\n        } = t,\n        l = a.axis,\n        {\n          min: h,\n          max: c,\n          minDefined: d,\n          maxDefined: u\n        } = a.getUserBounds();\n      d && (n = Z(Math.min(et(r, a.axis, h).lo, i ? s : et(e, l, a.getPixelForValue(h)).lo), 0, s - 1)), o = u ? Z(Math.max(et(r, a.axis, c, !0).hi + 1, i ? 0 : et(e, l, a.getPixelForValue(c), !0).hi + 1), n, s) - n : s - n;\n    }\n    return {\n      start: n,\n      count: o\n    };\n  }\n  function pt(t) {\n    const {\n        xScale: e,\n        yScale: i,\n        _scaleRanges: s\n      } = t,\n      n = {\n        xmin: e.min,\n        xmax: e.max,\n        ymin: i.min,\n        ymax: i.max\n      };\n    if (!s) return t._scaleRanges = n, !0;\n    const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;\n    return Object.assign(s, n), o;\n  }\n  var mt = new class {\n    constructor() {\n      this._request = null, this._charts = new Map(), this._running = !1, this._lastDate = void 0;\n    }\n    _notify(t, e, i, s) {\n      const n = e.listeners[s],\n        o = e.duration;\n      n.forEach(s => s({\n        chart: t,\n        initial: e.initial,\n        numSteps: o,\n        currentStep: Math.min(i - e.start, o)\n      }));\n    }\n    _refresh() {\n      this._request || (this._running = !0, this._request = lt.call(window, () => {\n        this._update(), this._request = null, this._running && this._refresh();\n      }));\n    }\n    _update() {\n      let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();\n      let e = 0;\n      this._charts.forEach((i, s) => {\n        if (!i.running || !i.items.length) return;\n        const n = i.items;\n        let o,\n          a = n.length - 1,\n          r = !1;\n        for (; a >= 0; --a) o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop());\n        r && (s.draw(), this._notify(s, i, t, \"progress\")), n.length || (i.running = !1, this._notify(s, i, t, \"complete\"), i.initial = !1), e += n.length;\n      }), this._lastDate = t, 0 === e && (this._running = !1);\n    }\n    _getAnims(t) {\n      const e = this._charts;\n      let i = e.get(t);\n      return i || (i = {\n        running: !1,\n        initial: !0,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      }, e.set(t, i)), i;\n    }\n    listen(t, e, i) {\n      this._getAnims(t).listeners[e].push(i);\n    }\n    add(t, e) {\n      e && e.length && this._getAnims(t).items.push(...e);\n    }\n    has(t) {\n      return this._getAnims(t).items.length > 0;\n    }\n    start(t) {\n      const e = this._charts.get(t);\n      e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((t, e) => Math.max(t, e._duration), 0), this._refresh());\n    }\n    running(t) {\n      if (!this._running) return !1;\n      const e = this._charts.get(t);\n      return !!(e && e.running && e.items.length);\n    }\n    stop(t) {\n      const e = this._charts.get(t);\n      if (!e || !e.items.length) return;\n      const i = e.items;\n      let s = i.length - 1;\n      for (; s >= 0; --s) i[s].cancel();\n      e.items = [], this._notify(t, e, Date.now(), \"complete\");\n    }\n    remove(t) {\n      return this._charts.delete(t);\n    }\n  }();\n  /*!\n   * @kurkle/color v0.2.1\n   * https://github.com/kurkle/color#readme\n   * (c) 2022 Jukka Kurkela\n   * Released under the MIT License\n   */\n  function bt(t) {\n    return t + .5 | 0;\n  }\n  const xt = (t, e, i) => Math.max(Math.min(t, i), e);\n  function _t(t) {\n    return xt(bt(2.55 * t), 0, 255);\n  }\n  function yt(t) {\n    return xt(bt(255 * t), 0, 255);\n  }\n  function vt(t) {\n    return xt(bt(t / 2.55) / 100, 0, 1);\n  }\n  function wt(t) {\n    return xt(bt(100 * t), 0, 100);\n  }\n  const Mt = {\n      0: 0,\n      1: 1,\n      2: 2,\n      3: 3,\n      4: 4,\n      5: 5,\n      6: 6,\n      7: 7,\n      8: 8,\n      9: 9,\n      A: 10,\n      B: 11,\n      C: 12,\n      D: 13,\n      E: 14,\n      F: 15,\n      a: 10,\n      b: 11,\n      c: 12,\n      d: 13,\n      e: 14,\n      f: 15\n    },\n    kt = [...\"0123456789ABCDEF\"],\n    St = t => kt[15 & t],\n    Pt = t => kt[(240 & t) >> 4] + kt[15 & t],\n    Dt = t => (240 & t) >> 4 == (15 & t);\n  function Ot(t) {\n    var e = (t => Dt(t.r) && Dt(t.g) && Dt(t.b) && Dt(t.a))(t) ? St : Pt;\n    return t ? \"#\" + e(t.r) + e(t.g) + e(t.b) + ((t, e) => t < 255 ? e(t) : \"\")(t.a, e) : void 0;\n  }\n  const Ct = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n  function At(t, e, i) {\n    const s = e * Math.min(i, 1 - i),\n      n = function n(e) {\n        let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (e + t / 30) % 12;\n        return i - s * Math.max(Math.min(n - 3, 9 - n, 1), -1);\n      };\n    return [n(0), n(8), n(4)];\n  }\n  function Tt(t, e, i) {\n    const s = function s(_s2) {\n      let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (_s2 + t / 60) % 6;\n      return i - i * e * Math.max(Math.min(n, 4 - n, 1), 0);\n    };\n    return [s(5), s(3), s(1)];\n  }\n  function Lt(t, e, i) {\n    const s = At(t, 1, .5);\n    let n;\n    for (e + i > 1 && (n = 1 / (e + i), e *= n, i *= n), n = 0; n < 3; n++) s[n] *= 1 - e - i, s[n] += e;\n    return s;\n  }\n  function Et(t) {\n    const e = t.r / 255,\n      i = t.g / 255,\n      s = t.b / 255,\n      n = Math.max(e, i, s),\n      o = Math.min(e, i, s),\n      a = (n + o) / 2;\n    let r, l, h;\n    return n !== o && (h = n - o, l = a > .5 ? h / (2 - n - o) : h / (n + o), r = function (t, e, i, s, n) {\n      return t === n ? (e - i) / s + (e < i ? 6 : 0) : e === n ? (i - t) / s + 2 : (t - e) / s + 4;\n    }(e, i, s, h, n), r = 60 * r + .5), [0 | r, l || 0, a];\n  }\n  function Rt(t, e, i, s) {\n    return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, s)).map(yt);\n  }\n  function It(t, e, i) {\n    return Rt(At, t, e, i);\n  }\n  function zt(t) {\n    return (t % 360 + 360) % 360;\n  }\n  function Ft(t) {\n    const e = Ct.exec(t);\n    let i,\n      s = 255;\n    if (!e) return;\n    e[5] !== i && (s = e[6] ? _t(+e[5]) : yt(+e[5]));\n    const n = zt(+e[2]),\n      o = +e[3] / 100,\n      a = +e[4] / 100;\n    return i = \"hwb\" === e[1] ? function (t, e, i) {\n      return Rt(Lt, t, e, i);\n    }(n, o, a) : \"hsv\" === e[1] ? function (t, e, i) {\n      return Rt(Tt, t, e, i);\n    }(n, o, a) : It(n, o, a), {\n      r: i[0],\n      g: i[1],\n      b: i[2],\n      a: s\n    };\n  }\n  const Vt = {\n      x: \"dark\",\n      Z: \"light\",\n      Y: \"re\",\n      X: \"blu\",\n      W: \"gr\",\n      V: \"medium\",\n      U: \"slate\",\n      A: \"ee\",\n      T: \"ol\",\n      S: \"or\",\n      B: \"ra\",\n      C: \"lateg\",\n      D: \"ights\",\n      R: \"in\",\n      Q: \"turquois\",\n      E: \"hi\",\n      P: \"ro\",\n      O: \"al\",\n      N: \"le\",\n      M: \"de\",\n      L: \"yello\",\n      F: \"en\",\n      K: \"ch\",\n      G: \"arks\",\n      H: \"ea\",\n      I: \"ightg\",\n      J: \"wh\"\n    },\n    Bt = {\n      OiceXe: \"f0f8ff\",\n      antiquewEte: \"faebd7\",\n      aqua: \"ffff\",\n      aquamarRe: \"7fffd4\",\n      azuY: \"f0ffff\",\n      beige: \"f5f5dc\",\n      bisque: \"ffe4c4\",\n      black: \"0\",\n      blanKedOmond: \"ffebcd\",\n      Xe: \"ff\",\n      XeviTet: \"8a2be2\",\n      bPwn: \"a52a2a\",\n      burlywood: \"deb887\",\n      caMtXe: \"5f9ea0\",\n      KartYuse: \"7fff00\",\n      KocTate: \"d2691e\",\n      cSO: \"ff7f50\",\n      cSnflowerXe: \"6495ed\",\n      cSnsilk: \"fff8dc\",\n      crimson: \"dc143c\",\n      cyan: \"ffff\",\n      xXe: \"8b\",\n      xcyan: \"8b8b\",\n      xgTMnPd: \"b8860b\",\n      xWay: \"a9a9a9\",\n      xgYF: \"6400\",\n      xgYy: \"a9a9a9\",\n      xkhaki: \"bdb76b\",\n      xmagFta: \"8b008b\",\n      xTivegYF: \"556b2f\",\n      xSange: \"ff8c00\",\n      xScEd: \"9932cc\",\n      xYd: \"8b0000\",\n      xsOmon: \"e9967a\",\n      xsHgYF: \"8fbc8f\",\n      xUXe: \"483d8b\",\n      xUWay: \"2f4f4f\",\n      xUgYy: \"2f4f4f\",\n      xQe: \"ced1\",\n      xviTet: \"9400d3\",\n      dAppRk: \"ff1493\",\n      dApskyXe: \"bfff\",\n      dimWay: \"696969\",\n      dimgYy: \"696969\",\n      dodgerXe: \"1e90ff\",\n      fiYbrick: \"b22222\",\n      flSOwEte: \"fffaf0\",\n      foYstWAn: \"228b22\",\n      fuKsia: \"ff00ff\",\n      gaRsbSo: \"dcdcdc\",\n      ghostwEte: \"f8f8ff\",\n      gTd: \"ffd700\",\n      gTMnPd: \"daa520\",\n      Way: \"808080\",\n      gYF: \"8000\",\n      gYFLw: \"adff2f\",\n      gYy: \"808080\",\n      honeyMw: \"f0fff0\",\n      hotpRk: \"ff69b4\",\n      RdianYd: \"cd5c5c\",\n      Rdigo: \"4b0082\",\n      ivSy: \"fffff0\",\n      khaki: \"f0e68c\",\n      lavFMr: \"e6e6fa\",\n      lavFMrXsh: \"fff0f5\",\n      lawngYF: \"7cfc00\",\n      NmoncEffon: \"fffacd\",\n      ZXe: \"add8e6\",\n      ZcSO: \"f08080\",\n      Zcyan: \"e0ffff\",\n      ZgTMnPdLw: \"fafad2\",\n      ZWay: \"d3d3d3\",\n      ZgYF: \"90ee90\",\n      ZgYy: \"d3d3d3\",\n      ZpRk: \"ffb6c1\",\n      ZsOmon: \"ffa07a\",\n      ZsHgYF: \"20b2aa\",\n      ZskyXe: \"87cefa\",\n      ZUWay: \"778899\",\n      ZUgYy: \"778899\",\n      ZstAlXe: \"b0c4de\",\n      ZLw: \"ffffe0\",\n      lime: \"ff00\",\n      limegYF: \"32cd32\",\n      lRF: \"faf0e6\",\n      magFta: \"ff00ff\",\n      maPon: \"800000\",\n      VaquamarRe: \"66cdaa\",\n      VXe: \"cd\",\n      VScEd: \"ba55d3\",\n      VpurpN: \"9370db\",\n      VsHgYF: \"3cb371\",\n      VUXe: \"7b68ee\",\n      VsprRggYF: \"fa9a\",\n      VQe: \"48d1cc\",\n      VviTetYd: \"c71585\",\n      midnightXe: \"191970\",\n      mRtcYam: \"f5fffa\",\n      mistyPse: \"ffe4e1\",\n      moccasR: \"ffe4b5\",\n      navajowEte: \"ffdead\",\n      navy: \"80\",\n      Tdlace: \"fdf5e6\",\n      Tive: \"808000\",\n      TivedBb: \"6b8e23\",\n      Sange: \"ffa500\",\n      SangeYd: \"ff4500\",\n      ScEd: \"da70d6\",\n      pOegTMnPd: \"eee8aa\",\n      pOegYF: \"98fb98\",\n      pOeQe: \"afeeee\",\n      pOeviTetYd: \"db7093\",\n      papayawEp: \"ffefd5\",\n      pHKpuff: \"ffdab9\",\n      peru: \"cd853f\",\n      pRk: \"ffc0cb\",\n      plum: \"dda0dd\",\n      powMrXe: \"b0e0e6\",\n      purpN: \"800080\",\n      YbeccapurpN: \"663399\",\n      Yd: \"ff0000\",\n      Psybrown: \"bc8f8f\",\n      PyOXe: \"4169e1\",\n      saddNbPwn: \"8b4513\",\n      sOmon: \"fa8072\",\n      sandybPwn: \"f4a460\",\n      sHgYF: \"2e8b57\",\n      sHshell: \"fff5ee\",\n      siFna: \"a0522d\",\n      silver: \"c0c0c0\",\n      skyXe: \"87ceeb\",\n      UXe: \"6a5acd\",\n      UWay: \"708090\",\n      UgYy: \"708090\",\n      snow: \"fffafa\",\n      sprRggYF: \"ff7f\",\n      stAlXe: \"4682b4\",\n      tan: \"d2b48c\",\n      teO: \"8080\",\n      tEstN: \"d8bfd8\",\n      tomato: \"ff6347\",\n      Qe: \"40e0d0\",\n      viTet: \"ee82ee\",\n      JHt: \"f5deb3\",\n      wEte: \"ffffff\",\n      wEtesmoke: \"f5f5f5\",\n      Lw: \"ffff00\",\n      LwgYF: \"9acd32\"\n    };\n  let Nt;\n  function Wt(t) {\n    Nt || (Nt = function () {\n      const t = {},\n        e = Object.keys(Bt),\n        i = Object.keys(Vt);\n      let s, n, o, a, r;\n      for (s = 0; s < e.length; s++) {\n        for (a = r = e[s], n = 0; n < i.length; n++) o = i[n], r = r.replace(o, Vt[o]);\n        o = parseInt(Bt[a], 16), t[r] = [o >> 16 & 255, o >> 8 & 255, 255 & o];\n      }\n      return t;\n    }(), Nt.transparent = [0, 0, 0, 0]);\n    const e = Nt[t.toLowerCase()];\n    return e && {\n      r: e[0],\n      g: e[1],\n      b: e[2],\n      a: 4 === e.length ? e[3] : 255\n    };\n  }\n  const jt = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n  const Ht = t => t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055,\n    $t = t => t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n  function Yt(t, e, i) {\n    if (t) {\n      let s = Et(t);\n      s[e] = Math.max(0, Math.min(s[e] + s[e] * i, 0 === e ? 360 : 1)), s = It(s), t.r = s[0], t.g = s[1], t.b = s[2];\n    }\n  }\n  function Ut(t, e) {\n    return t ? Object.assign(e || {}, t) : t;\n  }\n  function Xt(t) {\n    var e = {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 255\n    };\n    return Array.isArray(t) ? t.length >= 3 && (e = {\n      r: t[0],\n      g: t[1],\n      b: t[2],\n      a: 255\n    }, t.length > 3 && (e.a = yt(t[3]))) : (e = Ut(t, {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 1\n    })).a = yt(e.a), e;\n  }\n  function qt(t) {\n    return \"r\" === t.charAt(0) ? function (t) {\n      const e = jt.exec(t);\n      let i,\n        s,\n        n,\n        o = 255;\n      if (e) {\n        if (e[7] !== i) {\n          const t = +e[7];\n          o = e[8] ? _t(t) : xt(255 * t, 0, 255);\n        }\n        return i = +e[1], s = +e[3], n = +e[5], i = 255 & (e[2] ? _t(i) : xt(i, 0, 255)), s = 255 & (e[4] ? _t(s) : xt(s, 0, 255)), n = 255 & (e[6] ? _t(n) : xt(n, 0, 255)), {\n          r: i,\n          g: s,\n          b: n,\n          a: o\n        };\n      }\n    }(t) : Ft(t);\n  }\n  class Kt {\n    constructor(t) {\n      if (t instanceof Kt) return t;\n      const e = typeof t;\n      let i;\n      var s, n, o;\n      \"object\" === e ? i = Xt(t) : \"string\" === e && (o = (s = t).length, \"#\" === s[0] && (4 === o || 5 === o ? n = {\n        r: 255 & 17 * Mt[s[1]],\n        g: 255 & 17 * Mt[s[2]],\n        b: 255 & 17 * Mt[s[3]],\n        a: 5 === o ? 17 * Mt[s[4]] : 255\n      } : 7 !== o && 9 !== o || (n = {\n        r: Mt[s[1]] << 4 | Mt[s[2]],\n        g: Mt[s[3]] << 4 | Mt[s[4]],\n        b: Mt[s[5]] << 4 | Mt[s[6]],\n        a: 9 === o ? Mt[s[7]] << 4 | Mt[s[8]] : 255\n      })), i = n || Wt(t) || qt(t)), this._rgb = i, this._valid = !!i;\n    }\n    get valid() {\n      return this._valid;\n    }\n    get rgb() {\n      var t = Ut(this._rgb);\n      return t && (t.a = vt(t.a)), t;\n    }\n    set rgb(t) {\n      this._rgb = Xt(t);\n    }\n    rgbString() {\n      return this._valid ? (t = this._rgb) && (t.a < 255 ? \"rgba(\".concat(t.r, \", \").concat(t.g, \", \").concat(t.b, \", \").concat(vt(t.a), \")\") : \"rgb(\".concat(t.r, \", \").concat(t.g, \", \").concat(t.b, \")\")) : void 0;\n      var t;\n    }\n    hexString() {\n      return this._valid ? Ot(this._rgb) : void 0;\n    }\n    hslString() {\n      return this._valid ? function (t) {\n        if (!t) return;\n        const e = Et(t),\n          i = e[0],\n          s = wt(e[1]),\n          n = wt(e[2]);\n        return t.a < 255 ? \"hsla(\".concat(i, \", \").concat(s, \"%, \").concat(n, \"%, \").concat(vt(t.a), \")\") : \"hsl(\".concat(i, \", \").concat(s, \"%, \").concat(n, \"%)\");\n      }(this._rgb) : void 0;\n    }\n    mix(t, e) {\n      if (t) {\n        const i = this.rgb,\n          s = t.rgb;\n        let n;\n        const o = e === n ? .5 : e,\n          a = 2 * o - 1,\n          r = i.a - s.a,\n          l = ((a * r == -1 ? a : (a + r) / (1 + a * r)) + 1) / 2;\n        n = 1 - l, i.r = 255 & l * i.r + n * s.r + .5, i.g = 255 & l * i.g + n * s.g + .5, i.b = 255 & l * i.b + n * s.b + .5, i.a = o * i.a + (1 - o) * s.a, this.rgb = i;\n      }\n      return this;\n    }\n    interpolate(t, e) {\n      return t && (this._rgb = function (t, e, i) {\n        const s = $t(vt(t.r)),\n          n = $t(vt(t.g)),\n          o = $t(vt(t.b));\n        return {\n          r: yt(Ht(s + i * ($t(vt(e.r)) - s))),\n          g: yt(Ht(n + i * ($t(vt(e.g)) - n))),\n          b: yt(Ht(o + i * ($t(vt(e.b)) - o))),\n          a: t.a + i * (e.a - t.a)\n        };\n      }(this._rgb, t._rgb, e)), this;\n    }\n    clone() {\n      return new Kt(this.rgb);\n    }\n    alpha(t) {\n      return this._rgb.a = yt(t), this;\n    }\n    clearer(t) {\n      return this._rgb.a *= 1 - t, this;\n    }\n    greyscale() {\n      const t = this._rgb,\n        e = bt(.3 * t.r + .59 * t.g + .11 * t.b);\n      return t.r = t.g = t.b = e, this;\n    }\n    opaquer(t) {\n      return this._rgb.a *= 1 + t, this;\n    }\n    negate() {\n      const t = this._rgb;\n      return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;\n    }\n    lighten(t) {\n      return Yt(this._rgb, 2, t), this;\n    }\n    darken(t) {\n      return Yt(this._rgb, 2, -t), this;\n    }\n    saturate(t) {\n      return Yt(this._rgb, 1, t), this;\n    }\n    desaturate(t) {\n      return Yt(this._rgb, 1, -t), this;\n    }\n    rotate(t) {\n      return function (t, e) {\n        var i = Et(t);\n        i[0] = zt(i[0] + e), i = It(i), t.r = i[0], t.g = i[1], t.b = i[2];\n      }(this._rgb, t), this;\n    }\n  }\n  function Gt(t) {\n    return new Kt(t);\n  }\n  function Zt(t) {\n    if (t && \"object\" == typeof t) {\n      const e = t.toString();\n      return \"[object CanvasPattern]\" === e || \"[object CanvasGradient]\" === e;\n    }\n    return !1;\n  }\n  function Jt(t) {\n    return Zt(t) ? t : Gt(t);\n  }\n  function Qt(t) {\n    return Zt(t) ? t : Gt(t).saturate(.5).darken(.1).hexString();\n  }\n  const te = Object.create(null),\n    ee = Object.create(null);\n  function ie(t, e) {\n    if (!e) return t;\n    const i = e.split(\".\");\n    for (let e = 0, s = i.length; e < s; ++e) {\n      const s = i[e];\n      t = t[s] || (t[s] = Object.create(null));\n    }\n    return t;\n  }\n  function se(t, e, i) {\n    return \"string\" == typeof e ? m(ie(t, e), i) : m(ie(t, \"\"), e);\n  }\n  var ne = new class {\n    constructor(t) {\n      this.animation = void 0, this.backgroundColor = \"rgba(0,0,0,0.1)\", this.borderColor = \"rgba(0,0,0,0.1)\", this.color = \"#666\", this.datasets = {}, this.devicePixelRatio = t => t.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [\"mousemove\", \"mouseout\", \"click\", \"touchstart\", \"touchmove\"], this.font = {\n        family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n        size: 12,\n        style: \"normal\",\n        lineHeight: 1.2,\n        weight: null\n      }, this.hover = {}, this.hoverBackgroundColor = (t, e) => Qt(e.backgroundColor), this.hoverBorderColor = (t, e) => Qt(e.borderColor), this.hoverColor = (t, e) => Qt(e.color), this.indexAxis = \"x\", this.interaction = {\n        mode: \"nearest\",\n        intersect: !0,\n        includeInvisible: !1\n      }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t);\n    }\n    set(t, e) {\n      return se(this, t, e);\n    }\n    get(t) {\n      return ie(this, t);\n    }\n    describe(t, e) {\n      return se(ee, t, e);\n    }\n    override(t, e) {\n      return se(te, t, e);\n    }\n    route(t, e, i, s) {\n      const o = ie(this, t),\n        a = ie(this, i),\n        l = \"_\" + e;\n      Object.defineProperties(o, {\n        [l]: {\n          value: o[e],\n          writable: !0\n        },\n        [e]: {\n          enumerable: !0,\n          get() {\n            const t = this[l],\n              e = a[s];\n            return n(t) ? Object.assign({}, e, t) : r(t, e);\n          },\n          set(t) {\n            this[l] = t;\n          }\n        }\n      });\n    }\n  }({\n    _scriptable: t => !t.startsWith(\"on\"),\n    _indexable: t => \"events\" !== t,\n    hover: {\n      _fallback: \"interaction\"\n    },\n    interaction: {\n      _scriptable: !1,\n      _indexable: !1\n    }\n  });\n  function oe() {\n    return \"undefined\" != typeof window && \"undefined\" != typeof document;\n  }\n  function ae(t) {\n    let e = t.parentNode;\n    return e && \"[object ShadowRoot]\" === e.toString() && (e = e.host), e;\n  }\n  function re(t, e, i) {\n    let s;\n    return \"string\" == typeof t ? (s = parseInt(t, 10), -1 !== t.indexOf(\"%\") && (s = s / 100 * e.parentNode[i])) : s = t, s;\n  }\n  const le = t => window.getComputedStyle(t, null);\n  function he(t, e) {\n    return le(t).getPropertyValue(e);\n  }\n  const ce = [\"top\", \"right\", \"bottom\", \"left\"];\n  function de(t, e, i) {\n    const s = {};\n    i = i ? \"-\" + i : \"\";\n    for (let n = 0; n < 4; n++) {\n      const o = ce[n];\n      s[o] = parseFloat(t[e + \"-\" + o + i]) || 0;\n    }\n    return s.width = s.left + s.right, s.height = s.top + s.bottom, s;\n  }\n  function ue(t, e) {\n    if (\"native\" in t) return t;\n    const {\n        canvas: i,\n        currentDevicePixelRatio: s\n      } = e,\n      n = le(i),\n      o = \"border-box\" === n.boxSizing,\n      a = de(n, \"padding\"),\n      r = de(n, \"border\", \"width\"),\n      {\n        x: l,\n        y: h,\n        box: c\n      } = function (t, e) {\n        const i = t.touches,\n          s = i && i.length ? i[0] : t,\n          {\n            offsetX: n,\n            offsetY: o\n          } = s;\n        let a,\n          r,\n          l = !1;\n        if (((t, e, i) => (t > 0 || e > 0) && (!i || !i.shadowRoot))(n, o, t.target)) a = n, r = o;else {\n          const t = e.getBoundingClientRect();\n          a = s.clientX - t.left, r = s.clientY - t.top, l = !0;\n        }\n        return {\n          x: a,\n          y: r,\n          box: l\n        };\n      }(t, i),\n      d = a.left + (c && r.left),\n      u = a.top + (c && r.top);\n    let {\n      width: f,\n      height: g\n    } = e;\n    return o && (f -= a.width + r.width, g -= a.height + r.height), {\n      x: Math.round((l - d) / f * i.width / s),\n      y: Math.round((h - u) / g * i.height / s)\n    };\n  }\n  const fe = t => Math.round(10 * t) / 10;\n  function ge(t, e, i, s) {\n    const n = le(t),\n      o = de(n, \"margin\"),\n      a = re(n.maxWidth, t, \"clientWidth\") || A,\n      r = re(n.maxHeight, t, \"clientHeight\") || A,\n      l = function (t, e, i) {\n        let s, n;\n        if (void 0 === e || void 0 === i) {\n          const o = ae(t);\n          if (o) {\n            const t = o.getBoundingClientRect(),\n              a = le(o),\n              r = de(a, \"border\", \"width\"),\n              l = de(a, \"padding\");\n            e = t.width - l.width - r.width, i = t.height - l.height - r.height, s = re(a.maxWidth, o, \"clientWidth\"), n = re(a.maxHeight, o, \"clientHeight\");\n          } else e = t.clientWidth, i = t.clientHeight;\n        }\n        return {\n          width: e,\n          height: i,\n          maxWidth: s || A,\n          maxHeight: n || A\n        };\n      }(t, e, i);\n    let {\n      width: h,\n      height: c\n    } = l;\n    if (\"content-box\" === n.boxSizing) {\n      const t = de(n, \"border\", \"width\"),\n        e = de(n, \"padding\");\n      h -= e.width + t.width, c -= e.height + t.height;\n    }\n    return h = Math.max(0, h - o.width), c = Math.max(0, s ? Math.floor(h / s) : c - o.height), h = fe(Math.min(h, a, l.maxWidth)), c = fe(Math.min(c, r, l.maxHeight)), h && !c && (c = fe(h / 2)), {\n      width: h,\n      height: c\n    };\n  }\n  function pe(t, e, i) {\n    const s = e || 1,\n      n = Math.floor(t.height * s),\n      o = Math.floor(t.width * s);\n    t.height = n / s, t.width = o / s;\n    const a = t.canvas;\n    return a.style && (i || !a.style.height && !a.style.width) && (a.style.height = \"\".concat(t.height, \"px\"), a.style.width = \"\".concat(t.width, \"px\")), (t.currentDevicePixelRatio !== s || a.height !== n || a.width !== o) && (t.currentDevicePixelRatio = s, a.height = n, a.width = o, t.ctx.setTransform(s, 0, 0, s, 0, 0), !0);\n  }\n  const me = function () {\n    let t = !1;\n    try {\n      const e = {\n        get passive() {\n          return t = !0, !1;\n        }\n      };\n      window.addEventListener(\"test\", null, e), window.removeEventListener(\"test\", null, e);\n    } catch (t) {}\n    return t;\n  }();\n  function be(t, e) {\n    const i = he(t, e),\n      s = i && i.match(/^(\\d+)(\\.\\d+)?px$/);\n    return s ? +s[1] : void 0;\n  }\n  function xe(t) {\n    return !t || i(t.size) || i(t.family) ? null : (t.style ? t.style + \" \" : \"\") + (t.weight ? t.weight + \" \" : \"\") + t.size + \"px \" + t.family;\n  }\n  function _e(t, e, i, s, n) {\n    let o = e[n];\n    return o || (o = e[n] = t.measureText(n).width, i.push(n)), o > s && (s = o), s;\n  }\n  function ye(t, e, i, n) {\n    let o = (n = n || {}).data = n.data || {},\n      a = n.garbageCollect = n.garbageCollect || [];\n    n.font !== e && (o = n.data = {}, a = n.garbageCollect = [], n.font = e), t.save(), t.font = e;\n    let r = 0;\n    const l = i.length;\n    let h, c, d, u, f;\n    for (h = 0; h < l; h++) if (u = i[h], null != u && !0 !== s(u)) r = _e(t, o, a, r, u);else if (s(u)) for (c = 0, d = u.length; c < d; c++) f = u[c], null == f || s(f) || (r = _e(t, o, a, r, f));\n    t.restore();\n    const g = a.length / 2;\n    if (g > i.length) {\n      for (h = 0; h < g; h++) delete o[a[h]];\n      a.splice(0, g);\n    }\n    return r;\n  }\n  function ve(t, e, i) {\n    const s = t.currentDevicePixelRatio,\n      n = 0 !== i ? Math.max(i / 2, .5) : 0;\n    return Math.round((e - n) * s) / s + n;\n  }\n  function we(t, e) {\n    (e = e || t.getContext(\"2d\")).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore();\n  }\n  function Me(t, e, i, s) {\n    ke(t, e, i, s, null);\n  }\n  function ke(t, e, i, s, n) {\n    let o, a, r, l, h, c;\n    const d = e.pointStyle,\n      u = e.rotation,\n      f = e.radius;\n    let g = (u || 0) * T;\n    if (d && \"object\" == typeof d && (o = d.toString(), \"[object HTMLImageElement]\" === o || \"[object HTMLCanvasElement]\" === o)) return t.save(), t.translate(i, s), t.rotate(g), t.drawImage(d, -d.width / 2, -d.height / 2, d.width, d.height), void t.restore();\n    if (!(isNaN(f) || f <= 0)) {\n      switch (t.beginPath(), d) {\n        default:\n          n ? t.ellipse(i, s, n / 2, f, 0, 0, O) : t.arc(i, s, f, 0, O), t.closePath();\n          break;\n        case \"triangle\":\n          t.moveTo(i + Math.sin(g) * f, s - Math.cos(g) * f), g += R, t.lineTo(i + Math.sin(g) * f, s - Math.cos(g) * f), g += R, t.lineTo(i + Math.sin(g) * f, s - Math.cos(g) * f), t.closePath();\n          break;\n        case \"rectRounded\":\n          h = .516 * f, l = f - h, a = Math.cos(g + E) * l, r = Math.sin(g + E) * l, t.arc(i - a, s - r, h, g - D, g - L), t.arc(i + r, s - a, h, g - L, g), t.arc(i + a, s + r, h, g, g + L), t.arc(i - r, s + a, h, g + L, g + D), t.closePath();\n          break;\n        case \"rect\":\n          if (!u) {\n            l = Math.SQRT1_2 * f, c = n ? n / 2 : l, t.rect(i - c, s - l, 2 * c, 2 * l);\n            break;\n          }\n          g += E;\n        case \"rectRot\":\n          a = Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + r, s - a), t.lineTo(i + a, s + r), t.lineTo(i - r, s + a), t.closePath();\n          break;\n        case \"crossRot\":\n          g += E;\n        case \"cross\":\n          a = Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r), t.moveTo(i + r, s - a), t.lineTo(i - r, s + a);\n          break;\n        case \"star\":\n          a = Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r), t.moveTo(i + r, s - a), t.lineTo(i - r, s + a), g += E, a = Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r), t.moveTo(i + r, s - a), t.lineTo(i - r, s + a);\n          break;\n        case \"line\":\n          a = n ? n / 2 : Math.cos(g) * f, r = Math.sin(g) * f, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r);\n          break;\n        case \"dash\":\n          t.moveTo(i, s), t.lineTo(i + Math.cos(g) * f, s + Math.sin(g) * f);\n      }\n      t.fill(), e.borderWidth > 0 && t.stroke();\n    }\n  }\n  function Se(t, e, i) {\n    return i = i || .5, !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i;\n  }\n  function Pe(t, e) {\n    t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip();\n  }\n  function De(t) {\n    t.restore();\n  }\n  function Oe(t, e, i, s, n) {\n    if (!e) return t.lineTo(i.x, i.y);\n    if (\"middle\" === n) {\n      const s = (e.x + i.x) / 2;\n      t.lineTo(s, e.y), t.lineTo(s, i.y);\n    } else \"after\" === n != !!s ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);\n    t.lineTo(i.x, i.y);\n  }\n  function Ce(t, e, i, s) {\n    if (!e) return t.lineTo(i.x, i.y);\n    t.bezierCurveTo(s ? e.cp1x : e.cp2x, s ? e.cp1y : e.cp2y, s ? i.cp2x : i.cp1x, s ? i.cp2y : i.cp1y, i.x, i.y);\n  }\n  function Ae(t, e, n, o, a) {\n    let r = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    const l = s(e) ? e : [e],\n      h = r.strokeWidth > 0 && \"\" !== r.strokeColor;\n    let c, d;\n    for (t.save(), t.font = a.string, function (t, e) {\n      e.translation && t.translate(e.translation[0], e.translation[1]);\n      i(e.rotation) || t.rotate(e.rotation);\n      e.color && (t.fillStyle = e.color);\n      e.textAlign && (t.textAlign = e.textAlign);\n      e.textBaseline && (t.textBaseline = e.textBaseline);\n    }(t, r), c = 0; c < l.length; ++c) d = l[c], h && (r.strokeColor && (t.strokeStyle = r.strokeColor), i(r.strokeWidth) || (t.lineWidth = r.strokeWidth), t.strokeText(d, n, o, r.maxWidth)), t.fillText(d, n, o, r.maxWidth), Te(t, n, o, d, r), o += a.lineHeight;\n    t.restore();\n  }\n  function Te(t, e, i, s, n) {\n    if (n.strikethrough || n.underline) {\n      const o = t.measureText(s),\n        a = e - o.actualBoundingBoxLeft,\n        r = e + o.actualBoundingBoxRight,\n        l = i - o.actualBoundingBoxAscent,\n        h = i + o.actualBoundingBoxDescent,\n        c = n.strikethrough ? (l + h) / 2 : h;\n      t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = n.decorationWidth || 2, t.moveTo(a, c), t.lineTo(r, c), t.stroke();\n    }\n  }\n  function Le(t, e) {\n    const {\n      x: i,\n      y: s,\n      w: n,\n      h: o,\n      radius: a\n    } = e;\n    t.arc(i + a.topLeft, s + a.topLeft, a.topLeft, -L, D, !0), t.lineTo(i, s + o - a.bottomLeft), t.arc(i + a.bottomLeft, s + o - a.bottomLeft, a.bottomLeft, D, L, !0), t.lineTo(i + n - a.bottomRight, s + o), t.arc(i + n - a.bottomRight, s + o - a.bottomRight, a.bottomRight, L, 0, !0), t.lineTo(i + n, s + a.topRight), t.arc(i + n - a.topRight, s + a.topRight, a.topRight, 0, -L, !0), t.lineTo(i + a.topLeft, s);\n  }\n  function Ee(t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [\"\"];\n    let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : t;\n    let s = arguments.length > 3 ? arguments[3] : undefined;\n    let n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : () => t[0];\n    M(s) || (s = $e(\"_fallback\", t));\n    const o = {\n      [Symbol.toStringTag]: \"Object\",\n      _cacheable: !0,\n      _scopes: t,\n      _rootScopes: i,\n      _fallback: s,\n      _getTarget: n,\n      override: n => Ee([n, ...t], e, i, s)\n    };\n    return new Proxy(o, {\n      deleteProperty: (e, i) => (delete e[i], delete e._keys, delete t[0][i], !0),\n      get: (i, s) => Ve(i, s, () => function (t, e, i, s) {\n        let n;\n        for (const o of e) if (n = $e(ze(o, t), i), M(n)) return Fe(t, n) ? je(i, s, t, n) : n;\n      }(s, e, t, i)),\n      getOwnPropertyDescriptor: (t, e) => Reflect.getOwnPropertyDescriptor(t._scopes[0], e),\n      getPrototypeOf: () => Reflect.getPrototypeOf(t[0]),\n      has: (t, e) => Ye(t).includes(e),\n      ownKeys: t => Ye(t),\n      set(t, e, i) {\n        const s = t._storage || (t._storage = n());\n        return t[e] = s[e] = i, delete t._keys, !0;\n      }\n    });\n  }\n  function Re(t, e, i, o) {\n    const a = {\n      _cacheable: !1,\n      _proxy: t,\n      _context: e,\n      _subProxy: i,\n      _stack: new Set(),\n      _descriptors: Ie(t, o),\n      setContext: e => Re(t, e, i, o),\n      override: s => Re(t.override(s), e, i, o)\n    };\n    return new Proxy(a, {\n      deleteProperty: (e, i) => (delete e[i], delete t[i], !0),\n      get: (t, e, i) => Ve(t, e, () => function (t, e, i) {\n        const {\n          _proxy: o,\n          _context: a,\n          _subProxy: r,\n          _descriptors: l\n        } = t;\n        let h = o[e];\n        k(h) && l.isScriptable(e) && (h = function (t, e, i, s) {\n          const {\n            _proxy: n,\n            _context: o,\n            _subProxy: a,\n            _stack: r\n          } = i;\n          if (r.has(t)) throw new Error(\"Recursion detected: \" + Array.from(r).join(\"->\") + \"->\" + t);\n          r.add(t), e = e(o, a || s), r.delete(t), Fe(t, e) && (e = je(n._scopes, n, t, e));\n          return e;\n        }(e, h, t, i));\n        s(h) && h.length && (h = function (t, e, i, s) {\n          const {\n            _proxy: o,\n            _context: a,\n            _subProxy: r,\n            _descriptors: l\n          } = i;\n          if (M(a.index) && s(t)) e = e[a.index % e.length];else if (n(e[0])) {\n            const i = e,\n              s = o._scopes.filter(t => t !== i);\n            e = [];\n            for (const n of i) {\n              const i = je(s, o, t, n);\n              e.push(Re(i, a, r && r[t], l));\n            }\n          }\n          return e;\n        }(e, h, t, l.isIndexable));\n        Fe(e, h) && (h = Re(h, a, r && r[e], l));\n        return h;\n      }(t, e, i)),\n      getOwnPropertyDescriptor: (e, i) => e._descriptors.allKeys ? Reflect.has(t, i) ? {\n        enumerable: !0,\n        configurable: !0\n      } : void 0 : Reflect.getOwnPropertyDescriptor(t, i),\n      getPrototypeOf: () => Reflect.getPrototypeOf(t),\n      has: (e, i) => Reflect.has(t, i),\n      ownKeys: () => Reflect.ownKeys(t),\n      set: (e, i, s) => (t[i] = s, delete e[i], !0)\n    });\n  }\n  function Ie(t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      scriptable: !0,\n      indexable: !0\n    };\n    const {\n      _scriptable: i = e.scriptable,\n      _indexable: s = e.indexable,\n      _allKeys: n = e.allKeys\n    } = t;\n    return {\n      allKeys: n,\n      scriptable: i,\n      indexable: s,\n      isScriptable: k(i) ? i : () => i,\n      isIndexable: k(s) ? s : () => s\n    };\n  }\n  const ze = (t, e) => t ? t + w(e) : e,\n    Fe = (t, e) => n(e) && \"adapters\" !== t && (null === Object.getPrototypeOf(e) || e.constructor === Object);\n  function Ve(t, e, i) {\n    if (Object.prototype.hasOwnProperty.call(t, e)) return t[e];\n    const s = i();\n    return t[e] = s, s;\n  }\n  function Be(t, e, i) {\n    return k(t) ? t(e, i) : t;\n  }\n  const Ne = (t, e) => !0 === t ? e : \"string\" == typeof t ? y(e, t) : void 0;\n  function We(t, e, i, s, n) {\n    for (const o of e) {\n      const e = Ne(i, o);\n      if (e) {\n        t.add(e);\n        const o = Be(e._fallback, i, n);\n        if (M(o) && o !== i && o !== s) return o;\n      } else if (!1 === e && M(s) && i !== s) return null;\n    }\n    return !1;\n  }\n  function je(t, e, i, o) {\n    const a = e._rootScopes,\n      r = Be(e._fallback, i, o),\n      l = [...t, ...a],\n      h = new Set();\n    h.add(o);\n    let c = He(h, l, i, r || i, o);\n    return null !== c && (!M(r) || r === i || (c = He(h, l, r, c, o), null !== c)) && Ee(Array.from(h), [\"\"], a, r, () => function (t, e, i) {\n      const o = t._getTarget();\n      e in o || (o[e] = {});\n      const a = o[e];\n      if (s(a) && n(i)) return i;\n      return a;\n    }(e, i, o));\n  }\n  function He(t, e, i, s, n) {\n    for (; i;) i = We(t, e, i, s, n);\n    return i;\n  }\n  function $e(t, e) {\n    for (const i of e) {\n      if (!i) continue;\n      const e = i[t];\n      if (M(e)) return e;\n    }\n  }\n  function Ye(t) {\n    let e = t._keys;\n    return e || (e = t._keys = function (t) {\n      const e = new Set();\n      for (const i of t) for (const t of Object.keys(i).filter(t => !t.startsWith(\"_\"))) e.add(t);\n      return Array.from(e);\n    }(t._scopes)), e;\n  }\n  function Ue(t, e, i, s) {\n    const {\n        iScale: n\n      } = t,\n      {\n        key: o = \"r\"\n      } = this._parsing,\n      a = new Array(s);\n    let r, l, h, c;\n    for (r = 0, l = s; r < l; ++r) h = r + i, c = e[h], a[r] = {\n      r: n.parse(y(c, o), h)\n    };\n    return a;\n  }\n  const Xe = Number.EPSILON || 1e-14,\n    qe = (t, e) => e < t.length && !t[e].skip && t[e],\n    Ke = t => \"x\" === t ? \"y\" : \"x\";\n  function Ge(t, e, i, s) {\n    const n = t.skip ? e : t,\n      o = e,\n      a = i.skip ? e : i,\n      r = X(o, n),\n      l = X(a, o);\n    let h = r / (r + l),\n      c = l / (r + l);\n    h = isNaN(h) ? 0 : h, c = isNaN(c) ? 0 : c;\n    const d = s * h,\n      u = s * c;\n    return {\n      previous: {\n        x: o.x - d * (a.x - n.x),\n        y: o.y - d * (a.y - n.y)\n      },\n      next: {\n        x: o.x + u * (a.x - n.x),\n        y: o.y + u * (a.y - n.y)\n      }\n    };\n  }\n  function Ze(t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"x\";\n    const i = Ke(e),\n      s = t.length,\n      n = Array(s).fill(0),\n      o = Array(s);\n    let a,\n      r,\n      l,\n      h = qe(t, 0);\n    for (a = 0; a < s; ++a) if (r = l, l = h, h = qe(t, a + 1), l) {\n      if (h) {\n        const t = h[e] - l[e];\n        n[a] = 0 !== t ? (h[i] - l[i]) / t : 0;\n      }\n      o[a] = r ? h ? z(n[a - 1]) !== z(n[a]) ? 0 : (n[a - 1] + n[a]) / 2 : n[a - 1] : n[a];\n    }\n    !function (t, e, i) {\n      const s = t.length;\n      let n,\n        o,\n        a,\n        r,\n        l,\n        h = qe(t, 0);\n      for (let c = 0; c < s - 1; ++c) l = h, h = qe(t, c + 1), l && h && (N(e[c], 0, Xe) ? i[c] = i[c + 1] = 0 : (n = i[c] / e[c], o = i[c + 1] / e[c], r = Math.pow(n, 2) + Math.pow(o, 2), r <= 9 || (a = 3 / Math.sqrt(r), i[c] = n * a * e[c], i[c + 1] = o * a * e[c])));\n    }(t, n, o), function (t, e) {\n      let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"x\";\n      const s = Ke(i),\n        n = t.length;\n      let o,\n        a,\n        r,\n        l = qe(t, 0);\n      for (let h = 0; h < n; ++h) {\n        if (a = r, r = l, l = qe(t, h + 1), !r) continue;\n        const n = r[i],\n          c = r[s];\n        a && (o = (n - a[i]) / 3, r[\"cp1\".concat(i)] = n - o, r[\"cp1\".concat(s)] = c - o * e[h]), l && (o = (l[i] - n) / 3, r[\"cp2\".concat(i)] = n + o, r[\"cp2\".concat(s)] = c + o * e[h]);\n      }\n    }(t, o, e);\n  }\n  function Je(t, e, i) {\n    return Math.max(Math.min(t, i), e);\n  }\n  function Qe(t, e, i, s, n) {\n    let o, a, r, l;\n    if (e.spanGaps && (t = t.filter(t => !t.skip)), \"monotone\" === e.cubicInterpolationMode) Ze(t, n);else {\n      let i = s ? t[t.length - 1] : t[0];\n      for (o = 0, a = t.length; o < a; ++o) r = t[o], l = Ge(i, r, t[Math.min(o + 1, a - (s ? 0 : 1)) % a], e.tension), r.cp1x = l.previous.x, r.cp1y = l.previous.y, r.cp2x = l.next.x, r.cp2y = l.next.y, i = r;\n    }\n    e.capBezierPoints && function (t, e) {\n      let i,\n        s,\n        n,\n        o,\n        a,\n        r = Se(t[0], e);\n      for (i = 0, s = t.length; i < s; ++i) a = o, o = r, r = i < s - 1 && Se(t[i + 1], e), o && (n = t[i], a && (n.cp1x = Je(n.cp1x, e.left, e.right), n.cp1y = Je(n.cp1y, e.top, e.bottom)), r && (n.cp2x = Je(n.cp2x, e.left, e.right), n.cp2y = Je(n.cp2y, e.top, e.bottom)));\n    }(t, i);\n  }\n  const ti = t => 0 === t || 1 === t,\n    ei = (t, e, i) => -Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * O / i),\n    ii = (t, e, i) => Math.pow(2, -10 * t) * Math.sin((t - e) * O / i) + 1,\n    si = {\n      linear: t => t,\n      easeInQuad: t => t * t,\n      easeOutQuad: t => -t * (t - 2),\n      easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1),\n      easeInCubic: t => t * t * t,\n      easeOutCubic: t => (t -= 1) * t * t + 1,\n      easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),\n      easeInQuart: t => t * t * t * t,\n      easeOutQuart: t => -((t -= 1) * t * t * t - 1),\n      easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2),\n      easeInQuint: t => t * t * t * t * t,\n      easeOutQuint: t => (t -= 1) * t * t * t * t + 1,\n      easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),\n      easeInSine: t => 1 - Math.cos(t * L),\n      easeOutSine: t => Math.sin(t * L),\n      easeInOutSine: t => -.5 * (Math.cos(D * t) - 1),\n      easeInExpo: t => 0 === t ? 0 : Math.pow(2, 10 * (t - 1)),\n      easeOutExpo: t => 1 === t ? 1 : 1 - Math.pow(2, -10 * t),\n      easeInOutExpo: t => ti(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),\n      easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n      easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),\n      easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n      easeInElastic: t => ti(t) ? t : ei(t, .075, .3),\n      easeOutElastic: t => ti(t) ? t : ii(t, .075, .3),\n      easeInOutElastic(t) {\n        const e = .1125;\n        return ti(t) ? t : t < .5 ? .5 * ei(2 * t, e, .45) : .5 + .5 * ii(2 * t - 1, e, .45);\n      },\n      easeInBack(t) {\n        const e = 1.70158;\n        return t * t * ((e + 1) * t - e);\n      },\n      easeOutBack(t) {\n        const e = 1.70158;\n        return (t -= 1) * t * ((e + 1) * t + e) + 1;\n      },\n      easeInOutBack(t) {\n        let e = 1.70158;\n        return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2);\n      },\n      easeInBounce: t => 1 - si.easeOutBounce(1 - t),\n      easeOutBounce(t) {\n        const e = 7.5625,\n          i = 2.75;\n        return t < 1 / i ? e * t * t : t < 2 / i ? e * (t -= 1.5 / i) * t + .75 : t < 2.5 / i ? e * (t -= 2.25 / i) * t + .9375 : e * (t -= 2.625 / i) * t + .984375;\n      },\n      easeInOutBounce: t => t < .5 ? .5 * si.easeInBounce(2 * t) : .5 * si.easeOutBounce(2 * t - 1) + .5\n    };\n  function ni(t, e, i, s) {\n    return {\n      x: t.x + i * (e.x - t.x),\n      y: t.y + i * (e.y - t.y)\n    };\n  }\n  function oi(t, e, i, s) {\n    return {\n      x: t.x + i * (e.x - t.x),\n      y: \"middle\" === s ? i < .5 ? t.y : e.y : \"after\" === s ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y\n    };\n  }\n  function ai(t, e, i, s) {\n    const n = {\n        x: t.cp2x,\n        y: t.cp2y\n      },\n      o = {\n        x: e.cp1x,\n        y: e.cp1y\n      },\n      a = ni(t, n, i),\n      r = ni(n, o, i),\n      l = ni(o, e, i),\n      h = ni(a, r, i),\n      c = ni(r, l, i);\n    return ni(h, c, i);\n  }\n  const ri = new Map();\n  function li(t, e, i) {\n    return function (t, e) {\n      e = e || {};\n      const i = t + JSON.stringify(e);\n      let s = ri.get(i);\n      return s || (s = new Intl.NumberFormat(t, e), ri.set(i, s)), s;\n    }(e, i).format(t);\n  }\n  const hi = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/),\n    ci = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\n  function di(t, e) {\n    const i = (\"\" + t).match(hi);\n    if (!i || \"normal\" === i[1]) return 1.2 * e;\n    switch (t = +i[2], i[3]) {\n      case \"px\":\n        return t;\n      case \"%\":\n        t /= 100;\n    }\n    return e * t;\n  }\n  function ui(t, e) {\n    const i = {},\n      s = n(e),\n      o = s ? Object.keys(e) : e,\n      a = n(t) ? s ? i => r(t[i], t[e[i]]) : e => t[e] : () => t;\n    for (const t of o) i[t] = +a(t) || 0;\n    return i;\n  }\n  function fi(t) {\n    return ui(t, {\n      top: \"y\",\n      right: \"x\",\n      bottom: \"y\",\n      left: \"x\"\n    });\n  }\n  function gi(t) {\n    return ui(t, [\"topLeft\", \"topRight\", \"bottomLeft\", \"bottomRight\"]);\n  }\n  function pi(t) {\n    const e = fi(t);\n    return e.width = e.left + e.right, e.height = e.top + e.bottom, e;\n  }\n  function mi(t, e) {\n    t = t || {}, e = e || ne.font;\n    let i = r(t.size, e.size);\n    \"string\" == typeof i && (i = parseInt(i, 10));\n    let s = r(t.style, e.style);\n    s && !(\"\" + s).match(ci) && (console.warn('Invalid font style specified: \"' + s + '\"'), s = \"\");\n    const n = {\n      family: r(t.family, e.family),\n      lineHeight: di(r(t.lineHeight, e.lineHeight), i),\n      size: i,\n      style: s,\n      weight: r(t.weight, e.weight),\n      string: \"\"\n    };\n    return n.string = xe(n), n;\n  }\n  function bi(t, e, i, n) {\n    let o,\n      a,\n      r,\n      l = !0;\n    for (o = 0, a = t.length; o < a; ++o) if (r = t[o], void 0 !== r && (void 0 !== e && \"function\" == typeof r && (r = r(e), l = !1), void 0 !== i && s(r) && (r = r[i % r.length], l = !1), void 0 !== r)) return n && !l && (n.cacheable = !1), r;\n  }\n  function xi(t, e, i) {\n    const {\n        min: s,\n        max: n\n      } = t,\n      o = h(e, (n - s) / 2),\n      a = (t, e) => i && 0 === t ? 0 : t + e;\n    return {\n      min: a(s, -Math.abs(o)),\n      max: a(n, o)\n    };\n  }\n  function _i(t, e) {\n    return Object.assign(Object.create(t), e);\n  }\n  function yi(t, e, i) {\n    return t ? function (t, e) {\n      return {\n        x: i => t + t + e - i,\n        setWidth(t) {\n          e = t;\n        },\n        textAlign: t => \"center\" === t ? t : \"right\" === t ? \"left\" : \"right\",\n        xPlus: (t, e) => t - e,\n        leftForLtr: (t, e) => t - e\n      };\n    }(e, i) : {\n      x: t => t,\n      setWidth(t) {},\n      textAlign: t => t,\n      xPlus: (t, e) => t + e,\n      leftForLtr: (t, e) => t\n    };\n  }\n  function vi(t, e) {\n    let i, s;\n    \"ltr\" !== e && \"rtl\" !== e || (i = t.canvas.style, s = [i.getPropertyValue(\"direction\"), i.getPropertyPriority(\"direction\")], i.setProperty(\"direction\", e, \"important\"), t.prevTextDirection = s);\n  }\n  function wi(t, e) {\n    void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty(\"direction\", e[0], e[1]));\n  }\n  function Mi(t) {\n    return \"angle\" === t ? {\n      between: G,\n      compare: q,\n      normalize: K\n    } : {\n      between: Q,\n      compare: (t, e) => t - e,\n      normalize: t => t\n    };\n  }\n  function ki(_ref) {\n    let {\n      start: t,\n      end: e,\n      count: i,\n      loop: s,\n      style: n\n    } = _ref;\n    return {\n      start: t % i,\n      end: e % i,\n      loop: s && (e - t + 1) % i == 0,\n      style: n\n    };\n  }\n  function Si(t, e, i) {\n    if (!i) return [t];\n    const {\n        property: s,\n        start: n,\n        end: o\n      } = i,\n      a = e.length,\n      {\n        compare: r,\n        between: l,\n        normalize: h\n      } = Mi(s),\n      {\n        start: c,\n        end: d,\n        loop: u,\n        style: f\n      } = function (t, e, i) {\n        const {\n            property: s,\n            start: n,\n            end: o\n          } = i,\n          {\n            between: a,\n            normalize: r\n          } = Mi(s),\n          l = e.length;\n        let h,\n          c,\n          {\n            start: d,\n            end: u,\n            loop: f\n          } = t;\n        if (f) {\n          for (d += l, u += l, h = 0, c = l; h < c && a(r(e[d % l][s]), n, o); ++h) d--, u--;\n          d %= l, u %= l;\n        }\n        return u < d && (u += l), {\n          start: d,\n          end: u,\n          loop: f,\n          style: t.style\n        };\n      }(t, e, i),\n      g = [];\n    let p,\n      m,\n      b,\n      x = !1,\n      _ = null;\n    const y = () => x || l(n, b, p) && 0 !== r(n, b),\n      v = () => !x || 0 === r(o, p) || l(o, b, p);\n    for (let t = c, i = c; t <= d; ++t) m = e[t % a], m.skip || (p = h(m[s]), p !== b && (x = l(p, n, o), null === _ && y() && (_ = 0 === r(p, n) ? t : i), null !== _ && v() && (g.push(ki({\n      start: _,\n      end: t,\n      loop: u,\n      count: a,\n      style: f\n    })), _ = null), i = t, b = p));\n    return null !== _ && g.push(ki({\n      start: _,\n      end: d,\n      loop: u,\n      count: a,\n      style: f\n    })), g;\n  }\n  function Pi(t, e) {\n    const i = [],\n      s = t.segments;\n    for (let n = 0; n < s.length; n++) {\n      const o = Si(s[n], t.points, e);\n      o.length && i.push(...o);\n    }\n    return i;\n  }\n  function Di(t, e) {\n    const i = t.points,\n      s = t.options.spanGaps,\n      n = i.length;\n    if (!n) return [];\n    const o = !!t._loop,\n      {\n        start: a,\n        end: r\n      } = function (t, e, i, s) {\n        let n = 0,\n          o = e - 1;\n        if (i && !s) for (; n < e && !t[n].skip;) n++;\n        for (; n < e && t[n].skip;) n++;\n        for (n %= e, i && (o += n); o > n && t[o % e].skip;) o--;\n        return o %= e, {\n          start: n,\n          end: o\n        };\n      }(i, n, o, s);\n    if (!0 === s) return Oi(t, [{\n      start: a,\n      end: r,\n      loop: o\n    }], i, e);\n    return Oi(t, function (t, e, i, s) {\n      const n = t.length,\n        o = [];\n      let a,\n        r = e,\n        l = t[e];\n      for (a = e + 1; a <= i; ++a) {\n        const i = t[a % n];\n        i.skip || i.stop ? l.skip || (s = !1, o.push({\n          start: e % n,\n          end: (a - 1) % n,\n          loop: s\n        }), e = r = i.stop ? a : null) : (r = a, l.skip && (e = a)), l = i;\n      }\n      return null !== r && o.push({\n        start: e % n,\n        end: r % n,\n        loop: s\n      }), o;\n    }(i, a, r < a ? r + n : r, !!t._fullLoop && 0 === a && r === n - 1), i, e);\n  }\n  function Oi(t, e, i, s) {\n    return s && s.setContext && i ? function (t, e, i, s) {\n      const n = t._chart.getContext(),\n        o = Ci(t.options),\n        {\n          _datasetIndex: a,\n          options: {\n            spanGaps: r\n          }\n        } = t,\n        l = i.length,\n        h = [];\n      let c = o,\n        d = e[0].start,\n        u = d;\n      function f(t, e, s, n) {\n        const o = r ? -1 : 1;\n        if (t !== e) {\n          for (t += l; i[t % l].skip;) t -= o;\n          for (; i[e % l].skip;) e += o;\n          t % l != e % l && (h.push({\n            start: t % l,\n            end: e % l,\n            loop: s,\n            style: n\n          }), c = n, d = e % l);\n        }\n      }\n      for (const t of e) {\n        d = r ? d : t.start;\n        let e,\n          o = i[d % l];\n        for (u = d + 1; u <= t.end; u++) {\n          const r = i[u % l];\n          e = Ci(s.setContext(_i(n, {\n            type: \"segment\",\n            p0: o,\n            p1: r,\n            p0DataIndex: (u - 1) % l,\n            p1DataIndex: u % l,\n            datasetIndex: a\n          }))), Ai(e, c) && f(d, u - 1, t.loop, c), o = r, c = e;\n        }\n        d < u - 1 && f(d, u - 1, t.loop, c);\n      }\n      return h;\n    }(t, e, i, s) : e;\n  }\n  function Ci(t) {\n    return {\n      backgroundColor: t.backgroundColor,\n      borderCapStyle: t.borderCapStyle,\n      borderDash: t.borderDash,\n      borderDashOffset: t.borderDashOffset,\n      borderJoinStyle: t.borderJoinStyle,\n      borderWidth: t.borderWidth,\n      borderColor: t.borderColor\n    };\n  }\n  function Ai(t, e) {\n    return e && JSON.stringify(t) !== JSON.stringify(e);\n  }\n  var Ti = Object.freeze({\n    __proto__: null,\n    easingEffects: si,\n    isPatternOrGradient: Zt,\n    color: Jt,\n    getHoverColor: Qt,\n    noop: t,\n    uid: e,\n    isNullOrUndef: i,\n    isArray: s,\n    isObject: n,\n    isFinite: o,\n    finiteOrDefault: a,\n    valueOrDefault: r,\n    toPercentage: l,\n    toDimension: h,\n    callback: c,\n    each: d,\n    _elementsEqual: u,\n    clone: f,\n    _merger: p,\n    merge: m,\n    mergeIf: b,\n    _mergerIf: x,\n    _deprecated: function _deprecated(t, e, i, s) {\n      void 0 !== e && console.warn(t + ': \"' + i + '\" is deprecated. Please use \"' + s + '\" instead');\n    },\n    resolveObjectKey: y,\n    _splitKey: v,\n    _capitalize: w,\n    defined: M,\n    isFunction: k,\n    setsEqual: S,\n    _isClickEvent: P,\n    toFontString: xe,\n    _measureText: _e,\n    _longestText: ye,\n    _alignPixel: ve,\n    clearCanvas: we,\n    drawPoint: Me,\n    drawPointLegend: ke,\n    _isPointInArea: Se,\n    clipArea: Pe,\n    unclipArea: De,\n    _steppedLineTo: Oe,\n    _bezierCurveTo: Ce,\n    renderText: Ae,\n    addRoundedRectPath: Le,\n    _lookup: tt,\n    _lookupByKey: et,\n    _rlookupByKey: it,\n    _filterBetween: st,\n    listenArrayEvents: ot,\n    unlistenArrayEvents: at,\n    _arrayUnique: rt,\n    _createResolver: Ee,\n    _attachContext: Re,\n    _descriptors: Ie,\n    _parseObjectDataRadialScale: Ue,\n    splineCurve: Ge,\n    splineCurveMonotone: Ze,\n    _updateBezierControlPoints: Qe,\n    _isDomSupported: oe,\n    _getParentNode: ae,\n    getStyle: he,\n    getRelativePosition: ue,\n    getMaximumSize: ge,\n    retinaScale: pe,\n    supportsEventListenerOptions: me,\n    readUsedSize: be,\n    fontString: function fontString(t, e, i) {\n      return e + \" \" + t + \"px \" + i;\n    },\n    requestAnimFrame: lt,\n    throttled: ht,\n    debounce: ct,\n    _toLeftRightCenter: dt,\n    _alignStartEnd: ut,\n    _textX: ft,\n    _getStartAndCountOfVisiblePoints: gt,\n    _scaleRangesChanged: pt,\n    _pointInLine: ni,\n    _steppedInterpolation: oi,\n    _bezierInterpolation: ai,\n    formatNumber: li,\n    toLineHeight: di,\n    _readValueToProps: ui,\n    toTRBL: fi,\n    toTRBLCorners: gi,\n    toPadding: pi,\n    toFont: mi,\n    resolve: bi,\n    _addGrace: xi,\n    createContext: _i,\n    PI: D,\n    TAU: O,\n    PITAU: C,\n    INFINITY: A,\n    RAD_PER_DEG: T,\n    HALF_PI: L,\n    QUARTER_PI: E,\n    TWO_THIRDS_PI: R,\n    log10: I,\n    sign: z,\n    niceNum: F,\n    _factorize: V,\n    isNumber: B,\n    almostEquals: N,\n    almostWhole: W,\n    _setMinAndMaxByKey: j,\n    toRadians: H,\n    toDegrees: $,\n    _decimalPlaces: Y,\n    getAngleFromPoint: U,\n    distanceBetweenPoints: X,\n    _angleDiff: q,\n    _normalizeAngle: K,\n    _angleBetween: G,\n    _limitValue: Z,\n    _int16Range: J,\n    _isBetween: Q,\n    getRtlAdapter: yi,\n    overrideTextDirection: vi,\n    restoreTextDirection: wi,\n    _boundSegment: Si,\n    _boundSegments: Pi,\n    _computeSegments: Di\n  });\n  function Li(t, e, i, s) {\n    const {\n        controller: n,\n        data: o,\n        _sorted: a\n      } = t,\n      r = n._cachedMeta.iScale;\n    if (r && e === r.axis && \"r\" !== e && a && o.length) {\n      const t = r._reversePixels ? it : et;\n      if (!s) return t(o, e, i);\n      if (n._sharedOptions) {\n        const s = o[0],\n          n = \"function\" == typeof s.getRange && s.getRange(e);\n        if (n) {\n          const s = t(o, e, i - n),\n            a = t(o, e, i + n);\n          return {\n            lo: s.lo,\n            hi: a.hi\n          };\n        }\n      }\n    }\n    return {\n      lo: 0,\n      hi: o.length - 1\n    };\n  }\n  function Ei(t, e, i, s, n) {\n    const o = t.getSortedVisibleDatasetMetas(),\n      a = i[e];\n    for (let t = 0, i = o.length; t < i; ++t) {\n      const {\n          index: i,\n          data: r\n        } = o[t],\n        {\n          lo: l,\n          hi: h\n        } = Li(o[t], e, a, n);\n      for (let t = l; t <= h; ++t) {\n        const e = r[t];\n        e.skip || s(e, i, t);\n      }\n    }\n  }\n  function Ri(t, e, i, s, n) {\n    const o = [];\n    if (!n && !t.isPointInArea(e)) return o;\n    return Ei(t, i, e, function (i, a, r) {\n      (n || Se(i, t.chartArea, 0)) && i.inRange(e.x, e.y, s) && o.push({\n        element: i,\n        datasetIndex: a,\n        index: r\n      });\n    }, !0), o;\n  }\n  function Ii(t, e, i, s, n, o) {\n    let a = [];\n    const r = function (t) {\n      const e = -1 !== t.indexOf(\"x\"),\n        i = -1 !== t.indexOf(\"y\");\n      return function (t, s) {\n        const n = e ? Math.abs(t.x - s.x) : 0,\n          o = i ? Math.abs(t.y - s.y) : 0;\n        return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2));\n      };\n    }(i);\n    let l = Number.POSITIVE_INFINITY;\n    return Ei(t, i, e, function (i, h, c) {\n      const d = i.inRange(e.x, e.y, n);\n      if (s && !d) return;\n      const u = i.getCenterPoint(n);\n      if (!(!!o || t.isPointInArea(u)) && !d) return;\n      const f = r(e, u);\n      f < l ? (a = [{\n        element: i,\n        datasetIndex: h,\n        index: c\n      }], l = f) : f === l && a.push({\n        element: i,\n        datasetIndex: h,\n        index: c\n      });\n    }), a;\n  }\n  function zi(t, e, i, s, n, o) {\n    return o || t.isPointInArea(e) ? \"r\" !== i || s ? Ii(t, e, i, s, n, o) : function (t, e, i, s) {\n      let n = [];\n      return Ei(t, i, e, function (t, i, o) {\n        const {\n            startAngle: a,\n            endAngle: r\n          } = t.getProps([\"startAngle\", \"endAngle\"], s),\n          {\n            angle: l\n          } = U(t, {\n            x: e.x,\n            y: e.y\n          });\n        G(l, a, r) && n.push({\n          element: t,\n          datasetIndex: i,\n          index: o\n        });\n      }), n;\n    }(t, e, i, n) : [];\n  }\n  function Fi(t, e, i, s, n) {\n    const o = [],\n      a = \"x\" === i ? \"inXRange\" : \"inYRange\";\n    let r = !1;\n    return Ei(t, i, e, (t, s, l) => {\n      t[a](e[i], n) && (o.push({\n        element: t,\n        datasetIndex: s,\n        index: l\n      }), r = r || t.inRange(e.x, e.y, n));\n    }), s && !r ? [] : o;\n  }\n  var Vi = {\n    evaluateInteractionItems: Ei,\n    modes: {\n      index(t, e, i, s) {\n        const n = ue(e, t),\n          o = i.axis || \"x\",\n          a = i.includeInvisible || !1,\n          r = i.intersect ? Ri(t, n, o, s, a) : zi(t, n, o, !1, s, a),\n          l = [];\n        return r.length ? (t.getSortedVisibleDatasetMetas().forEach(t => {\n          const e = r[0].index,\n            i = t.data[e];\n          i && !i.skip && l.push({\n            element: i,\n            datasetIndex: t.index,\n            index: e\n          });\n        }), l) : [];\n      },\n      dataset(t, e, i, s) {\n        const n = ue(e, t),\n          o = i.axis || \"xy\",\n          a = i.includeInvisible || !1;\n        let r = i.intersect ? Ri(t, n, o, s, a) : zi(t, n, o, !1, s, a);\n        if (r.length > 0) {\n          const e = r[0].datasetIndex,\n            i = t.getDatasetMeta(e).data;\n          r = [];\n          for (let t = 0; t < i.length; ++t) r.push({\n            element: i[t],\n            datasetIndex: e,\n            index: t\n          });\n        }\n        return r;\n      },\n      point: (t, e, i, s) => Ri(t, ue(e, t), i.axis || \"xy\", s, i.includeInvisible || !1),\n      nearest(t, e, i, s) {\n        const n = ue(e, t),\n          o = i.axis || \"xy\",\n          a = i.includeInvisible || !1;\n        return zi(t, n, o, i.intersect, s, a);\n      },\n      x: (t, e, i, s) => Fi(t, ue(e, t), \"x\", i.intersect, s),\n      y: (t, e, i, s) => Fi(t, ue(e, t), \"y\", i.intersect, s)\n    }\n  };\n  const Bi = [\"left\", \"top\", \"right\", \"bottom\"];\n  function Ni(t, e) {\n    return t.filter(t => t.pos === e);\n  }\n  function Wi(t, e) {\n    return t.filter(t => -1 === Bi.indexOf(t.pos) && t.box.axis === e);\n  }\n  function ji(t, e) {\n    return t.sort((t, i) => {\n      const s = e ? i : t,\n        n = e ? t : i;\n      return s.weight === n.weight ? s.index - n.index : s.weight - n.weight;\n    });\n  }\n  function Hi(t, e) {\n    const i = function (t) {\n        const e = {};\n        for (const i of t) {\n          const {\n            stack: t,\n            pos: s,\n            stackWeight: n\n          } = i;\n          if (!t || !Bi.includes(s)) continue;\n          const o = e[t] || (e[t] = {\n            count: 0,\n            placed: 0,\n            weight: 0,\n            size: 0\n          });\n          o.count++, o.weight += n;\n        }\n        return e;\n      }(t),\n      {\n        vBoxMaxWidth: s,\n        hBoxMaxHeight: n\n      } = e;\n    let o, a, r;\n    for (o = 0, a = t.length; o < a; ++o) {\n      r = t[o];\n      const {\n          fullSize: a\n        } = r.box,\n        l = i[r.stack],\n        h = l && r.stackWeight / l.weight;\n      r.horizontal ? (r.width = h ? h * s : a && e.availableWidth, r.height = n) : (r.width = s, r.height = h ? h * n : a && e.availableHeight);\n    }\n    return i;\n  }\n  function $i(t, e, i, s) {\n    return Math.max(t[i], e[i]) + Math.max(t[s], e[s]);\n  }\n  function Yi(t, e) {\n    t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right);\n  }\n  function Ui(t, e, i, s) {\n    const {\n        pos: o,\n        box: a\n      } = i,\n      r = t.maxPadding;\n    if (!n(o)) {\n      i.size && (t[o] -= i.size);\n      const e = s[i.stack] || {\n        size: 0,\n        count: 1\n      };\n      e.size = Math.max(e.size, i.horizontal ? a.height : a.width), i.size = e.size / e.count, t[o] += i.size;\n    }\n    a.getPadding && Yi(r, a.getPadding());\n    const l = Math.max(0, e.outerWidth - $i(r, t, \"left\", \"right\")),\n      h = Math.max(0, e.outerHeight - $i(r, t, \"top\", \"bottom\")),\n      c = l !== t.w,\n      d = h !== t.h;\n    return t.w = l, t.h = h, i.horizontal ? {\n      same: c,\n      other: d\n    } : {\n      same: d,\n      other: c\n    };\n  }\n  function Xi(t, e) {\n    const i = e.maxPadding;\n    function s(t) {\n      const s = {\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0\n      };\n      return t.forEach(t => {\n        s[t] = Math.max(e[t], i[t]);\n      }), s;\n    }\n    return s(t ? [\"left\", \"right\"] : [\"top\", \"bottom\"]);\n  }\n  function qi(t, e, i, s) {\n    const n = [];\n    let o, a, r, l, h, c;\n    for (o = 0, a = t.length, h = 0; o < a; ++o) {\n      r = t[o], l = r.box, l.update(r.width || e.w, r.height || e.h, Xi(r.horizontal, e));\n      const {\n        same: a,\n        other: d\n      } = Ui(e, i, r, s);\n      h |= a && n.length, c = c || d, l.fullSize || n.push(r);\n    }\n    return h && qi(n, e, i, s) || c;\n  }\n  function Ki(t, e, i, s, n) {\n    t.top = i, t.left = e, t.right = e + s, t.bottom = i + n, t.width = s, t.height = n;\n  }\n  function Gi(t, e, i, s) {\n    const n = i.padding;\n    let {\n      x: o,\n      y: a\n    } = e;\n    for (const r of t) {\n      const t = r.box,\n        l = s[r.stack] || {\n          count: 1,\n          placed: 0,\n          weight: 1\n        },\n        h = r.stackWeight / l.weight || 1;\n      if (r.horizontal) {\n        const s = e.w * h,\n          o = l.size || t.height;\n        M(l.start) && (a = l.start), t.fullSize ? Ki(t, n.left, a, i.outerWidth - n.right - n.left, o) : Ki(t, e.left + l.placed, a, s, o), l.start = a, l.placed += s, a = t.bottom;\n      } else {\n        const s = e.h * h,\n          a = l.size || t.width;\n        M(l.start) && (o = l.start), t.fullSize ? Ki(t, o, n.top, a, i.outerHeight - n.bottom - n.top) : Ki(t, o, e.top + l.placed, a, s), l.start = o, l.placed += s, o = t.right;\n      }\n    }\n    e.x = o, e.y = a;\n  }\n  ne.set(\"layout\", {\n    autoPadding: !0,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n  var Zi = {\n    addBox(t, e) {\n      t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || \"top\", e.weight = e.weight || 0, e._layers = e._layers || function () {\n        return [{\n          z: 0,\n          draw(t) {\n            e.draw(t);\n          }\n        }];\n      }, t.boxes.push(e);\n    },\n    removeBox(t, e) {\n      const i = t.boxes ? t.boxes.indexOf(e) : -1;\n      -1 !== i && t.boxes.splice(i, 1);\n    },\n    configure(t, e, i) {\n      e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight;\n    },\n    update(t, e, i, s) {\n      if (!t) return;\n      const n = pi(t.options.layout.padding),\n        o = Math.max(e - n.width, 0),\n        a = Math.max(i - n.height, 0),\n        r = function (t) {\n          const e = function (t) {\n              const e = [];\n              let i, s, n, o, a, r;\n              for (i = 0, s = (t || []).length; i < s; ++i) n = t[i], {\n                position: o,\n                options: {\n                  stack: a,\n                  stackWeight: r = 1\n                }\n              } = n, e.push({\n                index: i,\n                box: n,\n                pos: o,\n                horizontal: n.isHorizontal(),\n                weight: n.weight,\n                stack: a && o + a,\n                stackWeight: r\n              });\n              return e;\n            }(t),\n            i = ji(e.filter(t => t.box.fullSize), !0),\n            s = ji(Ni(e, \"left\"), !0),\n            n = ji(Ni(e, \"right\")),\n            o = ji(Ni(e, \"top\"), !0),\n            a = ji(Ni(e, \"bottom\")),\n            r = Wi(e, \"x\"),\n            l = Wi(e, \"y\");\n          return {\n            fullSize: i,\n            leftAndTop: s.concat(o),\n            rightAndBottom: n.concat(l).concat(a).concat(r),\n            chartArea: Ni(e, \"chartArea\"),\n            vertical: s.concat(n).concat(l),\n            horizontal: o.concat(a).concat(r)\n          };\n        }(t.boxes),\n        l = r.vertical,\n        h = r.horizontal;\n      d(t.boxes, t => {\n        \"function\" == typeof t.beforeLayout && t.beforeLayout();\n      });\n      const c = l.reduce((t, e) => e.box.options && !1 === e.box.options.display ? t : t + 1, 0) || 1,\n        u = Object.freeze({\n          outerWidth: e,\n          outerHeight: i,\n          padding: n,\n          availableWidth: o,\n          availableHeight: a,\n          vBoxMaxWidth: o / 2 / c,\n          hBoxMaxHeight: a / 2\n        }),\n        f = Object.assign({}, n);\n      Yi(f, pi(s));\n      const g = Object.assign({\n          maxPadding: f,\n          w: o,\n          h: a,\n          x: n.left,\n          y: n.top\n        }, n),\n        p = Hi(l.concat(h), u);\n      qi(r.fullSize, g, u, p), qi(l, g, u, p), qi(h, g, u, p) && qi(l, g, u, p), function (t) {\n        const e = t.maxPadding;\n        function i(i) {\n          const s = Math.max(e[i] - t[i], 0);\n          return t[i] += s, s;\n        }\n        t.y += i(\"top\"), t.x += i(\"left\"), i(\"right\"), i(\"bottom\");\n      }(g), Gi(r.leftAndTop, g, u, p), g.x += g.w, g.y += g.h, Gi(r.rightAndBottom, g, u, p), t.chartArea = {\n        left: g.left,\n        top: g.top,\n        right: g.left + g.w,\n        bottom: g.top + g.h,\n        height: g.h,\n        width: g.w\n      }, d(r.chartArea, e => {\n        const i = e.box;\n        Object.assign(i, t.chartArea), i.update(g.w, g.h, {\n          left: 0,\n          top: 0,\n          right: 0,\n          bottom: 0\n        });\n      });\n    }\n  };\n  class Ji {\n    acquireContext(t, e) {}\n    releaseContext(t) {\n      return !1;\n    }\n    addEventListener(t, e, i) {}\n    removeEventListener(t, e, i) {}\n    getDevicePixelRatio() {\n      return 1;\n    }\n    getMaximumSize(t, e, i, s) {\n      return e = Math.max(0, e || t.width), i = i || t.height, {\n        width: e,\n        height: Math.max(0, s ? Math.floor(e / s) : i)\n      };\n    }\n    isAttached(t) {\n      return !0;\n    }\n    updateConfig(t) {}\n  }\n  class Qi extends Ji {\n    acquireContext(t) {\n      return t && t.getContext && t.getContext(\"2d\") || null;\n    }\n    updateConfig(t) {\n      t.options.animation = !1;\n    }\n  }\n  const ts = {\n      touchstart: \"mousedown\",\n      touchmove: \"mousemove\",\n      touchend: \"mouseup\",\n      pointerenter: \"mouseenter\",\n      pointerdown: \"mousedown\",\n      pointermove: \"mousemove\",\n      pointerup: \"mouseup\",\n      pointerleave: \"mouseout\",\n      pointerout: \"mouseout\"\n    },\n    es = t => null === t || \"\" === t;\n  const is = !!me && {\n    passive: !0\n  };\n  function ss(t, e, i) {\n    t.canvas.removeEventListener(e, i, is);\n  }\n  function ns(t, e) {\n    for (const i of t) if (i === e || i.contains(e)) return !0;\n  }\n  function os(t, e, i) {\n    const s = t.canvas,\n      n = new MutationObserver(t => {\n        let e = !1;\n        for (const i of t) e = e || ns(i.addedNodes, s), e = e && !ns(i.removedNodes, s);\n        e && i();\n      });\n    return n.observe(document, {\n      childList: !0,\n      subtree: !0\n    }), n;\n  }\n  function as(t, e, i) {\n    const s = t.canvas,\n      n = new MutationObserver(t => {\n        let e = !1;\n        for (const i of t) e = e || ns(i.removedNodes, s), e = e && !ns(i.addedNodes, s);\n        e && i();\n      });\n    return n.observe(document, {\n      childList: !0,\n      subtree: !0\n    }), n;\n  }\n  const rs = new Map();\n  let ls = 0;\n  function hs() {\n    const t = window.devicePixelRatio;\n    t !== ls && (ls = t, rs.forEach((e, i) => {\n      i.currentDevicePixelRatio !== t && e();\n    }));\n  }\n  function cs(t, e, i) {\n    const s = t.canvas,\n      n = s && ae(s);\n    if (!n) return;\n    const o = ht((t, e) => {\n        const s = n.clientWidth;\n        i(t, e), s < n.clientWidth && i();\n      }, window),\n      a = new ResizeObserver(t => {\n        const e = t[0],\n          i = e.contentRect.width,\n          s = e.contentRect.height;\n        0 === i && 0 === s || o(i, s);\n      });\n    return a.observe(n), function (t, e) {\n      rs.size || window.addEventListener(\"resize\", hs), rs.set(t, e);\n    }(t, o), a;\n  }\n  function ds(t, e, i) {\n    i && i.disconnect(), \"resize\" === e && function (t) {\n      rs.delete(t), rs.size || window.removeEventListener(\"resize\", hs);\n    }(t);\n  }\n  function us(t, e, i) {\n    const s = t.canvas,\n      n = ht(e => {\n        null !== t.ctx && i(function (t, e) {\n          const i = ts[t.type] || t.type,\n            {\n              x: s,\n              y: n\n            } = ue(t, e);\n          return {\n            type: i,\n            chart: e,\n            native: t,\n            x: void 0 !== s ? s : null,\n            y: void 0 !== n ? n : null\n          };\n        }(e, t));\n      }, t, t => {\n        const e = t[0];\n        return [e, e.offsetX, e.offsetY];\n      });\n    return function (t, e, i) {\n      t.addEventListener(e, i, is);\n    }(s, e, n), n;\n  }\n  class fs extends Ji {\n    acquireContext(t, e) {\n      const i = t && t.getContext && t.getContext(\"2d\");\n      return i && i.canvas === t ? (function (t, e) {\n        const i = t.style,\n          s = t.getAttribute(\"height\"),\n          n = t.getAttribute(\"width\");\n        if (t.$chartjs = {\n          initial: {\n            height: s,\n            width: n,\n            style: {\n              display: i.display,\n              height: i.height,\n              width: i.width\n            }\n          }\n        }, i.display = i.display || \"block\", i.boxSizing = i.boxSizing || \"border-box\", es(n)) {\n          const e = be(t, \"width\");\n          void 0 !== e && (t.width = e);\n        }\n        if (es(s)) if (\"\" === t.style.height) t.height = t.width / (e || 2);else {\n          const e = be(t, \"height\");\n          void 0 !== e && (t.height = e);\n        }\n      }(t, e), i) : null;\n    }\n    releaseContext(t) {\n      const e = t.canvas;\n      if (!e.$chartjs) return !1;\n      const s = e.$chartjs.initial;\n      [\"height\", \"width\"].forEach(t => {\n        const n = s[t];\n        i(n) ? e.removeAttribute(t) : e.setAttribute(t, n);\n      });\n      const n = s.style || {};\n      return Object.keys(n).forEach(t => {\n        e.style[t] = n[t];\n      }), e.width = e.width, delete e.$chartjs, !0;\n    }\n    addEventListener(t, e, i) {\n      this.removeEventListener(t, e);\n      const s = t.$proxies || (t.$proxies = {}),\n        n = {\n          attach: os,\n          detach: as,\n          resize: cs\n        }[e] || us;\n      s[e] = n(t, e, i);\n    }\n    removeEventListener(t, e) {\n      const i = t.$proxies || (t.$proxies = {}),\n        s = i[e];\n      if (!s) return;\n      ({\n        attach: ds,\n        detach: ds,\n        resize: ds\n      }[e] || ss)(t, e, s), i[e] = void 0;\n    }\n    getDevicePixelRatio() {\n      return window.devicePixelRatio;\n    }\n    getMaximumSize(t, e, i, s) {\n      return ge(t, e, i, s);\n    }\n    isAttached(t) {\n      const e = ae(t);\n      return !(!e || !e.isConnected);\n    }\n  }\n  function gs(t) {\n    return !oe() || \"undefined\" != typeof OffscreenCanvas && t instanceof OffscreenCanvas ? Qi : fs;\n  }\n  var ps = Object.freeze({\n    __proto__: null,\n    _detectPlatform: gs,\n    BasePlatform: Ji,\n    BasicPlatform: Qi,\n    DomPlatform: fs\n  });\n  const ms = \"transparent\",\n    bs = {\n      boolean: (t, e, i) => i > .5 ? e : t,\n      color(t, e, i) {\n        const s = Jt(t || ms),\n          n = s.valid && Jt(e || ms);\n        return n && n.valid ? n.mix(s, i).hexString() : e;\n      },\n      number: (t, e, i) => t + (e - t) * i\n    };\n  class xs {\n    constructor(t, e, i, s) {\n      const n = e[i];\n      s = bi([t.to, s, n, t.from]);\n      const o = bi([t.from, n, s]);\n      this._active = !0, this._fn = t.fn || bs[t.type || typeof o], this._easing = si[t.easing] || si.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = o, this._to = s, this._promises = void 0;\n    }\n    active() {\n      return this._active;\n    }\n    update(t, e, i) {\n      if (this._active) {\n        this._notify(!1);\n        const s = this._target[this._prop],\n          n = i - this._start,\n          o = this._duration - n;\n        this._start = i, this._duration = Math.floor(Math.max(o, t.duration)), this._total += n, this._loop = !!t.loop, this._to = bi([t.to, e, s, t.from]), this._from = bi([t.from, s, e]);\n      }\n    }\n    cancel() {\n      this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));\n    }\n    tick(t) {\n      const e = t - this._start,\n        i = this._duration,\n        s = this._prop,\n        n = this._from,\n        o = this._loop,\n        a = this._to;\n      let r;\n      if (this._active = n !== a && (o || e < i), !this._active) return this._target[s] = a, void this._notify(!0);\n      e < 0 ? this._target[s] = n : (r = e / i % 2, r = o && r > 1 ? 2 - r : r, r = this._easing(Math.min(1, Math.max(0, r))), this._target[s] = this._fn(n, a, r));\n    }\n    wait() {\n      const t = this._promises || (this._promises = []);\n      return new Promise((e, i) => {\n        t.push({\n          res: e,\n          rej: i\n        });\n      });\n    }\n    _notify(t) {\n      const e = t ? \"res\" : \"rej\",\n        i = this._promises || [];\n      for (let t = 0; t < i.length; t++) i[t][e]();\n    }\n  }\n  ne.set(\"animation\", {\n    delay: void 0,\n    duration: 1e3,\n    easing: \"easeOutQuart\",\n    fn: void 0,\n    from: void 0,\n    loop: void 0,\n    to: void 0,\n    type: void 0\n  });\n  const _s = Object.keys(ne.animation);\n  ne.describe(\"animation\", {\n    _fallback: !1,\n    _indexable: !1,\n    _scriptable: t => \"onProgress\" !== t && \"onComplete\" !== t && \"fn\" !== t\n  }), ne.set(\"animations\", {\n    colors: {\n      type: \"color\",\n      properties: [\"color\", \"borderColor\", \"backgroundColor\"]\n    },\n    numbers: {\n      type: \"number\",\n      properties: [\"x\", \"y\", \"borderWidth\", \"radius\", \"tension\"]\n    }\n  }), ne.describe(\"animations\", {\n    _fallback: \"animation\"\n  }), ne.set(\"transitions\", {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: \"transparent\"\n        },\n        visible: {\n          type: \"boolean\",\n          duration: 0\n        }\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: \"transparent\"\n        },\n        visible: {\n          type: \"boolean\",\n          easing: \"linear\",\n          fn: t => 0 | t\n        }\n      }\n    }\n  });\n  class ys {\n    constructor(t, e) {\n      this._chart = t, this._properties = new Map(), this.configure(e);\n    }\n    configure(t) {\n      if (!n(t)) return;\n      const e = this._properties;\n      Object.getOwnPropertyNames(t).forEach(i => {\n        const o = t[i];\n        if (!n(o)) return;\n        const a = {};\n        for (const t of _s) a[t] = o[t];\n        (s(o.properties) && o.properties || [i]).forEach(t => {\n          t !== i && e.has(t) || e.set(t, a);\n        });\n      });\n    }\n    _animateOptions(t, e) {\n      const i = e.options,\n        s = function (t, e) {\n          if (!e) return;\n          let i = t.options;\n          if (!i) return void (t.options = e);\n          i.$shared && (t.options = i = Object.assign({}, i, {\n            $shared: !1,\n            $animations: {}\n          }));\n          return i;\n        }(t, i);\n      if (!s) return [];\n      const n = this._createAnimations(s, i);\n      return i.$shared && function (t, e) {\n        const i = [],\n          s = Object.keys(e);\n        for (let e = 0; e < s.length; e++) {\n          const n = t[s[e]];\n          n && n.active() && i.push(n.wait());\n        }\n        return Promise.all(i);\n      }(t.options.$animations, i).then(() => {\n        t.options = i;\n      }, () => {}), n;\n    }\n    _createAnimations(t, e) {\n      const i = this._properties,\n        s = [],\n        n = t.$animations || (t.$animations = {}),\n        o = Object.keys(e),\n        a = Date.now();\n      let r;\n      for (r = o.length - 1; r >= 0; --r) {\n        const l = o[r];\n        if (\"$\" === l.charAt(0)) continue;\n        if (\"options\" === l) {\n          s.push(...this._animateOptions(t, e));\n          continue;\n        }\n        const h = e[l];\n        let c = n[l];\n        const d = i.get(l);\n        if (c) {\n          if (d && c.active()) {\n            c.update(d, h, a);\n            continue;\n          }\n          c.cancel();\n        }\n        d && d.duration ? (n[l] = c = new xs(d, t, l, h), s.push(c)) : t[l] = h;\n      }\n      return s;\n    }\n    update(t, e) {\n      if (0 === this._properties.size) return void Object.assign(t, e);\n      const i = this._createAnimations(t, e);\n      return i.length ? (mt.add(this._chart, i), !0) : void 0;\n    }\n  }\n  function vs(t, e) {\n    const i = t && t.options || {},\n      s = i.reverse,\n      n = void 0 === i.min ? e : 0,\n      o = void 0 === i.max ? e : 0;\n    return {\n      start: s ? o : n,\n      end: s ? n : o\n    };\n  }\n  function ws(t, e) {\n    const i = [],\n      s = t._getSortedDatasetMetas(e);\n    let n, o;\n    for (n = 0, o = s.length; n < o; ++n) i.push(s[n].index);\n    return i;\n  }\n  function Ms(t, e, i) {\n    let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const n = t.keys,\n      a = \"single\" === s.mode;\n    let r, l, h, c;\n    if (null !== e) {\n      for (r = 0, l = n.length; r < l; ++r) {\n        if (h = +n[r], h === i) {\n          if (s.all) continue;\n          break;\n        }\n        c = t.values[h], o(c) && (a || 0 === e || z(e) === z(c)) && (e += c);\n      }\n      return e;\n    }\n  }\n  function ks(t, e) {\n    const i = t && t.options.stacked;\n    return i || void 0 === i && void 0 !== e.stack;\n  }\n  function Ss(t, e, i) {\n    const s = t[e] || (t[e] = {});\n    return s[i] || (s[i] = {});\n  }\n  function Ps(t, e, i, s) {\n    for (const n of e.getMatchingVisibleMetas(s).reverse()) {\n      const e = t[n.index];\n      if (i && e > 0 || !i && e < 0) return n.index;\n    }\n    return null;\n  }\n  function Ds(t, e) {\n    const {\n        chart: i,\n        _cachedMeta: s\n      } = t,\n      n = i._stacks || (i._stacks = {}),\n      {\n        iScale: o,\n        vScale: a,\n        index: r\n      } = s,\n      l = o.axis,\n      h = a.axis,\n      c = function (t, e, i) {\n        return \"\".concat(t.id, \".\").concat(e.id, \".\").concat(i.stack || i.type);\n      }(o, a, s),\n      d = e.length;\n    let u;\n    for (let t = 0; t < d; ++t) {\n      const i = e[t],\n        {\n          [l]: o,\n          [h]: d\n        } = i;\n      u = (i._stacks || (i._stacks = {}))[h] = Ss(n, c, o), u[r] = d, u._top = Ps(u, a, !0, s.type), u._bottom = Ps(u, a, !1, s.type);\n    }\n  }\n  function Os(t, e) {\n    const i = t.scales;\n    return Object.keys(i).filter(t => i[t].axis === e).shift();\n  }\n  function Cs(t, e) {\n    const i = t.controller.index,\n      s = t.vScale && t.vScale.axis;\n    if (s) {\n      e = e || t._parsed;\n      for (const t of e) {\n        const e = t._stacks;\n        if (!e || void 0 === e[s] || void 0 === e[s][i]) return;\n        delete e[s][i];\n      }\n    }\n  }\n  const As = t => \"reset\" === t || \"none\" === t,\n    Ts = (t, e) => e ? t : Object.assign({}, t);\n  class Ls {\n    constructor(t, e) {\n      this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.initialize();\n    }\n    initialize() {\n      const t = this._cachedMeta;\n      this.configure(), this.linkScales(), t._stacked = ks(t.vScale, t), this.addElements();\n    }\n    updateIndex(t) {\n      this.index !== t && Cs(this._cachedMeta), this.index = t;\n    }\n    linkScales() {\n      const t = this.chart,\n        e = this._cachedMeta,\n        i = this.getDataset(),\n        s = (t, e, i, s) => \"x\" === t ? e : \"r\" === t ? s : i,\n        n = e.xAxisID = r(i.xAxisID, Os(t, \"x\")),\n        o = e.yAxisID = r(i.yAxisID, Os(t, \"y\")),\n        a = e.rAxisID = r(i.rAxisID, Os(t, \"r\")),\n        l = e.indexAxis,\n        h = e.iAxisID = s(l, n, o, a),\n        c = e.vAxisID = s(l, o, n, a);\n      e.xScale = this.getScaleForId(n), e.yScale = this.getScaleForId(o), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(h), e.vScale = this.getScaleForId(c);\n    }\n    getDataset() {\n      return this.chart.data.datasets[this.index];\n    }\n    getMeta() {\n      return this.chart.getDatasetMeta(this.index);\n    }\n    getScaleForId(t) {\n      return this.chart.scales[t];\n    }\n    _getOtherScale(t) {\n      const e = this._cachedMeta;\n      return t === e.iScale ? e.vScale : e.iScale;\n    }\n    reset() {\n      this._update(\"reset\");\n    }\n    _destroy() {\n      const t = this._cachedMeta;\n      this._data && at(this._data, this), t._stacked && Cs(t);\n    }\n    _dataCheck() {\n      const t = this.getDataset(),\n        e = t.data || (t.data = []),\n        i = this._data;\n      if (n(e)) this._data = function (t) {\n        const e = Object.keys(t),\n          i = new Array(e.length);\n        let s, n, o;\n        for (s = 0, n = e.length; s < n; ++s) o = e[s], i[s] = {\n          x: o,\n          y: t[o]\n        };\n        return i;\n      }(e);else if (i !== e) {\n        if (i) {\n          at(i, this);\n          const t = this._cachedMeta;\n          Cs(t), t._parsed = [];\n        }\n        e && Object.isExtensible(e) && ot(e, this), this._syncList = [], this._data = e;\n      }\n    }\n    addElements() {\n      const t = this._cachedMeta;\n      this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());\n    }\n    buildOrUpdateElements(t) {\n      const e = this._cachedMeta,\n        i = this.getDataset();\n      let s = !1;\n      this._dataCheck();\n      const n = e._stacked;\n      e._stacked = ks(e.vScale, e), e.stack !== i.stack && (s = !0, Cs(e), e.stack = i.stack), this._resyncElements(t), (s || n !== e._stacked) && Ds(this, e._parsed);\n    }\n    configure() {\n      const t = this.chart.config,\n        e = t.datasetScopeKeys(this._type),\n        i = t.getOptionScopes(this.getDataset(), e, !0);\n      this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};\n    }\n    parse(t, e) {\n      const {\n          _cachedMeta: i,\n          _data: o\n        } = this,\n        {\n          iScale: a,\n          _stacked: r\n        } = i,\n        l = a.axis;\n      let h,\n        c,\n        d,\n        u = 0 === t && e === o.length || i._sorted,\n        f = t > 0 && i._parsed[t - 1];\n      if (!1 === this._parsing) i._parsed = o, i._sorted = !0, d = o;else {\n        d = s(o[t]) ? this.parseArrayData(i, o, t, e) : n(o[t]) ? this.parseObjectData(i, o, t, e) : this.parsePrimitiveData(i, o, t, e);\n        const a = () => null === c[l] || f && c[l] < f[l];\n        for (h = 0; h < e; ++h) i._parsed[h + t] = c = d[h], u && (a() && (u = !1), f = c);\n        i._sorted = u;\n      }\n      r && Ds(this, d);\n    }\n    parsePrimitiveData(t, e, i, s) {\n      const {\n          iScale: n,\n          vScale: o\n        } = t,\n        a = n.axis,\n        r = o.axis,\n        l = n.getLabels(),\n        h = n === o,\n        c = new Array(s);\n      let d, u, f;\n      for (d = 0, u = s; d < u; ++d) f = d + i, c[d] = {\n        [a]: h || n.parse(l[f], f),\n        [r]: o.parse(e[f], f)\n      };\n      return c;\n    }\n    parseArrayData(t, e, i, s) {\n      const {\n          xScale: n,\n          yScale: o\n        } = t,\n        a = new Array(s);\n      let r, l, h, c;\n      for (r = 0, l = s; r < l; ++r) h = r + i, c = e[h], a[r] = {\n        x: n.parse(c[0], h),\n        y: o.parse(c[1], h)\n      };\n      return a;\n    }\n    parseObjectData(t, e, i, s) {\n      const {\n          xScale: n,\n          yScale: o\n        } = t,\n        {\n          xAxisKey: a = \"x\",\n          yAxisKey: r = \"y\"\n        } = this._parsing,\n        l = new Array(s);\n      let h, c, d, u;\n      for (h = 0, c = s; h < c; ++h) d = h + i, u = e[d], l[h] = {\n        x: n.parse(y(u, a), d),\n        y: o.parse(y(u, r), d)\n      };\n      return l;\n    }\n    getParsed(t) {\n      return this._cachedMeta._parsed[t];\n    }\n    getDataElement(t) {\n      return this._cachedMeta.data[t];\n    }\n    applyStack(t, e, i) {\n      const s = this.chart,\n        n = this._cachedMeta,\n        o = e[t.axis];\n      return Ms({\n        keys: ws(s, !0),\n        values: e._stacks[t.axis]\n      }, o, n.index, {\n        mode: i\n      });\n    }\n    updateRangeFromParsed(t, e, i, s) {\n      const n = i[e.axis];\n      let o = null === n ? NaN : n;\n      const a = s && i._stacks[e.axis];\n      s && a && (s.values = a, o = Ms(s, n, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o);\n    }\n    getMinMax(t, e) {\n      const i = this._cachedMeta,\n        s = i._parsed,\n        n = i._sorted && t === i.iScale,\n        a = s.length,\n        r = this._getOtherScale(t),\n        l = ((t, e, i) => t && !e.hidden && e._stacked && {\n          keys: ws(i, !0),\n          values: null\n        })(e, i, this.chart),\n        h = {\n          min: Number.POSITIVE_INFINITY,\n          max: Number.NEGATIVE_INFINITY\n        },\n        {\n          min: c,\n          max: d\n        } = function (t) {\n          const {\n            min: e,\n            max: i,\n            minDefined: s,\n            maxDefined: n\n          } = t.getUserBounds();\n          return {\n            min: s ? e : Number.NEGATIVE_INFINITY,\n            max: n ? i : Number.POSITIVE_INFINITY\n          };\n        }(r);\n      let u, f;\n      function g() {\n        f = s[u];\n        const e = f[r.axis];\n        return !o(f[t.axis]) || c > e || d < e;\n      }\n      for (u = 0; u < a && (g() || (this.updateRangeFromParsed(h, t, f, l), !n)); ++u);\n      if (n) for (u = a - 1; u >= 0; --u) if (!g()) {\n        this.updateRangeFromParsed(h, t, f, l);\n        break;\n      }\n      return h;\n    }\n    getAllParsedValues(t) {\n      const e = this._cachedMeta._parsed,\n        i = [];\n      let s, n, a;\n      for (s = 0, n = e.length; s < n; ++s) a = e[s][t.axis], o(a) && i.push(a);\n      return i;\n    }\n    getMaxOverflow() {\n      return !1;\n    }\n    getLabelAndValue(t) {\n      const e = this._cachedMeta,\n        i = e.iScale,\n        s = e.vScale,\n        n = this.getParsed(t);\n      return {\n        label: i ? \"\" + i.getLabelForValue(n[i.axis]) : \"\",\n        value: s ? \"\" + s.getLabelForValue(n[s.axis]) : \"\"\n      };\n    }\n    _update(t) {\n      const e = this._cachedMeta;\n      this.update(t || \"default\"), e._clip = function (t) {\n        let e, i, s, o;\n        return n(t) ? (e = t.top, i = t.right, s = t.bottom, o = t.left) : e = i = s = o = t, {\n          top: e,\n          right: i,\n          bottom: s,\n          left: o,\n          disabled: !1 === t\n        };\n      }(r(this.options.clip, function (t, e, i) {\n        if (!1 === i) return !1;\n        const s = vs(t, i),\n          n = vs(e, i);\n        return {\n          top: n.end,\n          right: s.end,\n          bottom: n.start,\n          left: s.start\n        };\n      }(e.xScale, e.yScale, this.getMaxOverflow())));\n    }\n    update(t) {}\n    draw() {\n      const t = this._ctx,\n        e = this.chart,\n        i = this._cachedMeta,\n        s = i.data || [],\n        n = e.chartArea,\n        o = [],\n        a = this._drawStart || 0,\n        r = this._drawCount || s.length - a,\n        l = this.options.drawActiveElementsOnTop;\n      let h;\n      for (i.dataset && i.dataset.draw(t, n, a, r), h = a; h < a + r; ++h) {\n        const e = s[h];\n        e.hidden || (e.active && l ? o.push(e) : e.draw(t, n));\n      }\n      for (h = 0; h < o.length; ++h) o[h].draw(t, n);\n    }\n    getStyle(t, e) {\n      const i = e ? \"active\" : \"default\";\n      return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i);\n    }\n    getContext(t, e, i) {\n      const s = this.getDataset();\n      let n;\n      if (t >= 0 && t < this._cachedMeta.data.length) {\n        const e = this._cachedMeta.data[t];\n        n = e.$context || (e.$context = function (t, e, i) {\n          return _i(t, {\n            active: !1,\n            dataIndex: e,\n            parsed: void 0,\n            raw: void 0,\n            element: i,\n            index: e,\n            mode: \"default\",\n            type: \"data\"\n          });\n        }(this.getContext(), t, e)), n.parsed = this.getParsed(t), n.raw = s.data[t], n.index = n.dataIndex = t;\n      } else n = this.$context || (this.$context = function (t, e) {\n        return _i(t, {\n          active: !1,\n          dataset: void 0,\n          datasetIndex: e,\n          index: e,\n          mode: \"default\",\n          type: \"dataset\"\n        });\n      }(this.chart.getContext(), this.index)), n.dataset = s, n.index = n.datasetIndex = this.index;\n      return n.active = !!e, n.mode = i, n;\n    }\n    resolveDatasetElementOptions(t) {\n      return this._resolveElementOptions(this.datasetElementType.id, t);\n    }\n    resolveDataElementOptions(t, e) {\n      return this._resolveElementOptions(this.dataElementType.id, e, t);\n    }\n    _resolveElementOptions(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"default\";\n      let i = arguments.length > 2 ? arguments[2] : undefined;\n      const s = \"active\" === e,\n        n = this._cachedDataOpts,\n        o = t + \"-\" + e,\n        a = n[o],\n        r = this.enableOptionSharing && M(i);\n      if (a) return Ts(a, r);\n      const l = this.chart.config,\n        h = l.datasetElementScopeKeys(this._type, t),\n        c = s ? [\"\".concat(t, \"Hover\"), \"hover\", t, \"\"] : [t, \"\"],\n        d = l.getOptionScopes(this.getDataset(), h),\n        u = Object.keys(ne.elements[t]),\n        f = l.resolveNamedOptions(d, u, () => this.getContext(i, s), c);\n      return f.$shared && (f.$shared = r, n[o] = Object.freeze(Ts(f, r))), f;\n    }\n    _resolveAnimations(t, e, i) {\n      const s = this.chart,\n        n = this._cachedDataOpts,\n        o = \"animation-\".concat(e),\n        a = n[o];\n      if (a) return a;\n      let r;\n      if (!1 !== s.options.animation) {\n        const s = this.chart.config,\n          n = s.datasetAnimationScopeKeys(this._type, e),\n          o = s.getOptionScopes(this.getDataset(), n);\n        r = s.createResolver(o, this.getContext(t, i, e));\n      }\n      const l = new ys(s, r && r.animations);\n      return r && r._cacheable && (n[o] = Object.freeze(l)), l;\n    }\n    getSharedOptions(t) {\n      if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));\n    }\n    includeOptions(t, e) {\n      return !e || As(t) || this.chart._animationsDisabled;\n    }\n    _getSharedOptions(t, e) {\n      const i = this.resolveDataElementOptions(t, e),\n        s = this._sharedOptions,\n        n = this.getSharedOptions(i),\n        o = this.includeOptions(e, n) || n !== s;\n      return this.updateSharedOptions(n, e, i), {\n        sharedOptions: n,\n        includeOptions: o\n      };\n    }\n    updateElement(t, e, i, s) {\n      As(s) ? Object.assign(t, i) : this._resolveAnimations(e, s).update(t, i);\n    }\n    updateSharedOptions(t, e, i) {\n      t && !As(e) && this._resolveAnimations(void 0, e).update(t, i);\n    }\n    _setStyle(t, e, i, s) {\n      t.active = s;\n      const n = this.getStyle(e, s);\n      this._resolveAnimations(e, i, s).update(t, {\n        options: !s && this.getSharedOptions(n) || n\n      });\n    }\n    removeHoverStyle(t, e, i) {\n      this._setStyle(t, i, \"active\", !1);\n    }\n    setHoverStyle(t, e, i) {\n      this._setStyle(t, i, \"active\", !0);\n    }\n    _removeDatasetHoverStyle() {\n      const t = this._cachedMeta.dataset;\n      t && this._setStyle(t, void 0, \"active\", !1);\n    }\n    _setDatasetHoverStyle() {\n      const t = this._cachedMeta.dataset;\n      t && this._setStyle(t, void 0, \"active\", !0);\n    }\n    _resyncElements(t) {\n      const e = this._data,\n        i = this._cachedMeta.data;\n      for (const [t, e, i] of this._syncList) this[t](e, i);\n      this._syncList = [];\n      const s = i.length,\n        n = e.length,\n        o = Math.min(n, s);\n      o && this.parse(0, o), n > s ? this._insertElements(s, n - s, t) : n < s && this._removeElements(n, s - n);\n    }\n    _insertElements(t, e) {\n      let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n      const s = this._cachedMeta,\n        n = s.data,\n        o = t + e;\n      let a;\n      const r = t => {\n        for (t.length += e, a = t.length - 1; a >= o; a--) t[a] = t[a - e];\n      };\n      for (r(n), a = t; a < o; ++a) n[a] = new this.dataElementType();\n      this._parsing && r(s._parsed), this.parse(t, e), i && this.updateElements(n, t, e, \"reset\");\n    }\n    updateElements(t, e, i, s) {}\n    _removeElements(t, e) {\n      const i = this._cachedMeta;\n      if (this._parsing) {\n        const s = i._parsed.splice(t, e);\n        i._stacked && Cs(i, s);\n      }\n      i.data.splice(t, e);\n    }\n    _sync(t) {\n      if (this._parsing) this._syncList.push(t);else {\n        const [e, i, s] = t;\n        this[e](i, s);\n      }\n      this.chart._dataChanges.push([this.index, ...t]);\n    }\n    _onDataPush() {\n      const t = arguments.length;\n      this._sync([\"_insertElements\", this.getDataset().data.length - t, t]);\n    }\n    _onDataPop() {\n      this._sync([\"_removeElements\", this._cachedMeta.data.length - 1, 1]);\n    }\n    _onDataShift() {\n      this._sync([\"_removeElements\", 0, 1]);\n    }\n    _onDataSplice(t, e) {\n      e && this._sync([\"_removeElements\", t, e]);\n      const i = arguments.length - 2;\n      i && this._sync([\"_insertElements\", t, i]);\n    }\n    _onDataUnshift() {\n      this._sync([\"_insertElements\", 0, arguments.length]);\n    }\n  }\n  Ls.defaults = {}, Ls.prototype.datasetElementType = null, Ls.prototype.dataElementType = null;\n  class Es {\n    constructor() {\n      this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0;\n    }\n    tooltipPosition(t) {\n      const {\n        x: e,\n        y: i\n      } = this.getProps([\"x\", \"y\"], t);\n      return {\n        x: e,\n        y: i\n      };\n    }\n    hasValue() {\n      return B(this.x) && B(this.y);\n    }\n    getProps(t, e) {\n      const i = this.$animations;\n      if (!e || !i) return this;\n      const s = {};\n      return t.forEach(t => {\n        s[t] = i[t] && i[t].active() ? i[t]._to : this[t];\n      }), s;\n    }\n  }\n  Es.defaults = {}, Es.defaultRoutes = void 0;\n  const Rs = {\n    values: t => s(t) ? t : \"\" + t,\n    numeric(t, e, i) {\n      if (0 === t) return \"0\";\n      const s = this.chart.options.locale;\n      let n,\n        o = t;\n      if (i.length > 1) {\n        const e = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));\n        (e < 1e-4 || e > 1e15) && (n = \"scientific\"), o = function (t, e) {\n          let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;\n          Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t));\n          return i;\n        }(t, i);\n      }\n      const a = I(Math.abs(o)),\n        r = Math.max(Math.min(-1 * Math.floor(a), 20), 0),\n        l = {\n          notation: n,\n          minimumFractionDigits: r,\n          maximumFractionDigits: r\n        };\n      return Object.assign(l, this.options.ticks.format), li(t, s, l);\n    },\n    logarithmic(t, e, i) {\n      if (0 === t) return \"0\";\n      const s = t / Math.pow(10, Math.floor(I(t)));\n      return 1 === s || 2 === s || 5 === s ? Rs.numeric.call(this, t, e, i) : \"\";\n    }\n  };\n  var Is = {\n    formatters: Rs\n  };\n  function zs(t, e) {\n    const s = t.options.ticks,\n      n = s.maxTicksLimit || function (t) {\n        const e = t.options.offset,\n          i = t._tickSize(),\n          s = t._length / i + (e ? 0 : 1),\n          n = t._maxLength / i;\n        return Math.floor(Math.min(s, n));\n      }(t),\n      o = s.major.enabled ? function (t) {\n        const e = [];\n        let i, s;\n        for (i = 0, s = t.length; i < s; i++) t[i].major && e.push(i);\n        return e;\n      }(e) : [],\n      a = o.length,\n      r = o[0],\n      l = o[a - 1],\n      h = [];\n    if (a > n) return function (t, e, i, s) {\n      let n,\n        o = 0,\n        a = i[0];\n      for (s = Math.ceil(s), n = 0; n < t.length; n++) n === a && (e.push(t[n]), o++, a = i[o * s]);\n    }(e, h, o, a / n), h;\n    const c = function (t, e, i) {\n      const s = function (t) {\n          const e = t.length;\n          let i, s;\n          if (e < 2) return !1;\n          for (s = t[0], i = 1; i < e; ++i) if (t[i] - t[i - 1] !== s) return !1;\n          return s;\n        }(t),\n        n = e.length / i;\n      if (!s) return Math.max(n, 1);\n      const o = V(s);\n      for (let t = 0, e = o.length - 1; t < e; t++) {\n        const e = o[t];\n        if (e > n) return e;\n      }\n      return Math.max(n, 1);\n    }(o, e, n);\n    if (a > 0) {\n      let t, s;\n      const n = a > 1 ? Math.round((l - r) / (a - 1)) : null;\n      for (Fs(e, h, c, i(n) ? 0 : r - n, r), t = 0, s = a - 1; t < s; t++) Fs(e, h, c, o[t], o[t + 1]);\n      return Fs(e, h, c, l, i(n) ? e.length : l + n), h;\n    }\n    return Fs(e, h, c), h;\n  }\n  function Fs(t, e, i, s, n) {\n    const o = r(s, 0),\n      a = Math.min(r(n, t.length), t.length);\n    let l,\n      h,\n      c,\n      d = 0;\n    for (i = Math.ceil(i), n && (l = n - s, i = l / Math.floor(l / i)), c = o; c < 0;) d++, c = Math.round(o + d * i);\n    for (h = Math.max(o, 0); h < a; h++) h === c && (e.push(t[h]), d++, c = Math.round(o + d * i));\n  }\n  ne.set(\"scale\", {\n    display: !0,\n    offset: !1,\n    reverse: !1,\n    beginAtZero: !1,\n    bounds: \"ticks\",\n    grace: 0,\n    grid: {\n      display: !0,\n      lineWidth: 1,\n      drawBorder: !0,\n      drawOnChartArea: !0,\n      drawTicks: !0,\n      tickLength: 8,\n      tickWidth: (t, e) => e.lineWidth,\n      tickColor: (t, e) => e.color,\n      offset: !1,\n      borderDash: [],\n      borderDashOffset: 0,\n      borderWidth: 1\n    },\n    title: {\n      display: !1,\n      text: \"\",\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: !1,\n      textStrokeWidth: 0,\n      textStrokeColor: \"\",\n      padding: 3,\n      display: !0,\n      autoSkip: !0,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      callback: Is.formatters.values,\n      minor: {},\n      major: {},\n      align: \"center\",\n      crossAlign: \"near\",\n      showLabelBackdrop: !1,\n      backdropColor: \"rgba(255, 255, 255, 0.75)\",\n      backdropPadding: 2\n    }\n  }), ne.route(\"scale.ticks\", \"color\", \"\", \"color\"), ne.route(\"scale.grid\", \"color\", \"\", \"borderColor\"), ne.route(\"scale.grid\", \"borderColor\", \"\", \"borderColor\"), ne.route(\"scale.title\", \"color\", \"\", \"color\"), ne.describe(\"scale\", {\n    _fallback: !1,\n    _scriptable: t => !t.startsWith(\"before\") && !t.startsWith(\"after\") && \"callback\" !== t && \"parser\" !== t,\n    _indexable: t => \"borderDash\" !== t && \"tickBorderDash\" !== t\n  }), ne.describe(\"scales\", {\n    _fallback: \"scale\"\n  }), ne.describe(\"scale.ticks\", {\n    _scriptable: t => \"backdropPadding\" !== t && \"callback\" !== t,\n    _indexable: t => \"backdropPadding\" !== t\n  });\n  const Vs = (t, e, i) => \"top\" === e || \"left\" === e ? t[e] + i : t[e] - i;\n  function Bs(t, e) {\n    const i = [],\n      s = t.length / e,\n      n = t.length;\n    let o = 0;\n    for (; o < n; o += s) i.push(t[Math.floor(o)]);\n    return i;\n  }\n  function Ns(t, e, i) {\n    const s = t.ticks.length,\n      n = Math.min(e, s - 1),\n      o = t._startPixel,\n      a = t._endPixel,\n      r = 1e-6;\n    let l,\n      h = t.getPixelForTick(n);\n    if (!(i && (l = 1 === s ? Math.max(h - o, a - h) : 0 === e ? (t.getPixelForTick(1) - h) / 2 : (h - t.getPixelForTick(n - 1)) / 2, h += n < e ? l : -l, h < o - r || h > a + r))) return h;\n  }\n  function Ws(t) {\n    return t.drawTicks ? t.tickLength : 0;\n  }\n  function js(t, e) {\n    if (!t.display) return 0;\n    const i = mi(t.font, e),\n      n = pi(t.padding);\n    return (s(t.text) ? t.text.length : 1) * i.lineHeight + n.height;\n  }\n  function Hs(t, e, i) {\n    let s = dt(t);\n    return (i && \"right\" !== e || !i && \"right\" === e) && (s = (t => \"left\" === t ? \"right\" : \"right\" === t ? \"left\" : t)(s)), s;\n  }\n  class $s extends Es {\n    constructor(t) {\n      super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;\n    }\n    init(t) {\n      this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);\n    }\n    parse(t, e) {\n      return t;\n    }\n    getUserBounds() {\n      let {\n        _userMin: t,\n        _userMax: e,\n        _suggestedMin: i,\n        _suggestedMax: s\n      } = this;\n      return t = a(t, Number.POSITIVE_INFINITY), e = a(e, Number.NEGATIVE_INFINITY), i = a(i, Number.POSITIVE_INFINITY), s = a(s, Number.NEGATIVE_INFINITY), {\n        min: a(t, i),\n        max: a(e, s),\n        minDefined: o(t),\n        maxDefined: o(e)\n      };\n    }\n    getMinMax(t) {\n      let e,\n        {\n          min: i,\n          max: s,\n          minDefined: n,\n          maxDefined: o\n        } = this.getUserBounds();\n      if (n && o) return {\n        min: i,\n        max: s\n      };\n      const r = this.getMatchingVisibleMetas();\n      for (let a = 0, l = r.length; a < l; ++a) e = r[a].controller.getMinMax(this, t), n || (i = Math.min(i, e.min)), o || (s = Math.max(s, e.max));\n      return i = o && i > s ? s : i, s = n && i > s ? i : s, {\n        min: a(i, a(s, i)),\n        max: a(s, a(i, s))\n      };\n    }\n    getPadding() {\n      return {\n        left: this.paddingLeft || 0,\n        top: this.paddingTop || 0,\n        right: this.paddingRight || 0,\n        bottom: this.paddingBottom || 0\n      };\n    }\n    getTicks() {\n      return this.ticks;\n    }\n    getLabels() {\n      const t = this.chart.data;\n      return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];\n    }\n    beforeLayout() {\n      this._cache = {}, this._dataLimitsCached = !1;\n    }\n    beforeUpdate() {\n      c(this.options.beforeUpdate, [this]);\n    }\n    update(t, e, i) {\n      const {\n          beginAtZero: s,\n          grace: n,\n          ticks: o\n        } = this.options,\n        a = o.sampleSize;\n      this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = xi(this, n, s), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();\n      const r = a < this.ticks.length;\n      this._convertTicksToLabels(r ? Bs(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || \"auto\" === o.source) && (this.ticks = zs(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), r && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();\n    }\n    configure() {\n      let t,\n        e,\n        i = this.options.reverse;\n      this.isHorizontal() ? (t = this.left, e = this.right) : (t = this.top, e = this.bottom, i = !i), this._startPixel = t, this._endPixel = e, this._reversePixels = i, this._length = e - t, this._alignToPixels = this.options.alignToPixels;\n    }\n    afterUpdate() {\n      c(this.options.afterUpdate, [this]);\n    }\n    beforeSetDimensions() {\n      c(this.options.beforeSetDimensions, [this]);\n    }\n    setDimensions() {\n      this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;\n    }\n    afterSetDimensions() {\n      c(this.options.afterSetDimensions, [this]);\n    }\n    _callHooks(t) {\n      this.chart.notifyPlugins(t, this.getContext()), c(this.options[t], [this]);\n    }\n    beforeDataLimits() {\n      this._callHooks(\"beforeDataLimits\");\n    }\n    determineDataLimits() {}\n    afterDataLimits() {\n      this._callHooks(\"afterDataLimits\");\n    }\n    beforeBuildTicks() {\n      this._callHooks(\"beforeBuildTicks\");\n    }\n    buildTicks() {\n      return [];\n    }\n    afterBuildTicks() {\n      this._callHooks(\"afterBuildTicks\");\n    }\n    beforeTickToLabelConversion() {\n      c(this.options.beforeTickToLabelConversion, [this]);\n    }\n    generateTickLabels(t) {\n      const e = this.options.ticks;\n      let i, s, n;\n      for (i = 0, s = t.length; i < s; i++) n = t[i], n.label = c(e.callback, [n.value, i, t], this);\n    }\n    afterTickToLabelConversion() {\n      c(this.options.afterTickToLabelConversion, [this]);\n    }\n    beforeCalculateLabelRotation() {\n      c(this.options.beforeCalculateLabelRotation, [this]);\n    }\n    calculateLabelRotation() {\n      const t = this.options,\n        e = t.ticks,\n        i = this.ticks.length,\n        s = e.minRotation || 0,\n        n = e.maxRotation;\n      let o,\n        a,\n        r,\n        l = s;\n      if (!this._isVisible() || !e.display || s >= n || i <= 1 || !this.isHorizontal()) return void (this.labelRotation = s);\n      const h = this._getLabelSizes(),\n        c = h.widest.width,\n        d = h.highest.height,\n        u = Z(this.chart.width - c, 0, this.maxWidth);\n      o = t.offset ? this.maxWidth / i : u / (i - 1), c + 6 > o && (o = u / (i - (t.offset ? .5 : 1)), a = this.maxHeight - Ws(t.grid) - e.padding - js(t.title, this.chart.options.font), r = Math.sqrt(c * c + d * d), l = $(Math.min(Math.asin(Z((h.highest.height + 6) / o, -1, 1)), Math.asin(Z(a / r, -1, 1)) - Math.asin(Z(d / r, -1, 1)))), l = Math.max(s, Math.min(n, l))), this.labelRotation = l;\n    }\n    afterCalculateLabelRotation() {\n      c(this.options.afterCalculateLabelRotation, [this]);\n    }\n    afterAutoSkip() {}\n    beforeFit() {\n      c(this.options.beforeFit, [this]);\n    }\n    fit() {\n      const t = {\n          width: 0,\n          height: 0\n        },\n        {\n          chart: e,\n          options: {\n            ticks: i,\n            title: s,\n            grid: n\n          }\n        } = this,\n        o = this._isVisible(),\n        a = this.isHorizontal();\n      if (o) {\n        const o = js(s, e.options.font);\n        if (a ? (t.width = this.maxWidth, t.height = Ws(n) + o) : (t.height = this.maxHeight, t.width = Ws(n) + o), i.display && this.ticks.length) {\n          const {\n              first: e,\n              last: s,\n              widest: n,\n              highest: o\n            } = this._getLabelSizes(),\n            r = 2 * i.padding,\n            l = H(this.labelRotation),\n            h = Math.cos(l),\n            c = Math.sin(l);\n          if (a) {\n            const e = i.mirror ? 0 : c * n.width + h * o.height;\n            t.height = Math.min(this.maxHeight, t.height + e + r);\n          } else {\n            const e = i.mirror ? 0 : h * n.width + c * o.height;\n            t.width = Math.min(this.maxWidth, t.width + e + r);\n          }\n          this._calculatePadding(e, s, c, h);\n        }\n      }\n      this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);\n    }\n    _calculatePadding(t, e, i, s) {\n      const {\n          ticks: {\n            align: n,\n            padding: o\n          },\n          position: a\n        } = this.options,\n        r = 0 !== this.labelRotation,\n        l = \"top\" !== a && \"x\" === this.axis;\n      if (this.isHorizontal()) {\n        const a = this.getPixelForTick(0) - this.left,\n          h = this.right - this.getPixelForTick(this.ticks.length - 1);\n        let c = 0,\n          d = 0;\n        r ? l ? (c = s * t.width, d = i * e.height) : (c = i * t.height, d = s * e.width) : \"start\" === n ? d = e.width : \"end\" === n ? c = t.width : \"inner\" !== n && (c = t.width / 2, d = e.width / 2), this.paddingLeft = Math.max((c - a + o) * this.width / (this.width - a), 0), this.paddingRight = Math.max((d - h + o) * this.width / (this.width - h), 0);\n      } else {\n        let i = e.height / 2,\n          s = t.height / 2;\n        \"start\" === n ? (i = 0, s = t.height) : \"end\" === n && (i = e.height, s = 0), this.paddingTop = i + o, this.paddingBottom = s + o;\n      }\n    }\n    _handleMargins() {\n      this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));\n    }\n    afterFit() {\n      c(this.options.afterFit, [this]);\n    }\n    isHorizontal() {\n      const {\n        axis: t,\n        position: e\n      } = this.options;\n      return \"top\" === e || \"bottom\" === e || \"x\" === t;\n    }\n    isFullSize() {\n      return this.options.fullSize;\n    }\n    _convertTicksToLabels(t) {\n      let e, s;\n      for (this.beforeTickToLabelConversion(), this.generateTickLabels(t), e = 0, s = t.length; e < s; e++) i(t[e].label) && (t.splice(e, 1), s--, e--);\n      this.afterTickToLabelConversion();\n    }\n    _getLabelSizes() {\n      let t = this._labelSizes;\n      if (!t) {\n        const e = this.options.ticks.sampleSize;\n        let i = this.ticks;\n        e < i.length && (i = Bs(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length);\n      }\n      return t;\n    }\n    _computeLabelSizes(t, e) {\n      const {\n          ctx: n,\n          _longestTextCache: o\n        } = this,\n        a = [],\n        r = [];\n      let l,\n        h,\n        c,\n        u,\n        f,\n        g,\n        p,\n        m,\n        b,\n        x,\n        _,\n        y = 0,\n        v = 0;\n      for (l = 0; l < e; ++l) {\n        if (u = t[l].label, f = this._resolveTickFontOptions(l), n.font = g = f.string, p = o[g] = o[g] || {\n          data: {},\n          gc: []\n        }, m = f.lineHeight, b = x = 0, i(u) || s(u)) {\n          if (s(u)) for (h = 0, c = u.length; h < c; ++h) _ = u[h], i(_) || s(_) || (b = _e(n, p.data, p.gc, b, _), x += m);\n        } else b = _e(n, p.data, p.gc, b, u), x = m;\n        a.push(b), r.push(x), y = Math.max(b, y), v = Math.max(x, v);\n      }\n      !function (t, e) {\n        d(t, t => {\n          const i = t.gc,\n            s = i.length / 2;\n          let n;\n          if (s > e) {\n            for (n = 0; n < s; ++n) delete t.data[i[n]];\n            i.splice(0, s);\n          }\n        });\n      }(o, e);\n      const w = a.indexOf(y),\n        M = r.indexOf(v),\n        k = t => ({\n          width: a[t] || 0,\n          height: r[t] || 0\n        });\n      return {\n        first: k(0),\n        last: k(e - 1),\n        widest: k(w),\n        highest: k(M),\n        widths: a,\n        heights: r\n      };\n    }\n    getLabelForValue(t) {\n      return t;\n    }\n    getPixelForValue(t, e) {\n      return NaN;\n    }\n    getValueForPixel(t) {}\n    getPixelForTick(t) {\n      const e = this.ticks;\n      return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n    }\n    getPixelForDecimal(t) {\n      this._reversePixels && (t = 1 - t);\n      const e = this._startPixel + t * this._length;\n      return J(this._alignToPixels ? ve(this.chart, e, 0) : e);\n    }\n    getDecimalForPixel(t) {\n      const e = (t - this._startPixel) / this._length;\n      return this._reversePixels ? 1 - e : e;\n    }\n    getBasePixel() {\n      return this.getPixelForValue(this.getBaseValue());\n    }\n    getBaseValue() {\n      const {\n        min: t,\n        max: e\n      } = this;\n      return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;\n    }\n    getContext(t) {\n      const e = this.ticks || [];\n      if (t >= 0 && t < e.length) {\n        const i = e[t];\n        return i.$context || (i.$context = function (t, e, i) {\n          return _i(t, {\n            tick: i,\n            index: e,\n            type: \"tick\"\n          });\n        }(this.getContext(), t, i));\n      }\n      return this.$context || (this.$context = _i(this.chart.getContext(), {\n        scale: this,\n        type: \"scale\"\n      }));\n    }\n    _tickSize() {\n      const t = this.options.ticks,\n        e = H(this.labelRotation),\n        i = Math.abs(Math.cos(e)),\n        s = Math.abs(Math.sin(e)),\n        n = this._getLabelSizes(),\n        o = t.autoSkipPadding || 0,\n        a = n ? n.widest.width + o : 0,\n        r = n ? n.highest.height + o : 0;\n      return this.isHorizontal() ? r * i > a * s ? a / i : r / s : r * s < a * i ? r / i : a / s;\n    }\n    _isVisible() {\n      const t = this.options.display;\n      return \"auto\" !== t ? !!t : this.getMatchingVisibleMetas().length > 0;\n    }\n    _computeGridLineItems(t) {\n      const e = this.axis,\n        i = this.chart,\n        s = this.options,\n        {\n          grid: o,\n          position: a\n        } = s,\n        l = o.offset,\n        h = this.isHorizontal(),\n        c = this.ticks.length + (l ? 1 : 0),\n        d = Ws(o),\n        u = [],\n        f = o.setContext(this.getContext()),\n        g = f.drawBorder ? f.borderWidth : 0,\n        p = g / 2,\n        m = function m(t) {\n          return ve(i, t, g);\n        };\n      let b, x, _, y, v, w, M, k, S, P, D, O;\n      if (\"top\" === a) b = m(this.bottom), w = this.bottom - d, k = b - p, P = m(t.top) + p, O = t.bottom;else if (\"bottom\" === a) b = m(this.top), P = t.top, O = m(t.bottom) - p, w = b + p, k = this.top + d;else if (\"left\" === a) b = m(this.right), v = this.right - d, M = b - p, S = m(t.left) + p, D = t.right;else if (\"right\" === a) b = m(this.left), S = t.left, D = m(t.right) - p, v = b + p, M = this.left + d;else if (\"x\" === e) {\n        if (\"center\" === a) b = m((t.top + t.bottom) / 2 + .5);else if (n(a)) {\n          const t = Object.keys(a)[0],\n            e = a[t];\n          b = m(this.chart.scales[t].getPixelForValue(e));\n        }\n        P = t.top, O = t.bottom, w = b + p, k = w + d;\n      } else if (\"y\" === e) {\n        if (\"center\" === a) b = m((t.left + t.right) / 2);else if (n(a)) {\n          const t = Object.keys(a)[0],\n            e = a[t];\n          b = m(this.chart.scales[t].getPixelForValue(e));\n        }\n        v = b - p, M = v - d, S = t.left, D = t.right;\n      }\n      const C = r(s.ticks.maxTicksLimit, c),\n        A = Math.max(1, Math.ceil(c / C));\n      for (x = 0; x < c; x += A) {\n        const t = o.setContext(this.getContext(x)),\n          e = t.lineWidth,\n          s = t.color,\n          n = t.borderDash || [],\n          a = t.borderDashOffset,\n          r = t.tickWidth,\n          c = t.tickColor,\n          d = t.tickBorderDash || [],\n          f = t.tickBorderDashOffset;\n        _ = Ns(this, x, l), void 0 !== _ && (y = ve(i, _, e), h ? v = M = S = D = y : w = k = P = O = y, u.push({\n          tx1: v,\n          ty1: w,\n          tx2: M,\n          ty2: k,\n          x1: S,\n          y1: P,\n          x2: D,\n          y2: O,\n          width: e,\n          color: s,\n          borderDash: n,\n          borderDashOffset: a,\n          tickWidth: r,\n          tickColor: c,\n          tickBorderDash: d,\n          tickBorderDashOffset: f\n        }));\n      }\n      return this._ticksLength = c, this._borderValue = b, u;\n    }\n    _computeLabelItems(t) {\n      const e = this.axis,\n        i = this.options,\n        {\n          position: o,\n          ticks: a\n        } = i,\n        r = this.isHorizontal(),\n        l = this.ticks,\n        {\n          align: h,\n          crossAlign: c,\n          padding: d,\n          mirror: u\n        } = a,\n        f = Ws(i.grid),\n        g = f + d,\n        p = u ? -d : g,\n        m = -H(this.labelRotation),\n        b = [];\n      let x,\n        _,\n        y,\n        v,\n        w,\n        M,\n        k,\n        S,\n        P,\n        D,\n        O,\n        C,\n        A = \"middle\";\n      if (\"top\" === o) M = this.bottom - p, k = this._getXAxisLabelAlignment();else if (\"bottom\" === o) M = this.top + p, k = this._getXAxisLabelAlignment();else if (\"left\" === o) {\n        const t = this._getYAxisLabelAlignment(f);\n        k = t.textAlign, w = t.x;\n      } else if (\"right\" === o) {\n        const t = this._getYAxisLabelAlignment(f);\n        k = t.textAlign, w = t.x;\n      } else if (\"x\" === e) {\n        if (\"center\" === o) M = (t.top + t.bottom) / 2 + g;else if (n(o)) {\n          const t = Object.keys(o)[0],\n            e = o[t];\n          M = this.chart.scales[t].getPixelForValue(e) + g;\n        }\n        k = this._getXAxisLabelAlignment();\n      } else if (\"y\" === e) {\n        if (\"center\" === o) w = (t.left + t.right) / 2 - g;else if (n(o)) {\n          const t = Object.keys(o)[0],\n            e = o[t];\n          w = this.chart.scales[t].getPixelForValue(e);\n        }\n        k = this._getYAxisLabelAlignment(f).textAlign;\n      }\n      \"y\" === e && (\"start\" === h ? A = \"top\" : \"end\" === h && (A = \"bottom\"));\n      const T = this._getLabelSizes();\n      for (x = 0, _ = l.length; x < _; ++x) {\n        y = l[x], v = y.label;\n        const t = a.setContext(this.getContext(x));\n        S = this.getPixelForTick(x) + a.labelOffset, P = this._resolveTickFontOptions(x), D = P.lineHeight, O = s(v) ? v.length : 1;\n        const e = O / 2,\n          i = t.color,\n          n = t.textStrokeColor,\n          h = t.textStrokeWidth;\n        let d,\n          f = k;\n        if (r ? (w = S, \"inner\" === k && (f = x === _ - 1 ? this.options.reverse ? \"left\" : \"right\" : 0 === x ? this.options.reverse ? \"right\" : \"left\" : \"center\"), C = \"top\" === o ? \"near\" === c || 0 !== m ? -O * D + D / 2 : \"center\" === c ? -T.highest.height / 2 - e * D + D : -T.highest.height + D / 2 : \"near\" === c || 0 !== m ? D / 2 : \"center\" === c ? T.highest.height / 2 - e * D : T.highest.height - O * D, u && (C *= -1)) : (M = S, C = (1 - O) * D / 2), t.showLabelBackdrop) {\n          const e = pi(t.backdropPadding),\n            i = T.heights[x],\n            s = T.widths[x];\n          let n = M + C - e.top,\n            o = w - e.left;\n          switch (A) {\n            case \"middle\":\n              n -= i / 2;\n              break;\n            case \"bottom\":\n              n -= i;\n          }\n          switch (k) {\n            case \"center\":\n              o -= s / 2;\n              break;\n            case \"right\":\n              o -= s;\n          }\n          d = {\n            left: o,\n            top: n,\n            width: s + e.width,\n            height: i + e.height,\n            color: t.backdropColor\n          };\n        }\n        b.push({\n          rotation: m,\n          label: v,\n          font: P,\n          color: i,\n          strokeColor: n,\n          strokeWidth: h,\n          textOffset: C,\n          textAlign: f,\n          textBaseline: A,\n          translation: [w, M],\n          backdrop: d\n        });\n      }\n      return b;\n    }\n    _getXAxisLabelAlignment() {\n      const {\n        position: t,\n        ticks: e\n      } = this.options;\n      if (-H(this.labelRotation)) return \"top\" === t ? \"left\" : \"right\";\n      let i = \"center\";\n      return \"start\" === e.align ? i = \"left\" : \"end\" === e.align ? i = \"right\" : \"inner\" === e.align && (i = \"inner\"), i;\n    }\n    _getYAxisLabelAlignment(t) {\n      const {\n          position: e,\n          ticks: {\n            crossAlign: i,\n            mirror: s,\n            padding: n\n          }\n        } = this.options,\n        o = t + n,\n        a = this._getLabelSizes().widest.width;\n      let r, l;\n      return \"left\" === e ? s ? (l = this.right + n, \"near\" === i ? r = \"left\" : \"center\" === i ? (r = \"center\", l += a / 2) : (r = \"right\", l += a)) : (l = this.right - o, \"near\" === i ? r = \"right\" : \"center\" === i ? (r = \"center\", l -= a / 2) : (r = \"left\", l = this.left)) : \"right\" === e ? s ? (l = this.left + n, \"near\" === i ? r = \"right\" : \"center\" === i ? (r = \"center\", l -= a / 2) : (r = \"left\", l -= a)) : (l = this.left + o, \"near\" === i ? r = \"left\" : \"center\" === i ? (r = \"center\", l += a / 2) : (r = \"right\", l = this.right)) : r = \"right\", {\n        textAlign: r,\n        x: l\n      };\n    }\n    _computeLabelArea() {\n      if (this.options.ticks.mirror) return;\n      const t = this.chart,\n        e = this.options.position;\n      return \"left\" === e || \"right\" === e ? {\n        top: 0,\n        left: this.left,\n        bottom: t.height,\n        right: this.right\n      } : \"top\" === e || \"bottom\" === e ? {\n        top: this.top,\n        left: 0,\n        bottom: this.bottom,\n        right: t.width\n      } : void 0;\n    }\n    drawBackground() {\n      const {\n        ctx: t,\n        options: {\n          backgroundColor: e\n        },\n        left: i,\n        top: s,\n        width: n,\n        height: o\n      } = this;\n      e && (t.save(), t.fillStyle = e, t.fillRect(i, s, n, o), t.restore());\n    }\n    getLineWidthForValue(t) {\n      const e = this.options.grid;\n      if (!this._isVisible() || !e.display) return 0;\n      const i = this.ticks.findIndex(e => e.value === t);\n      if (i >= 0) {\n        return e.setContext(this.getContext(i)).lineWidth;\n      }\n      return 0;\n    }\n    drawGrid(t) {\n      const e = this.options.grid,\n        i = this.ctx,\n        s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));\n      let n, o;\n      const a = (t, e, s) => {\n        s.width && s.color && (i.save(), i.lineWidth = s.width, i.strokeStyle = s.color, i.setLineDash(s.borderDash || []), i.lineDashOffset = s.borderDashOffset, i.beginPath(), i.moveTo(t.x, t.y), i.lineTo(e.x, e.y), i.stroke(), i.restore());\n      };\n      if (e.display) for (n = 0, o = s.length; n < o; ++n) {\n        const t = s[n];\n        e.drawOnChartArea && a({\n          x: t.x1,\n          y: t.y1\n        }, {\n          x: t.x2,\n          y: t.y2\n        }, t), e.drawTicks && a({\n          x: t.tx1,\n          y: t.ty1\n        }, {\n          x: t.tx2,\n          y: t.ty2\n        }, {\n          color: t.tickColor,\n          width: t.tickWidth,\n          borderDash: t.tickBorderDash,\n          borderDashOffset: t.tickBorderDashOffset\n        });\n      }\n    }\n    drawBorder() {\n      const {\n          chart: t,\n          ctx: e,\n          options: {\n            grid: i\n          }\n        } = this,\n        s = i.setContext(this.getContext()),\n        n = i.drawBorder ? s.borderWidth : 0;\n      if (!n) return;\n      const o = i.setContext(this.getContext(0)).lineWidth,\n        a = this._borderValue;\n      let r, l, h, c;\n      this.isHorizontal() ? (r = ve(t, this.left, n) - n / 2, l = ve(t, this.right, o) + o / 2, h = c = a) : (h = ve(t, this.top, n) - n / 2, c = ve(t, this.bottom, o) + o / 2, r = l = a), e.save(), e.lineWidth = s.borderWidth, e.strokeStyle = s.borderColor, e.beginPath(), e.moveTo(r, h), e.lineTo(l, c), e.stroke(), e.restore();\n    }\n    drawLabels(t) {\n      if (!this.options.ticks.display) return;\n      const e = this.ctx,\n        i = this._computeLabelArea();\n      i && Pe(e, i);\n      const s = this._labelItems || (this._labelItems = this._computeLabelItems(t));\n      let n, o;\n      for (n = 0, o = s.length; n < o; ++n) {\n        const t = s[n],\n          i = t.font,\n          o = t.label;\n        t.backdrop && (e.fillStyle = t.backdrop.color, e.fillRect(t.backdrop.left, t.backdrop.top, t.backdrop.width, t.backdrop.height)), Ae(e, o, 0, t.textOffset, i, t);\n      }\n      i && De(e);\n    }\n    drawTitle() {\n      const {\n        ctx: t,\n        options: {\n          position: e,\n          title: i,\n          reverse: o\n        }\n      } = this;\n      if (!i.display) return;\n      const a = mi(i.font),\n        r = pi(i.padding),\n        l = i.align;\n      let h = a.lineHeight / 2;\n      \"bottom\" === e || \"center\" === e || n(e) ? (h += r.bottom, s(i.text) && (h += a.lineHeight * (i.text.length - 1))) : h += r.top;\n      const {\n        titleX: c,\n        titleY: d,\n        maxWidth: u,\n        rotation: f\n      } = function (t, e, i, s) {\n        const {\n            top: o,\n            left: a,\n            bottom: r,\n            right: l,\n            chart: h\n          } = t,\n          {\n            chartArea: c,\n            scales: d\n          } = h;\n        let u,\n          f,\n          g,\n          p = 0;\n        const m = r - o,\n          b = l - a;\n        if (t.isHorizontal()) {\n          if (f = ut(s, a, l), n(i)) {\n            const t = Object.keys(i)[0],\n              s = i[t];\n            g = d[t].getPixelForValue(s) + m - e;\n          } else g = \"center\" === i ? (c.bottom + c.top) / 2 + m - e : Vs(t, i, e);\n          u = l - a;\n        } else {\n          if (n(i)) {\n            const t = Object.keys(i)[0],\n              s = i[t];\n            f = d[t].getPixelForValue(s) - b + e;\n          } else f = \"center\" === i ? (c.left + c.right) / 2 - b + e : Vs(t, i, e);\n          g = ut(s, r, o), p = \"left\" === i ? -L : L;\n        }\n        return {\n          titleX: f,\n          titleY: g,\n          maxWidth: u,\n          rotation: p\n        };\n      }(this, h, e, l);\n      Ae(t, i.text, 0, 0, a, {\n        color: i.color,\n        maxWidth: u,\n        rotation: f,\n        textAlign: Hs(l, e, o),\n        textBaseline: \"middle\",\n        translation: [c, d]\n      });\n    }\n    draw(t) {\n      this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));\n    }\n    _layers() {\n      const t = this.options,\n        e = t.ticks && t.ticks.z || 0,\n        i = r(t.grid && t.grid.z, -1);\n      return this._isVisible() && this.draw === $s.prototype.draw ? [{\n        z: i,\n        draw: t => {\n          this.drawBackground(), this.drawGrid(t), this.drawTitle();\n        }\n      }, {\n        z: i + 1,\n        draw: () => {\n          this.drawBorder();\n        }\n      }, {\n        z: e,\n        draw: t => {\n          this.drawLabels(t);\n        }\n      }] : [{\n        z: e,\n        draw: t => {\n          this.draw(t);\n        }\n      }];\n    }\n    getMatchingVisibleMetas(t) {\n      const e = this.chart.getSortedVisibleDatasetMetas(),\n        i = this.axis + \"AxisID\",\n        s = [];\n      let n, o;\n      for (n = 0, o = e.length; n < o; ++n) {\n        const o = e[n];\n        o[i] !== this.id || t && o.type !== t || s.push(o);\n      }\n      return s;\n    }\n    _resolveTickFontOptions(t) {\n      return mi(this.options.ticks.setContext(this.getContext(t)).font);\n    }\n    _maxDigits() {\n      const t = this._resolveTickFontOptions(0).lineHeight;\n      return (this.isHorizontal() ? this.width : this.height) / t;\n    }\n  }\n  class Ys {\n    constructor(t, e, i) {\n      this.type = t, this.scope = e, this.override = i, this.items = Object.create(null);\n    }\n    isForType(t) {\n      return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);\n    }\n    register(t) {\n      const e = Object.getPrototypeOf(t);\n      let i;\n      (function (t) {\n        return \"id\" in t && \"defaults\" in t;\n      })(e) && (i = this.register(e));\n      const s = this.items,\n        n = t.id,\n        o = this.scope + \".\" + n;\n      if (!n) throw new Error(\"class does not have id: \" + t);\n      return n in s || (s[n] = t, function (t, e, i) {\n        const s = m(Object.create(null), [i ? ne.get(i) : {}, ne.get(e), t.defaults]);\n        ne.set(e, s), t.defaultRoutes && function (t, e) {\n          Object.keys(e).forEach(i => {\n            const s = i.split(\".\"),\n              n = s.pop(),\n              o = [t].concat(s).join(\".\"),\n              a = e[i].split(\".\"),\n              r = a.pop(),\n              l = a.join(\".\");\n            ne.route(o, n, l, r);\n          });\n        }(e, t.defaultRoutes);\n        t.descriptors && ne.describe(e, t.descriptors);\n      }(t, o, i), this.override && ne.override(t.id, t.overrides)), o;\n    }\n    get(t) {\n      return this.items[t];\n    }\n    unregister(t) {\n      const e = this.items,\n        i = t.id,\n        s = this.scope;\n      i in e && delete e[i], s && i in ne[s] && (delete ne[s][i], this.override && delete te[i]);\n    }\n  }\n  var Us = new class {\n    constructor() {\n      this.controllers = new Ys(Ls, \"datasets\", !0), this.elements = new Ys(Es, \"elements\"), this.plugins = new Ys(Object, \"plugins\"), this.scales = new Ys($s, \"scales\"), this._typedRegistries = [this.controllers, this.scales, this.elements];\n    }\n    add() {\n      for (var _len4 = arguments.length, t = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        t[_key4] = arguments[_key4];\n      }\n      this._each(\"register\", t);\n    }\n    remove() {\n      for (var _len5 = arguments.length, t = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        t[_key5] = arguments[_key5];\n      }\n      this._each(\"unregister\", t);\n    }\n    addControllers() {\n      for (var _len6 = arguments.length, t = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        t[_key6] = arguments[_key6];\n      }\n      this._each(\"register\", t, this.controllers);\n    }\n    addElements() {\n      for (var _len7 = arguments.length, t = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        t[_key7] = arguments[_key7];\n      }\n      this._each(\"register\", t, this.elements);\n    }\n    addPlugins() {\n      for (var _len8 = arguments.length, t = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        t[_key8] = arguments[_key8];\n      }\n      this._each(\"register\", t, this.plugins);\n    }\n    addScales() {\n      for (var _len9 = arguments.length, t = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        t[_key9] = arguments[_key9];\n      }\n      this._each(\"register\", t, this.scales);\n    }\n    getController(t) {\n      return this._get(t, this.controllers, \"controller\");\n    }\n    getElement(t) {\n      return this._get(t, this.elements, \"element\");\n    }\n    getPlugin(t) {\n      return this._get(t, this.plugins, \"plugin\");\n    }\n    getScale(t) {\n      return this._get(t, this.scales, \"scale\");\n    }\n    removeControllers() {\n      for (var _len10 = arguments.length, t = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        t[_key10] = arguments[_key10];\n      }\n      this._each(\"unregister\", t, this.controllers);\n    }\n    removeElements() {\n      for (var _len11 = arguments.length, t = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        t[_key11] = arguments[_key11];\n      }\n      this._each(\"unregister\", t, this.elements);\n    }\n    removePlugins() {\n      for (var _len12 = arguments.length, t = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        t[_key12] = arguments[_key12];\n      }\n      this._each(\"unregister\", t, this.plugins);\n    }\n    removeScales() {\n      for (var _len13 = arguments.length, t = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        t[_key13] = arguments[_key13];\n      }\n      this._each(\"unregister\", t, this.scales);\n    }\n    _each(t, e, i) {\n      [...e].forEach(e => {\n        const s = i || this._getRegistryForType(e);\n        i || s.isForType(e) || s === this.plugins && e.id ? this._exec(t, s, e) : d(e, e => {\n          const s = i || this._getRegistryForType(e);\n          this._exec(t, s, e);\n        });\n      });\n    }\n    _exec(t, e, i) {\n      const s = w(t);\n      c(i[\"before\" + s], [], i), e[t](i), c(i[\"after\" + s], [], i);\n    }\n    _getRegistryForType(t) {\n      for (let e = 0; e < this._typedRegistries.length; e++) {\n        const i = this._typedRegistries[e];\n        if (i.isForType(t)) return i;\n      }\n      return this.plugins;\n    }\n    _get(t, e, i) {\n      const s = e.get(t);\n      if (void 0 === s) throw new Error('\"' + t + '\" is not a registered ' + i + \".\");\n      return s;\n    }\n  }();\n  class Xs {\n    constructor() {\n      this._init = [];\n    }\n    notify(t, e, i, s) {\n      \"beforeInit\" === e && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, \"install\"));\n      const n = s ? this._descriptors(t).filter(s) : this._descriptors(t),\n        o = this._notify(n, t, e, i);\n      return \"afterDestroy\" === e && (this._notify(n, t, \"stop\"), this._notify(this._init, t, \"uninstall\")), o;\n    }\n    _notify(t, e, i, s) {\n      s = s || {};\n      for (const n of t) {\n        const t = n.plugin;\n        if (!1 === c(t[i], [e, s, n.options], t) && s.cancelable) return !1;\n      }\n      return !0;\n    }\n    invalidate() {\n      i(this._cache) || (this._oldCache = this._cache, this._cache = void 0);\n    }\n    _descriptors(t) {\n      if (this._cache) return this._cache;\n      const e = this._cache = this._createDescriptors(t);\n      return this._notifyStateChanges(t), e;\n    }\n    _createDescriptors(t, e) {\n      const i = t && t.config,\n        s = r(i.options && i.options.plugins, {}),\n        n = function (t) {\n          const e = {},\n            i = [],\n            s = Object.keys(Us.plugins.items);\n          for (let t = 0; t < s.length; t++) i.push(Us.getPlugin(s[t]));\n          const n = t.plugins || [];\n          for (let t = 0; t < n.length; t++) {\n            const s = n[t];\n            -1 === i.indexOf(s) && (i.push(s), e[s.id] = !0);\n          }\n          return {\n            plugins: i,\n            localIds: e\n          };\n        }(i);\n      return !1 !== s || e ? function (t, _ref2, s, n) {\n        let {\n          plugins: e,\n          localIds: i\n        } = _ref2;\n        const o = [],\n          a = t.getContext();\n        for (const r of e) {\n          const e = r.id,\n            l = qs(s[e], n);\n          null !== l && o.push({\n            plugin: r,\n            options: Ks(t.config, {\n              plugin: r,\n              local: i[e]\n            }, l, a)\n          });\n        }\n        return o;\n      }(t, n, s, e) : [];\n    }\n    _notifyStateChanges(t) {\n      const e = this._oldCache || [],\n        i = this._cache,\n        s = (t, e) => t.filter(t => !e.some(e => t.plugin.id === e.plugin.id));\n      this._notify(s(e, i), t, \"stop\"), this._notify(s(i, e), t, \"start\");\n    }\n  }\n  function qs(t, e) {\n    return e || !1 !== t ? !0 === t ? {} : t : null;\n  }\n  function Ks(t, _ref3, s, n) {\n    let {\n      plugin: e,\n      local: i\n    } = _ref3;\n    const o = t.pluginScopeKeys(e),\n      a = t.getOptionScopes(s, o);\n    return i && e.defaults && a.push(e.defaults), t.createResolver(a, n, [\"\"], {\n      scriptable: !1,\n      indexable: !1,\n      allKeys: !0\n    });\n  }\n  function Gs(t, e) {\n    const i = ne.datasets[t] || {};\n    return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || \"x\";\n  }\n  function Zs(t, e) {\n    return \"x\" === t || \"y\" === t ? t : e.axis || (\"top\" === (i = e.position) || \"bottom\" === i ? \"x\" : \"left\" === i || \"right\" === i ? \"y\" : void 0) || t.charAt(0).toLowerCase();\n    var i;\n  }\n  function Js(t) {\n    const e = t.options || (t.options = {});\n    e.plugins = r(e.plugins, {}), e.scales = function (t, e) {\n      const i = te[t.type] || {\n          scales: {}\n        },\n        s = e.scales || {},\n        o = Gs(t.type, e),\n        a = Object.create(null),\n        r = Object.create(null);\n      return Object.keys(s).forEach(t => {\n        const e = s[t];\n        if (!n(e)) return console.error(\"Invalid scale configuration for scale: \".concat(t));\n        if (e._proxy) return console.warn(\"Ignoring resolver passed as options for scale: \".concat(t));\n        const l = Zs(t, e),\n          h = function (t, e) {\n            return t === e ? \"_index_\" : \"_value_\";\n          }(l, o),\n          c = i.scales || {};\n        a[l] = a[l] || t, r[t] = b(Object.create(null), [{\n          axis: l\n        }, e, c[l], c[h]]);\n      }), t.data.datasets.forEach(i => {\n        const n = i.type || t.type,\n          o = i.indexAxis || Gs(n, e),\n          l = (te[n] || {}).scales || {};\n        Object.keys(l).forEach(t => {\n          const e = function (t, e) {\n              let i = t;\n              return \"_index_\" === t ? i = e : \"_value_\" === t && (i = \"x\" === e ? \"y\" : \"x\"), i;\n            }(t, o),\n            n = i[e + \"AxisID\"] || a[e] || e;\n          r[n] = r[n] || Object.create(null), b(r[n], [{\n            axis: e\n          }, s[n], l[t]]);\n        });\n      }), Object.keys(r).forEach(t => {\n        const e = r[t];\n        b(e, [ne.scales[e.type], ne.scale]);\n      }), r;\n    }(t, e);\n  }\n  function Qs(t) {\n    return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t;\n  }\n  const tn = new Map(),\n    en = new Set();\n  function sn(t, e) {\n    let i = tn.get(t);\n    return i || (i = e(), tn.set(t, i), en.add(i)), i;\n  }\n  const nn = (t, e, i) => {\n    const s = y(e, i);\n    void 0 !== s && t.add(s);\n  };\n  class on {\n    constructor(t) {\n      this._config = function (t) {\n        return (t = t || {}).data = Qs(t.data), Js(t), t;\n      }(t), this._scopeCache = new Map(), this._resolverCache = new Map();\n    }\n    get platform() {\n      return this._config.platform;\n    }\n    get type() {\n      return this._config.type;\n    }\n    set type(t) {\n      this._config.type = t;\n    }\n    get data() {\n      return this._config.data;\n    }\n    set data(t) {\n      this._config.data = Qs(t);\n    }\n    get options() {\n      return this._config.options;\n    }\n    set options(t) {\n      this._config.options = t;\n    }\n    get plugins() {\n      return this._config.plugins;\n    }\n    update() {\n      const t = this._config;\n      this.clearCache(), Js(t);\n    }\n    clearCache() {\n      this._scopeCache.clear(), this._resolverCache.clear();\n    }\n    datasetScopeKeys(t) {\n      return sn(t, () => [[\"datasets.\".concat(t), \"\"]]);\n    }\n    datasetAnimationScopeKeys(t, e) {\n      return sn(\"\".concat(t, \".transition.\").concat(e), () => [[\"datasets.\".concat(t, \".transitions.\").concat(e), \"transitions.\".concat(e)], [\"datasets.\".concat(t), \"\"]]);\n    }\n    datasetElementScopeKeys(t, e) {\n      return sn(\"\".concat(t, \"-\").concat(e), () => [[\"datasets.\".concat(t, \".elements.\").concat(e), \"datasets.\".concat(t), \"elements.\".concat(e), \"\"]]);\n    }\n    pluginScopeKeys(t) {\n      const e = t.id;\n      return sn(\"\".concat(this.type, \"-plugin-\").concat(e), () => [[\"plugins.\".concat(e), ...(t.additionalOptionScopes || [])]]);\n    }\n    _cachedScopes(t, e) {\n      const i = this._scopeCache;\n      let s = i.get(t);\n      return s && !e || (s = new Map(), i.set(t, s)), s;\n    }\n    getOptionScopes(t, e, i) {\n      const {\n          options: s,\n          type: n\n        } = this,\n        o = this._cachedScopes(t, i),\n        a = o.get(e);\n      if (a) return a;\n      const r = new Set();\n      e.forEach(e => {\n        t && (r.add(t), e.forEach(e => nn(r, t, e))), e.forEach(t => nn(r, s, t)), e.forEach(t => nn(r, te[n] || {}, t)), e.forEach(t => nn(r, ne, t)), e.forEach(t => nn(r, ee, t));\n      });\n      const l = Array.from(r);\n      return 0 === l.length && l.push(Object.create(null)), en.has(e) && o.set(e, l), l;\n    }\n    chartOptionScopes() {\n      const {\n        options: t,\n        type: e\n      } = this;\n      return [t, te[e] || {}, ne.datasets[e] || {}, {\n        type: e\n      }, ne, ee];\n    }\n    resolveNamedOptions(t, e, i) {\n      let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [\"\"];\n      const o = {\n          $shared: !0\n        },\n        {\n          resolver: a,\n          subPrefixes: r\n        } = an(this._resolverCache, t, n);\n      let l = a;\n      if (function (t, e) {\n        const {\n          isScriptable: i,\n          isIndexable: n\n        } = Ie(t);\n        for (const o of e) {\n          const e = i(o),\n            a = n(o),\n            r = (a || e) && t[o];\n          if (e && (k(r) || rn(r)) || a && s(r)) return !0;\n        }\n        return !1;\n      }(a, e)) {\n        o.$shared = !1;\n        l = Re(a, i = k(i) ? i() : i, this.createResolver(t, i, r));\n      }\n      for (const t of e) o[t] = l[t];\n      return o;\n    }\n    createResolver(t, e) {\n      let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [\"\"];\n      let s = arguments.length > 3 ? arguments[3] : undefined;\n      const {\n        resolver: o\n      } = an(this._resolverCache, t, i);\n      return n(e) ? Re(o, e, void 0, s) : o;\n    }\n  }\n  function an(t, e, i) {\n    let s = t.get(e);\n    s || (s = new Map(), t.set(e, s));\n    const n = i.join();\n    let o = s.get(n);\n    if (!o) {\n      o = {\n        resolver: Ee(e, i),\n        subPrefixes: i.filter(t => !t.toLowerCase().includes(\"hover\"))\n      }, s.set(n, o);\n    }\n    return o;\n  }\n  const rn = t => n(t) && Object.getOwnPropertyNames(t).reduce((e, i) => e || k(t[i]), !1);\n  const ln = [\"top\", \"bottom\", \"left\", \"right\", \"chartArea\"];\n  function hn(t, e) {\n    return \"top\" === t || \"bottom\" === t || -1 === ln.indexOf(t) && \"x\" === e;\n  }\n  function cn(t, e) {\n    return function (i, s) {\n      return i[t] === s[t] ? i[e] - s[e] : i[t] - s[t];\n    };\n  }\n  function dn(t) {\n    const e = t.chart,\n      i = e.options.animation;\n    e.notifyPlugins(\"afterRender\"), c(i && i.onComplete, [t], e);\n  }\n  function un(t) {\n    const e = t.chart,\n      i = e.options.animation;\n    c(i && i.onProgress, [t], e);\n  }\n  function fn(t) {\n    return oe() && \"string\" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t;\n  }\n  const gn = {},\n    pn = t => {\n      const e = fn(t);\n      return Object.values(gn).filter(t => t.canvas === e).pop();\n    };\n  function mn(t, e, i) {\n    const s = Object.keys(t);\n    for (const n of s) {\n      const s = +n;\n      if (s >= e) {\n        const o = t[n];\n        delete t[n], (i > 0 || s > e) && (t[s + i] = o);\n      }\n    }\n  }\n  class bn {\n    constructor(t, i) {\n      const s = this.config = new on(i),\n        n = fn(t),\n        o = pn(n);\n      if (o) throw new Error(\"Canvas is already in use. Chart with ID '\" + o.id + \"' must be destroyed before the canvas with ID '\" + o.canvas.id + \"' can be reused.\");\n      const a = s.createResolver(s.chartOptionScopes(), this.getContext());\n      this.platform = new (s.platform || gs(n))(), this.platform.updateConfig(s);\n      const r = this.platform.acquireContext(n, a.aspectRatio),\n        l = r && r.canvas,\n        h = l && l.height,\n        c = l && l.width;\n      this.id = e(), this.ctx = r, this.canvas = l, this.width = c, this.height = h, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new Xs(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = ct(t => this.update(t), a.resizeDelay || 0), this._dataChanges = [], gn[this.id] = this, r && l ? (mt.listen(this, \"complete\", dn), mt.listen(this, \"progress\", un), this._initialize(), this.attached && this.update()) : console.error(\"Failed to create chart: can't acquire context from the given item\");\n    }\n    get aspectRatio() {\n      const {\n        options: {\n          aspectRatio: t,\n          maintainAspectRatio: e\n        },\n        width: s,\n        height: n,\n        _aspectRatio: o\n      } = this;\n      return i(t) ? e && o ? o : n ? s / n : null : t;\n    }\n    get data() {\n      return this.config.data;\n    }\n    set data(t) {\n      this.config.data = t;\n    }\n    get options() {\n      return this._options;\n    }\n    set options(t) {\n      this.config.options = t;\n    }\n    _initialize() {\n      return this.notifyPlugins(\"beforeInit\"), this.options.responsive ? this.resize() : pe(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins(\"afterInit\"), this;\n    }\n    clear() {\n      return we(this.canvas, this.ctx), this;\n    }\n    stop() {\n      return mt.stop(this), this;\n    }\n    resize(t, e) {\n      mt.running(this) ? this._resizeBeforeDraw = {\n        width: t,\n        height: e\n      } : this._resize(t, e);\n    }\n    _resize(t, e) {\n      const i = this.options,\n        s = this.canvas,\n        n = i.maintainAspectRatio && this.aspectRatio,\n        o = this.platform.getMaximumSize(s, t, e, n),\n        a = i.devicePixelRatio || this.platform.getDevicePixelRatio(),\n        r = this.width ? \"resize\" : \"attach\";\n      this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, pe(this, a, !0) && (this.notifyPlugins(\"resize\", {\n        size: o\n      }), c(i.onResize, [this, o], this), this.attached && this._doResize(r) && this.render());\n    }\n    ensureScalesHaveIDs() {\n      d(this.options.scales || {}, (t, e) => {\n        t.id = e;\n      });\n    }\n    buildOrUpdateScales() {\n      const t = this.options,\n        e = t.scales,\n        i = this.scales,\n        s = Object.keys(i).reduce((t, e) => (t[e] = !1, t), {});\n      let n = [];\n      e && (n = n.concat(Object.keys(e).map(t => {\n        const i = e[t],\n          s = Zs(t, i),\n          n = \"r\" === s,\n          o = \"x\" === s;\n        return {\n          options: i,\n          dposition: n ? \"chartArea\" : o ? \"bottom\" : \"left\",\n          dtype: n ? \"radialLinear\" : o ? \"category\" : \"linear\"\n        };\n      }))), d(n, e => {\n        const n = e.options,\n          o = n.id,\n          a = Zs(o, n),\n          l = r(n.type, e.dtype);\n        void 0 !== n.position && hn(n.position, a) === hn(e.dposition) || (n.position = e.dposition), s[o] = !0;\n        let h = null;\n        if (o in i && i[o].type === l) h = i[o];else {\n          h = new (Us.getScale(l))({\n            id: o,\n            type: l,\n            ctx: this.ctx,\n            chart: this\n          }), i[h.id] = h;\n        }\n        h.init(n, t);\n      }), d(s, (t, e) => {\n        t || delete i[e];\n      }), d(i, t => {\n        Zi.configure(this, t, t.options), Zi.addBox(this, t);\n      });\n    }\n    _updateMetasets() {\n      const t = this._metasets,\n        e = this.data.datasets.length,\n        i = t.length;\n      if (t.sort((t, e) => t.index - e.index), i > e) {\n        for (let t = e; t < i; ++t) this._destroyDatasetMeta(t);\n        t.splice(e, i - e);\n      }\n      this._sortedMetasets = t.slice(0).sort(cn(\"order\", \"index\"));\n    }\n    _removeUnreferencedMetasets() {\n      const {\n        _metasets: t,\n        data: {\n          datasets: e\n        }\n      } = this;\n      t.length > e.length && delete this._stacks, t.forEach((t, i) => {\n        0 === e.filter(e => e === t._dataset).length && this._destroyDatasetMeta(i);\n      });\n    }\n    buildOrUpdateControllers() {\n      const t = [],\n        e = this.data.datasets;\n      let i, s;\n      for (this._removeUnreferencedMetasets(), i = 0, s = e.length; i < s; i++) {\n        const s = e[i];\n        let n = this.getDatasetMeta(i);\n        const o = s.type || this.config.type;\n        if (n.type && n.type !== o && (this._destroyDatasetMeta(i), n = this.getDatasetMeta(i)), n.type = o, n.indexAxis = s.indexAxis || Gs(o, this.options), n.order = s.order || 0, n.index = i, n.label = \"\" + s.label, n.visible = this.isDatasetVisible(i), n.controller) n.controller.updateIndex(i), n.controller.linkScales();else {\n          const e = Us.getController(o),\n            {\n              datasetElementType: s,\n              dataElementType: a\n            } = ne.datasets[o];\n          Object.assign(e.prototype, {\n            dataElementType: Us.getElement(a),\n            datasetElementType: s && Us.getElement(s)\n          }), n.controller = new e(this, i), t.push(n.controller);\n        }\n      }\n      return this._updateMetasets(), t;\n    }\n    _resetElements() {\n      d(this.data.datasets, (t, e) => {\n        this.getDatasetMeta(e).controller.reset();\n      }, this);\n    }\n    reset() {\n      this._resetElements(), this.notifyPlugins(\"reset\");\n    }\n    update(t) {\n      const e = this.config;\n      e.update();\n      const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()),\n        s = this._animationsDisabled = !i.animation;\n      if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins(\"beforeUpdate\", {\n        mode: t,\n        cancelable: !0\n      })) return;\n      const n = this.buildOrUpdateControllers();\n      this.notifyPlugins(\"beforeElementsUpdate\");\n      let o = 0;\n      for (let t = 0, e = this.data.datasets.length; t < e; t++) {\n        const {\n            controller: e\n          } = this.getDatasetMeta(t),\n          i = !s && -1 === n.indexOf(e);\n        e.buildOrUpdateElements(i), o = Math.max(+e.getMaxOverflow(), o);\n      }\n      o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), s || d(n, t => {\n        t.reset();\n      }), this._updateDatasets(t), this.notifyPlugins(\"afterUpdate\", {\n        mode: t\n      }), this._layers.sort(cn(\"z\", \"_idx\"));\n      const {\n        _active: a,\n        _lastEvent: r\n      } = this;\n      r ? this._eventHandler(r, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();\n    }\n    _updateScales() {\n      d(this.scales, t => {\n        Zi.removeBox(this, t);\n      }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();\n    }\n    _checkEventBindings() {\n      const t = this.options,\n        e = new Set(Object.keys(this._listeners)),\n        i = new Set(t.events);\n      S(e, i) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(), this.bindEvents());\n    }\n    _updateHiddenIndices() {\n      const {\n          _hiddenIndices: t\n        } = this,\n        e = this._getUniformDataChanges() || [];\n      for (const {\n        method: i,\n        start: s,\n        count: n\n      } of e) {\n        mn(t, s, \"_removeElements\" === i ? -n : n);\n      }\n    }\n    _getUniformDataChanges() {\n      const t = this._dataChanges;\n      if (!t || !t.length) return;\n      this._dataChanges = [];\n      const e = this.data.datasets.length,\n        i = e => new Set(t.filter(t => t[0] === e).map((t, e) => e + \",\" + t.splice(1).join(\",\"))),\n        s = i(0);\n      for (let t = 1; t < e; t++) if (!S(s, i(t))) return;\n      return Array.from(s).map(t => t.split(\",\")).map(t => ({\n        method: t[1],\n        start: +t[2],\n        count: +t[3]\n      }));\n    }\n    _updateLayout(t) {\n      if (!1 === this.notifyPlugins(\"beforeLayout\", {\n        cancelable: !0\n      })) return;\n      Zi.update(this, this.width, this.height, t);\n      const e = this.chartArea,\n        i = e.width <= 0 || e.height <= 0;\n      this._layers = [], d(this.boxes, t => {\n        i && \"chartArea\" === t.position || (t.configure && t.configure(), this._layers.push(...t._layers()));\n      }, this), this._layers.forEach((t, e) => {\n        t._idx = e;\n      }), this.notifyPlugins(\"afterLayout\");\n    }\n    _updateDatasets(t) {\n      if (!1 !== this.notifyPlugins(\"beforeDatasetsUpdate\", {\n        mode: t,\n        cancelable: !0\n      })) {\n        for (let t = 0, e = this.data.datasets.length; t < e; ++t) this.getDatasetMeta(t).controller.configure();\n        for (let e = 0, i = this.data.datasets.length; e < i; ++e) this._updateDataset(e, k(t) ? t({\n          datasetIndex: e\n        }) : t);\n        this.notifyPlugins(\"afterDatasetsUpdate\", {\n          mode: t\n        });\n      }\n    }\n    _updateDataset(t, e) {\n      const i = this.getDatasetMeta(t),\n        s = {\n          meta: i,\n          index: t,\n          mode: e,\n          cancelable: !0\n        };\n      !1 !== this.notifyPlugins(\"beforeDatasetUpdate\", s) && (i.controller._update(e), s.cancelable = !1, this.notifyPlugins(\"afterDatasetUpdate\", s));\n    }\n    render() {\n      !1 !== this.notifyPlugins(\"beforeRender\", {\n        cancelable: !0\n      }) && (mt.has(this) ? this.attached && !mt.running(this) && mt.start(this) : (this.draw(), dn({\n        chart: this\n      })));\n    }\n    draw() {\n      let t;\n      if (this._resizeBeforeDraw) {\n        const {\n          width: t,\n          height: e\n        } = this._resizeBeforeDraw;\n        this._resize(t, e), this._resizeBeforeDraw = null;\n      }\n      if (this.clear(), this.width <= 0 || this.height <= 0) return;\n      if (!1 === this.notifyPlugins(\"beforeDraw\", {\n        cancelable: !0\n      })) return;\n      const e = this._layers;\n      for (t = 0; t < e.length && e[t].z <= 0; ++t) e[t].draw(this.chartArea);\n      for (this._drawDatasets(); t < e.length; ++t) e[t].draw(this.chartArea);\n      this.notifyPlugins(\"afterDraw\");\n    }\n    _getSortedDatasetMetas(t) {\n      const e = this._sortedMetasets,\n        i = [];\n      let s, n;\n      for (s = 0, n = e.length; s < n; ++s) {\n        const n = e[s];\n        t && !n.visible || i.push(n);\n      }\n      return i;\n    }\n    getSortedVisibleDatasetMetas() {\n      return this._getSortedDatasetMetas(!0);\n    }\n    _drawDatasets() {\n      if (!1 === this.notifyPlugins(\"beforeDatasetsDraw\", {\n        cancelable: !0\n      })) return;\n      const t = this.getSortedVisibleDatasetMetas();\n      for (let e = t.length - 1; e >= 0; --e) this._drawDataset(t[e]);\n      this.notifyPlugins(\"afterDatasetsDraw\");\n    }\n    _drawDataset(t) {\n      const e = this.ctx,\n        i = t._clip,\n        s = !i.disabled,\n        n = this.chartArea,\n        o = {\n          meta: t,\n          index: t.index,\n          cancelable: !0\n        };\n      !1 !== this.notifyPlugins(\"beforeDatasetDraw\", o) && (s && Pe(e, {\n        left: !1 === i.left ? 0 : n.left - i.left,\n        right: !1 === i.right ? this.width : n.right + i.right,\n        top: !1 === i.top ? 0 : n.top - i.top,\n        bottom: !1 === i.bottom ? this.height : n.bottom + i.bottom\n      }), t.controller.draw(), s && De(e), o.cancelable = !1, this.notifyPlugins(\"afterDatasetDraw\", o));\n    }\n    isPointInArea(t) {\n      return Se(t, this.chartArea, this._minPadding);\n    }\n    getElementsAtEventForMode(t, e, i, s) {\n      const n = Vi.modes[e];\n      return \"function\" == typeof n ? n(this, t, i, s) : [];\n    }\n    getDatasetMeta(t) {\n      const e = this.data.datasets[t],\n        i = this._metasets;\n      let s = i.filter(t => t && t._dataset === e).pop();\n      return s || (s = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: e && e.order || 0,\n        index: t,\n        _dataset: e,\n        _parsed: [],\n        _sorted: !1\n      }, i.push(s)), s;\n    }\n    getContext() {\n      return this.$context || (this.$context = _i(null, {\n        chart: this,\n        type: \"chart\"\n      }));\n    }\n    getVisibleDatasetCount() {\n      return this.getSortedVisibleDatasetMetas().length;\n    }\n    isDatasetVisible(t) {\n      const e = this.data.datasets[t];\n      if (!e) return !1;\n      const i = this.getDatasetMeta(t);\n      return \"boolean\" == typeof i.hidden ? !i.hidden : !e.hidden;\n    }\n    setDatasetVisibility(t, e) {\n      this.getDatasetMeta(t).hidden = !e;\n    }\n    toggleDataVisibility(t) {\n      this._hiddenIndices[t] = !this._hiddenIndices[t];\n    }\n    getDataVisibility(t) {\n      return !this._hiddenIndices[t];\n    }\n    _updateVisibility(t, e, i) {\n      const s = i ? \"show\" : \"hide\",\n        n = this.getDatasetMeta(t),\n        o = n.controller._resolveAnimations(void 0, s);\n      M(e) ? (n.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), o.update(n, {\n        visible: i\n      }), this.update(e => e.datasetIndex === t ? s : void 0));\n    }\n    hide(t, e) {\n      this._updateVisibility(t, e, !1);\n    }\n    show(t, e) {\n      this._updateVisibility(t, e, !0);\n    }\n    _destroyDatasetMeta(t) {\n      const e = this._metasets[t];\n      e && e.controller && e.controller._destroy(), delete this._metasets[t];\n    }\n    _stop() {\n      let t, e;\n      for (this.stop(), mt.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t) this._destroyDatasetMeta(t);\n    }\n    destroy() {\n      this.notifyPlugins(\"beforeDestroy\");\n      const {\n        canvas: t,\n        ctx: e\n      } = this;\n      this._stop(), this.config.clearCache(), t && (this.unbindEvents(), we(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), this.notifyPlugins(\"destroy\"), delete gn[this.id], this.notifyPlugins(\"afterDestroy\");\n    }\n    toBase64Image() {\n      return this.canvas.toDataURL(...arguments);\n    }\n    bindEvents() {\n      this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;\n    }\n    bindUserEvents() {\n      const t = this._listeners,\n        e = this.platform,\n        i = (i, s) => {\n          e.addEventListener(this, i, s), t[i] = s;\n        },\n        s = (t, e, i) => {\n          t.offsetX = e, t.offsetY = i, this._eventHandler(t);\n        };\n      d(this.options.events, t => i(t, s));\n    }\n    bindResponsiveEvents() {\n      this._responsiveListeners || (this._responsiveListeners = {});\n      const t = this._responsiveListeners,\n        e = this.platform,\n        i = (i, s) => {\n          e.addEventListener(this, i, s), t[i] = s;\n        },\n        s = (i, s) => {\n          t[i] && (e.removeEventListener(this, i, s), delete t[i]);\n        },\n        n = (t, e) => {\n          this.canvas && this.resize(t, e);\n        };\n      let o;\n      const a = () => {\n        s(\"attach\", a), this.attached = !0, this.resize(), i(\"resize\", n), i(\"detach\", o);\n      };\n      o = () => {\n        this.attached = !1, s(\"resize\", n), this._stop(), this._resize(0, 0), i(\"attach\", a);\n      }, e.isAttached(this.canvas) ? a() : o();\n    }\n    unbindEvents() {\n      d(this._listeners, (t, e) => {\n        this.platform.removeEventListener(this, e, t);\n      }), this._listeners = {}, d(this._responsiveListeners, (t, e) => {\n        this.platform.removeEventListener(this, e, t);\n      }), this._responsiveListeners = void 0;\n    }\n    updateHoverStyle(t, e, i) {\n      const s = i ? \"set\" : \"remove\";\n      let n, o, a, r;\n      for (\"dataset\" === e && (n = this.getDatasetMeta(t[0].datasetIndex), n.controller[\"_\" + s + \"DatasetHoverStyle\"]()), a = 0, r = t.length; a < r; ++a) {\n        o = t[a];\n        const e = o && this.getDatasetMeta(o.datasetIndex).controller;\n        e && e[s + \"HoverStyle\"](o.element, o.datasetIndex, o.index);\n      }\n    }\n    getActiveElements() {\n      return this._active || [];\n    }\n    setActiveElements(t) {\n      const e = this._active || [],\n        i = t.map(_ref4 => {\n          let {\n            datasetIndex: t,\n            index: e\n          } = _ref4;\n          const i = this.getDatasetMeta(t);\n          if (!i) throw new Error(\"No dataset found at index \" + t);\n          return {\n            datasetIndex: t,\n            element: i.data[e],\n            index: e\n          };\n        });\n      !u(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e));\n    }\n    notifyPlugins(t, e, i) {\n      return this._plugins.notify(this, t, e, i);\n    }\n    _updateHoverStyles(t, e, i) {\n      const s = this.options.hover,\n        n = (t, e) => t.filter(t => !e.some(e => t.datasetIndex === e.datasetIndex && t.index === e.index)),\n        o = n(e, t),\n        a = i ? t : n(t, e);\n      o.length && this.updateHoverStyle(o, s.mode, !1), a.length && s.mode && this.updateHoverStyle(a, s.mode, !0);\n    }\n    _eventHandler(t, e) {\n      const i = {\n          event: t,\n          replay: e,\n          cancelable: !0,\n          inChartArea: this.isPointInArea(t)\n        },\n        s = e => (e.options.events || this.options.events).includes(t.native.type);\n      if (!1 === this.notifyPlugins(\"beforeEvent\", i, s)) return;\n      const n = this._handleEvent(t, e, i.inChartArea);\n      return i.cancelable = !1, this.notifyPlugins(\"afterEvent\", i, s), (n || i.changed) && this.render(), this;\n    }\n    _handleEvent(t, e, i) {\n      const {\n          _active: s = [],\n          options: n\n        } = this,\n        o = e,\n        a = this._getActiveElements(t, s, i, o),\n        r = P(t),\n        l = function (t, e, i, s) {\n          return i && \"mouseout\" !== t.type ? s ? e : t : null;\n        }(t, this._lastEvent, i, r);\n      i && (this._lastEvent = null, c(n.onHover, [t, a, this], this), r && c(n.onClick, [t, a, this], this));\n      const h = !u(a, s);\n      return (h || e) && (this._active = a, this._updateHoverStyles(a, s, e)), this._lastEvent = l, h;\n    }\n    _getActiveElements(t, e, i, s) {\n      if (\"mouseout\" === t.type) return [];\n      if (!i) return e;\n      const n = this.options.hover;\n      return this.getElementsAtEventForMode(t, n.mode, n, s);\n    }\n  }\n  const xn = () => d(bn.instances, t => t._plugins.invalidate()),\n    _n = !0;\n  function yn() {\n    throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n  }\n  Object.defineProperties(bn, {\n    defaults: {\n      enumerable: _n,\n      value: ne\n    },\n    instances: {\n      enumerable: _n,\n      value: gn\n    },\n    overrides: {\n      enumerable: _n,\n      value: te\n    },\n    registry: {\n      enumerable: _n,\n      value: Us\n    },\n    version: {\n      enumerable: _n,\n      value: \"3.9.1\"\n    },\n    getChart: {\n      enumerable: _n,\n      value: pn\n    },\n    register: {\n      enumerable: _n,\n      value: function value() {\n        Us.add(...arguments), xn();\n      }\n    },\n    unregister: {\n      enumerable: _n,\n      value: function value() {\n        Us.remove(...arguments), xn();\n      }\n    }\n  });\n  class vn {\n    constructor(t) {\n      this.options = t || {};\n    }\n    init(t) {}\n    formats() {\n      return yn();\n    }\n    parse(t, e) {\n      return yn();\n    }\n    format(t, e) {\n      return yn();\n    }\n    add(t, e, i) {\n      return yn();\n    }\n    diff(t, e, i) {\n      return yn();\n    }\n    startOf(t, e, i) {\n      return yn();\n    }\n    endOf(t, e) {\n      return yn();\n    }\n  }\n  vn.override = function (t) {\n    Object.assign(vn.prototype, t);\n  };\n  var wn = {\n    _date: vn\n  };\n  function Mn(t) {\n    const e = t.iScale,\n      i = function (t, e) {\n        if (!t._cache.$bar) {\n          const i = t.getMatchingVisibleMetas(e);\n          let s = [];\n          for (let e = 0, n = i.length; e < n; e++) s = s.concat(i[e].controller.getAllParsedValues(t));\n          t._cache.$bar = rt(s.sort((t, e) => t - e));\n        }\n        return t._cache.$bar;\n      }(e, t.type);\n    let s,\n      n,\n      o,\n      a,\n      r = e._length;\n    const l = () => {\n      32767 !== o && -32768 !== o && (M(a) && (r = Math.min(r, Math.abs(o - a) || r)), a = o);\n    };\n    for (s = 0, n = i.length; s < n; ++s) o = e.getPixelForValue(i[s]), l();\n    for (a = void 0, s = 0, n = e.ticks.length; s < n; ++s) o = e.getPixelForTick(s), l();\n    return r;\n  }\n  function kn(t, e, i, n) {\n    return s(t) ? function (t, e, i, s) {\n      const n = i.parse(t[0], s),\n        o = i.parse(t[1], s),\n        a = Math.min(n, o),\n        r = Math.max(n, o);\n      let l = a,\n        h = r;\n      Math.abs(a) > Math.abs(r) && (l = r, h = a), e[i.axis] = h, e._custom = {\n        barStart: l,\n        barEnd: h,\n        start: n,\n        end: o,\n        min: a,\n        max: r\n      };\n    }(t, e, i, n) : e[i.axis] = i.parse(t, n), e;\n  }\n  function Sn(t, e, i, s) {\n    const n = t.iScale,\n      o = t.vScale,\n      a = n.getLabels(),\n      r = n === o,\n      l = [];\n    let h, c, d, u;\n    for (h = i, c = i + s; h < c; ++h) u = e[h], d = {}, d[n.axis] = r || n.parse(a[h], h), l.push(kn(u, d, o, h));\n    return l;\n  }\n  function Pn(t) {\n    return t && void 0 !== t.barStart && void 0 !== t.barEnd;\n  }\n  function Dn(t, e, i, s) {\n    let n = e.borderSkipped;\n    const o = {};\n    if (!n) return void (t.borderSkipped = o);\n    if (!0 === n) return void (t.borderSkipped = {\n      top: !0,\n      right: !0,\n      bottom: !0,\n      left: !0\n    });\n    const {\n      start: a,\n      end: r,\n      reverse: l,\n      top: h,\n      bottom: c\n    } = function (t) {\n      let e, i, s, n, o;\n      return t.horizontal ? (e = t.base > t.x, i = \"left\", s = \"right\") : (e = t.base < t.y, i = \"bottom\", s = \"top\"), e ? (n = \"end\", o = \"start\") : (n = \"start\", o = \"end\"), {\n        start: i,\n        end: s,\n        reverse: e,\n        top: n,\n        bottom: o\n      };\n    }(t);\n    \"middle\" === n && i && (t.enableBorderRadius = !0, (i._top || 0) === s ? n = h : (i._bottom || 0) === s ? n = c : (o[On(c, a, r, l)] = !0, n = h)), o[On(n, a, r, l)] = !0, t.borderSkipped = o;\n  }\n  function On(t, e, i, s) {\n    var n, o, a;\n    return s ? (a = i, t = Cn(t = (n = t) === (o = e) ? a : n === a ? o : n, i, e)) : t = Cn(t, e, i), t;\n  }\n  function Cn(t, e, i) {\n    return \"start\" === t ? e : \"end\" === t ? i : t;\n  }\n  function An(t, _ref5, i) {\n    let {\n      inflateAmount: e\n    } = _ref5;\n    t.inflateAmount = \"auto\" === e ? 1 === i ? .33 : 0 : e;\n  }\n  class Tn extends Ls {\n    parsePrimitiveData(t, e, i, s) {\n      return Sn(t, e, i, s);\n    }\n    parseArrayData(t, e, i, s) {\n      return Sn(t, e, i, s);\n    }\n    parseObjectData(t, e, i, s) {\n      const {\n          iScale: n,\n          vScale: o\n        } = t,\n        {\n          xAxisKey: a = \"x\",\n          yAxisKey: r = \"y\"\n        } = this._parsing,\n        l = \"x\" === n.axis ? a : r,\n        h = \"x\" === o.axis ? a : r,\n        c = [];\n      let d, u, f, g;\n      for (d = i, u = i + s; d < u; ++d) g = e[d], f = {}, f[n.axis] = n.parse(y(g, l), d), c.push(kn(y(g, h), f, o, d));\n      return c;\n    }\n    updateRangeFromParsed(t, e, i, s) {\n      super.updateRangeFromParsed(t, e, i, s);\n      const n = i._custom;\n      n && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, n.min), t.max = Math.max(t.max, n.max));\n    }\n    getMaxOverflow() {\n      return 0;\n    }\n    getLabelAndValue(t) {\n      const e = this._cachedMeta,\n        {\n          iScale: i,\n          vScale: s\n        } = e,\n        n = this.getParsed(t),\n        o = n._custom,\n        a = Pn(o) ? \"[\" + o.start + \", \" + o.end + \"]\" : \"\" + s.getLabelForValue(n[s.axis]);\n      return {\n        label: \"\" + i.getLabelForValue(n[i.axis]),\n        value: a\n      };\n    }\n    initialize() {\n      this.enableOptionSharing = !0, super.initialize();\n      this._cachedMeta.stack = this.getDataset().stack;\n    }\n    update(t) {\n      const e = this._cachedMeta;\n      this.updateElements(e.data, 0, e.data.length, t);\n    }\n    updateElements(t, e, s, n) {\n      const o = \"reset\" === n,\n        {\n          index: a,\n          _cachedMeta: {\n            vScale: r\n          }\n        } = this,\n        l = r.getBasePixel(),\n        h = r.isHorizontal(),\n        c = this._getRuler(),\n        {\n          sharedOptions: d,\n          includeOptions: u\n        } = this._getSharedOptions(e, n);\n      for (let f = e; f < e + s; f++) {\n        const e = this.getParsed(f),\n          s = o || i(e[r.axis]) ? {\n            base: l,\n            head: l\n          } : this._calculateBarValuePixels(f),\n          g = this._calculateBarIndexPixels(f, c),\n          p = (e._stacks || {})[r.axis],\n          m = {\n            horizontal: h,\n            base: s.base,\n            enableBorderRadius: !p || Pn(e._custom) || a === p._top || a === p._bottom,\n            x: h ? s.head : g.center,\n            y: h ? g.center : s.head,\n            height: h ? g.size : Math.abs(s.size),\n            width: h ? Math.abs(s.size) : g.size\n          };\n        u && (m.options = d || this.resolveDataElementOptions(f, t[f].active ? \"active\" : n));\n        const b = m.options || t[f].options;\n        Dn(m, b, p, a), An(m, b, c.ratio), this.updateElement(t[f], f, m, n);\n      }\n    }\n    _getStacks(t, e) {\n      const {\n          iScale: s\n        } = this._cachedMeta,\n        n = s.getMatchingVisibleMetas(this._type).filter(t => t.controller.options.grouped),\n        o = s.options.stacked,\n        a = [],\n        r = t => {\n          const s = t.controller.getParsed(e),\n            n = s && s[t.vScale.axis];\n          if (i(n) || isNaN(n)) return !0;\n        };\n      for (const i of n) if ((void 0 === e || !r(i)) && ((!1 === o || -1 === a.indexOf(i.stack) || void 0 === o && void 0 === i.stack) && a.push(i.stack), i.index === t)) break;\n      return a.length || a.push(void 0), a;\n    }\n    _getStackCount(t) {\n      return this._getStacks(void 0, t).length;\n    }\n    _getStackIndex(t, e, i) {\n      const s = this._getStacks(t, i),\n        n = void 0 !== e ? s.indexOf(e) : -1;\n      return -1 === n ? s.length - 1 : n;\n    }\n    _getRuler() {\n      const t = this.options,\n        e = this._cachedMeta,\n        i = e.iScale,\n        s = [];\n      let n, o;\n      for (n = 0, o = e.data.length; n < o; ++n) s.push(i.getPixelForValue(this.getParsed(n)[i.axis], n));\n      const a = t.barThickness;\n      return {\n        min: a || Mn(e),\n        pixels: s,\n        start: i._startPixel,\n        end: i._endPixel,\n        stackCount: this._getStackCount(),\n        scale: i,\n        grouped: t.grouped,\n        ratio: a ? 1 : t.categoryPercentage * t.barPercentage\n      };\n    }\n    _calculateBarValuePixels(t) {\n      const {\n          _cachedMeta: {\n            vScale: e,\n            _stacked: s\n          },\n          options: {\n            base: n,\n            minBarLength: o\n          }\n        } = this,\n        a = n || 0,\n        r = this.getParsed(t),\n        l = r._custom,\n        h = Pn(l);\n      let c,\n        d,\n        u = r[e.axis],\n        f = 0,\n        g = s ? this.applyStack(e, r, s) : u;\n      g !== u && (f = g - u, g = u), h && (u = l.barStart, g = l.barEnd - l.barStart, 0 !== u && z(u) !== z(l.barEnd) && (f = 0), f += u);\n      const p = i(n) || h ? f : n;\n      let m = e.getPixelForValue(p);\n      if (c = this.chart.getDataVisibility(t) ? e.getPixelForValue(f + g) : m, d = c - m, Math.abs(d) < o) {\n        d = function (t, e, i) {\n          return 0 !== t ? z(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1);\n        }(d, e, a) * o, u === a && (m -= d / 2);\n        const t = e.getPixelForDecimal(0),\n          i = e.getPixelForDecimal(1),\n          s = Math.min(t, i),\n          n = Math.max(t, i);\n        m = Math.max(Math.min(m, n), s), c = m + d;\n      }\n      if (m === e.getPixelForValue(a)) {\n        const t = z(d) * e.getLineWidthForValue(a) / 2;\n        m += t, d -= t;\n      }\n      return {\n        size: d,\n        base: m,\n        head: c,\n        center: c + d / 2\n      };\n    }\n    _calculateBarIndexPixels(t, e) {\n      const s = e.scale,\n        n = this.options,\n        o = n.skipNull,\n        a = r(n.maxBarThickness, 1 / 0);\n      let l, h;\n      if (e.grouped) {\n        const s = o ? this._getStackCount(t) : e.stackCount,\n          r = \"flex\" === n.barThickness ? function (t, e, i, s) {\n            const n = e.pixels,\n              o = n[t];\n            let a = t > 0 ? n[t - 1] : null,\n              r = t < n.length - 1 ? n[t + 1] : null;\n            const l = i.categoryPercentage;\n            null === a && (a = o - (null === r ? e.end - e.start : r - o)), null === r && (r = o + o - a);\n            const h = o - (o - Math.min(a, r)) / 2 * l;\n            return {\n              chunk: Math.abs(r - a) / 2 * l / s,\n              ratio: i.barPercentage,\n              start: h\n            };\n          }(t, e, n, s) : function (t, e, s, n) {\n            const o = s.barThickness;\n            let a, r;\n            return i(o) ? (a = e.min * s.categoryPercentage, r = s.barPercentage) : (a = o * n, r = 1), {\n              chunk: a / n,\n              ratio: r,\n              start: e.pixels[t] - a / 2\n            };\n          }(t, e, n, s),\n          c = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0);\n        l = r.start + r.chunk * c + r.chunk / 2, h = Math.min(a, r.chunk * r.ratio);\n      } else l = s.getPixelForValue(this.getParsed(t)[s.axis], t), h = Math.min(a, e.min * e.ratio);\n      return {\n        base: l - h / 2,\n        head: l + h / 2,\n        center: l,\n        size: h\n      };\n    }\n    draw() {\n      const t = this._cachedMeta,\n        e = t.vScale,\n        i = t.data,\n        s = i.length;\n      let n = 0;\n      for (; n < s; ++n) null !== this.getParsed(n)[e.axis] && i[n].draw(this._ctx);\n    }\n  }\n  Tn.id = \"bar\", Tn.defaults = {\n    datasetElementType: !1,\n    dataElementType: \"bar\",\n    categoryPercentage: .8,\n    barPercentage: .9,\n    grouped: !0,\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"x\", \"y\", \"base\", \"width\", \"height\"]\n      }\n    }\n  }, Tn.overrides = {\n    scales: {\n      _index_: {\n        type: \"category\",\n        offset: !0,\n        grid: {\n          offset: !0\n        }\n      },\n      _value_: {\n        type: \"linear\",\n        beginAtZero: !0\n      }\n    }\n  };\n  class Ln extends Ls {\n    initialize() {\n      this.enableOptionSharing = !0, super.initialize();\n    }\n    parsePrimitiveData(t, e, i, s) {\n      const n = super.parsePrimitiveData(t, e, i, s);\n      for (let t = 0; t < n.length; t++) n[t]._custom = this.resolveDataElementOptions(t + i).radius;\n      return n;\n    }\n    parseArrayData(t, e, i, s) {\n      const n = super.parseArrayData(t, e, i, s);\n      for (let t = 0; t < n.length; t++) {\n        const s = e[i + t];\n        n[t]._custom = r(s[2], this.resolveDataElementOptions(t + i).radius);\n      }\n      return n;\n    }\n    parseObjectData(t, e, i, s) {\n      const n = super.parseObjectData(t, e, i, s);\n      for (let t = 0; t < n.length; t++) {\n        const s = e[i + t];\n        n[t]._custom = r(s && s.r && +s.r, this.resolveDataElementOptions(t + i).radius);\n      }\n      return n;\n    }\n    getMaxOverflow() {\n      const t = this._cachedMeta.data;\n      let e = 0;\n      for (let i = t.length - 1; i >= 0; --i) e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) / 2);\n      return e > 0 && e;\n    }\n    getLabelAndValue(t) {\n      const e = this._cachedMeta,\n        {\n          xScale: i,\n          yScale: s\n        } = e,\n        n = this.getParsed(t),\n        o = i.getLabelForValue(n.x),\n        a = s.getLabelForValue(n.y),\n        r = n._custom;\n      return {\n        label: e.label,\n        value: \"(\" + o + \", \" + a + (r ? \", \" + r : \"\") + \")\"\n      };\n    }\n    update(t) {\n      const e = this._cachedMeta.data;\n      this.updateElements(e, 0, e.length, t);\n    }\n    updateElements(t, e, i, s) {\n      const n = \"reset\" === s,\n        {\n          iScale: o,\n          vScale: a\n        } = this._cachedMeta,\n        {\n          sharedOptions: r,\n          includeOptions: l\n        } = this._getSharedOptions(e, s),\n        h = o.axis,\n        c = a.axis;\n      for (let d = e; d < e + i; d++) {\n        const e = t[d],\n          i = !n && this.getParsed(d),\n          u = {},\n          f = u[h] = n ? o.getPixelForDecimal(.5) : o.getPixelForValue(i[h]),\n          g = u[c] = n ? a.getBasePixel() : a.getPixelForValue(i[c]);\n        u.skip = isNaN(f) || isNaN(g), l && (u.options = r || this.resolveDataElementOptions(d, e.active ? \"active\" : s), n && (u.options.radius = 0)), this.updateElement(e, d, u, s);\n      }\n    }\n    resolveDataElementOptions(t, e) {\n      const i = this.getParsed(t);\n      let s = super.resolveDataElementOptions(t, e);\n      s.$shared && (s = Object.assign({}, s, {\n        $shared: !1\n      }));\n      const n = s.radius;\n      return \"active\" !== e && (s.radius = 0), s.radius += r(i && i._custom, n), s;\n    }\n  }\n  Ln.id = \"bubble\", Ln.defaults = {\n    datasetElementType: !1,\n    dataElementType: \"point\",\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"x\", \"y\", \"borderWidth\", \"radius\"]\n      }\n    }\n  }, Ln.overrides = {\n    scales: {\n      x: {\n        type: \"linear\"\n      },\n      y: {\n        type: \"linear\"\n      }\n    },\n    plugins: {\n      tooltip: {\n        callbacks: {\n          title: () => \"\"\n        }\n      }\n    }\n  };\n  class En extends Ls {\n    constructor(t, e) {\n      super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;\n    }\n    linkScales() {}\n    parse(t, e) {\n      const i = this.getDataset().data,\n        s = this._cachedMeta;\n      if (!1 === this._parsing) s._parsed = i;else {\n        let o,\n          a,\n          r = t => +i[t];\n        if (n(i[t])) {\n          const {\n            key: t = \"value\"\n          } = this._parsing;\n          r = e => +y(i[e], t);\n        }\n        for (o = t, a = t + e; o < a; ++o) s._parsed[o] = r(o);\n      }\n    }\n    _getRotation() {\n      return H(this.options.rotation - 90);\n    }\n    _getCircumference() {\n      return H(this.options.circumference);\n    }\n    _getRotationExtents() {\n      let t = O,\n        e = -O;\n      for (let i = 0; i < this.chart.data.datasets.length; ++i) if (this.chart.isDatasetVisible(i)) {\n        const s = this.chart.getDatasetMeta(i).controller,\n          n = s._getRotation(),\n          o = s._getCircumference();\n        t = Math.min(t, n), e = Math.max(e, n + o);\n      }\n      return {\n        rotation: t,\n        circumference: e - t\n      };\n    }\n    update(t) {\n      const e = this.chart,\n        {\n          chartArea: i\n        } = e,\n        s = this._cachedMeta,\n        n = s.data,\n        o = this.getMaxBorderWidth() + this.getMaxOffset(n) + this.options.spacing,\n        a = Math.max((Math.min(i.width, i.height) - o) / 2, 0),\n        r = Math.min(l(this.options.cutout, a), 1),\n        c = this._getRingWeight(this.index),\n        {\n          circumference: d,\n          rotation: u\n        } = this._getRotationExtents(),\n        {\n          ratioX: f,\n          ratioY: g,\n          offsetX: p,\n          offsetY: m\n        } = function (t, e, i) {\n          let s = 1,\n            n = 1,\n            o = 0,\n            a = 0;\n          if (e < O) {\n            const r = t,\n              l = r + e,\n              h = Math.cos(r),\n              c = Math.sin(r),\n              d = Math.cos(l),\n              u = Math.sin(l),\n              f = (t, e, s) => G(t, r, l, !0) ? 1 : Math.max(e, e * i, s, s * i),\n              g = (t, e, s) => G(t, r, l, !0) ? -1 : Math.min(e, e * i, s, s * i),\n              p = f(0, h, d),\n              m = f(L, c, u),\n              b = g(D, h, d),\n              x = g(D + L, c, u);\n            s = (p - b) / 2, n = (m - x) / 2, o = -(p + b) / 2, a = -(m + x) / 2;\n          }\n          return {\n            ratioX: s,\n            ratioY: n,\n            offsetX: o,\n            offsetY: a\n          };\n        }(u, d, r),\n        b = (i.width - o) / f,\n        x = (i.height - o) / g,\n        _ = Math.max(Math.min(b, x) / 2, 0),\n        y = h(this.options.radius, _),\n        v = (y - Math.max(y * r, 0)) / this._getVisibleDatasetWeightTotal();\n      this.offsetX = p * y, this.offsetY = m * y, s.total = this.calculateTotal(), this.outerRadius = y - v * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - v * c, 0), this.updateElements(n, 0, n.length, t);\n    }\n    _circumference(t, e) {\n      const i = this.options,\n        s = this._cachedMeta,\n        n = this._getCircumference();\n      return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === s._parsed[t] || s.data[t].hidden ? 0 : this.calculateCircumference(s._parsed[t] * n / O);\n    }\n    updateElements(t, e, i, s) {\n      const n = \"reset\" === s,\n        o = this.chart,\n        a = o.chartArea,\n        r = o.options.animation,\n        l = (a.left + a.right) / 2,\n        h = (a.top + a.bottom) / 2,\n        c = n && r.animateScale,\n        d = c ? 0 : this.innerRadius,\n        u = c ? 0 : this.outerRadius,\n        {\n          sharedOptions: f,\n          includeOptions: g\n        } = this._getSharedOptions(e, s);\n      let p,\n        m = this._getRotation();\n      for (p = 0; p < e; ++p) m += this._circumference(p, n);\n      for (p = e; p < e + i; ++p) {\n        const e = this._circumference(p, n),\n          i = t[p],\n          o = {\n            x: l + this.offsetX,\n            y: h + this.offsetY,\n            startAngle: m,\n            endAngle: m + e,\n            circumference: e,\n            outerRadius: u,\n            innerRadius: d\n          };\n        g && (o.options = f || this.resolveDataElementOptions(p, i.active ? \"active\" : s)), m += e, this.updateElement(i, p, o, s);\n      }\n    }\n    calculateTotal() {\n      const t = this._cachedMeta,\n        e = t.data;\n      let i,\n        s = 0;\n      for (i = 0; i < e.length; i++) {\n        const n = t._parsed[i];\n        null === n || isNaN(n) || !this.chart.getDataVisibility(i) || e[i].hidden || (s += Math.abs(n));\n      }\n      return s;\n    }\n    calculateCircumference(t) {\n      const e = this._cachedMeta.total;\n      return e > 0 && !isNaN(t) ? O * (Math.abs(t) / e) : 0;\n    }\n    getLabelAndValue(t) {\n      const e = this._cachedMeta,\n        i = this.chart,\n        s = i.data.labels || [],\n        n = li(e._parsed[t], i.options.locale);\n      return {\n        label: s[t] || \"\",\n        value: n\n      };\n    }\n    getMaxBorderWidth(t) {\n      let e = 0;\n      const i = this.chart;\n      let s, n, o, a, r;\n      if (!t) for (s = 0, n = i.data.datasets.length; s < n; ++s) if (i.isDatasetVisible(s)) {\n        o = i.getDatasetMeta(s), t = o.data, a = o.controller;\n        break;\n      }\n      if (!t) return 0;\n      for (s = 0, n = t.length; s < n; ++s) r = a.resolveDataElementOptions(s), \"inner\" !== r.borderAlign && (e = Math.max(e, r.borderWidth || 0, r.hoverBorderWidth || 0));\n      return e;\n    }\n    getMaxOffset(t) {\n      let e = 0;\n      for (let i = 0, s = t.length; i < s; ++i) {\n        const t = this.resolveDataElementOptions(i);\n        e = Math.max(e, t.offset || 0, t.hoverOffset || 0);\n      }\n      return e;\n    }\n    _getRingWeightOffset(t) {\n      let e = 0;\n      for (let i = 0; i < t; ++i) this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));\n      return e;\n    }\n    _getRingWeight(t) {\n      return Math.max(r(this.chart.data.datasets[t].weight, 1), 0);\n    }\n    _getVisibleDatasetWeightTotal() {\n      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n  }\n  En.id = \"doughnut\", En.defaults = {\n    datasetElementType: !1,\n    dataElementType: \"arc\",\n    animation: {\n      animateRotate: !0,\n      animateScale: !1\n    },\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"circumference\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"startAngle\", \"x\", \"y\", \"offset\", \"borderWidth\", \"spacing\"]\n      }\n    },\n    cutout: \"50%\",\n    rotation: 0,\n    circumference: 360,\n    radius: \"100%\",\n    spacing: 0,\n    indexAxis: \"r\"\n  }, En.descriptors = {\n    _scriptable: t => \"spacing\" !== t,\n    _indexable: t => \"spacing\" !== t\n  }, En.overrides = {\n    aspectRatio: 1,\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(t) {\n            const e = t.data;\n            if (e.labels.length && e.datasets.length) {\n              const {\n                labels: {\n                  pointStyle: i\n                }\n              } = t.legend.options;\n              return e.labels.map((e, s) => {\n                const n = t.getDatasetMeta(0).controller.getStyle(s);\n                return {\n                  text: e,\n                  fillStyle: n.backgroundColor,\n                  strokeStyle: n.borderColor,\n                  lineWidth: n.borderWidth,\n                  pointStyle: i,\n                  hidden: !t.getDataVisibility(s),\n                  index: s\n                };\n              });\n            }\n            return [];\n          }\n        },\n        onClick(t, e, i) {\n          i.chart.toggleDataVisibility(e.index), i.chart.update();\n        }\n      },\n      tooltip: {\n        callbacks: {\n          title: () => \"\",\n          label(t) {\n            let e = t.label;\n            const i = \": \" + t.formattedValue;\n            return s(e) ? (e = e.slice(), e[0] += i) : e += i, e;\n          }\n        }\n      }\n    }\n  };\n  class Rn extends Ls {\n    initialize() {\n      this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();\n    }\n    update(t) {\n      const e = this._cachedMeta,\n        {\n          dataset: i,\n          data: s = [],\n          _dataset: n\n        } = e,\n        o = this.chart._animationsDisabled;\n      let {\n        start: a,\n        count: r\n      } = gt(e, s, o);\n      this._drawStart = a, this._drawCount = r, pt(e) && (a = 0, r = s.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!n._decimated, i.points = s;\n      const l = this.resolveDatasetElementOptions(t);\n      this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(i, void 0, {\n        animated: !o,\n        options: l\n      }, t), this.updateElements(s, a, r, t);\n    }\n    updateElements(t, e, s, n) {\n      const o = \"reset\" === n,\n        {\n          iScale: a,\n          vScale: r,\n          _stacked: l,\n          _dataset: h\n        } = this._cachedMeta,\n        {\n          sharedOptions: c,\n          includeOptions: d\n        } = this._getSharedOptions(e, n),\n        u = a.axis,\n        f = r.axis,\n        {\n          spanGaps: g,\n          segment: p\n        } = this.options,\n        m = B(g) ? g : Number.POSITIVE_INFINITY,\n        b = this.chart._animationsDisabled || o || \"none\" === n;\n      let x = e > 0 && this.getParsed(e - 1);\n      for (let g = e; g < e + s; ++g) {\n        const e = t[g],\n          s = this.getParsed(g),\n          _ = b ? e : {},\n          y = i(s[f]),\n          v = _[u] = a.getPixelForValue(s[u], g),\n          w = _[f] = o || y ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, s, l) : s[f], g);\n        _.skip = isNaN(v) || isNaN(w) || y, _.stop = g > 0 && Math.abs(s[u] - x[u]) > m, p && (_.parsed = s, _.raw = h.data[g]), d && (_.options = c || this.resolveDataElementOptions(g, e.active ? \"active\" : n)), b || this.updateElement(e, g, _, n), x = s;\n      }\n    }\n    getMaxOverflow() {\n      const t = this._cachedMeta,\n        e = t.dataset,\n        i = e.options && e.options.borderWidth || 0,\n        s = t.data || [];\n      if (!s.length) return i;\n      const n = s[0].size(this.resolveDataElementOptions(0)),\n        o = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1));\n      return Math.max(i, n, o) / 2;\n    }\n    draw() {\n      const t = this._cachedMeta;\n      t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();\n    }\n  }\n  Rn.id = \"line\", Rn.defaults = {\n    datasetElementType: \"line\",\n    dataElementType: \"point\",\n    showLine: !0,\n    spanGaps: !1\n  }, Rn.overrides = {\n    scales: {\n      _index_: {\n        type: \"category\"\n      },\n      _value_: {\n        type: \"linear\"\n      }\n    }\n  };\n  class In extends Ls {\n    constructor(t, e) {\n      super(t, e), this.innerRadius = void 0, this.outerRadius = void 0;\n    }\n    getLabelAndValue(t) {\n      const e = this._cachedMeta,\n        i = this.chart,\n        s = i.data.labels || [],\n        n = li(e._parsed[t].r, i.options.locale);\n      return {\n        label: s[t] || \"\",\n        value: n\n      };\n    }\n    parseObjectData(t, e, i, s) {\n      return Ue.bind(this)(t, e, i, s);\n    }\n    update(t) {\n      const e = this._cachedMeta.data;\n      this._updateRadius(), this.updateElements(e, 0, e.length, t);\n    }\n    getMinMax() {\n      const t = this._cachedMeta,\n        e = {\n          min: Number.POSITIVE_INFINITY,\n          max: Number.NEGATIVE_INFINITY\n        };\n      return t.data.forEach((t, i) => {\n        const s = this.getParsed(i).r;\n        !isNaN(s) && this.chart.getDataVisibility(i) && (s < e.min && (e.min = s), s > e.max && (e.max = s));\n      }), e;\n    }\n    _updateRadius() {\n      const t = this.chart,\n        e = t.chartArea,\n        i = t.options,\n        s = Math.min(e.right - e.left, e.bottom - e.top),\n        n = Math.max(s / 2, 0),\n        o = (n - Math.max(i.cutoutPercentage ? n / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount();\n      this.outerRadius = n - o * this.index, this.innerRadius = this.outerRadius - o;\n    }\n    updateElements(t, e, i, s) {\n      const n = \"reset\" === s,\n        o = this.chart,\n        a = o.options.animation,\n        r = this._cachedMeta.rScale,\n        l = r.xCenter,\n        h = r.yCenter,\n        c = r.getIndexAngle(0) - .5 * D;\n      let d,\n        u = c;\n      const f = 360 / this.countVisibleElements();\n      for (d = 0; d < e; ++d) u += this._computeAngle(d, s, f);\n      for (d = e; d < e + i; d++) {\n        const e = t[d];\n        let i = u,\n          g = u + this._computeAngle(d, s, f),\n          p = o.getDataVisibility(d) ? r.getDistanceFromCenterForValue(this.getParsed(d).r) : 0;\n        u = g, n && (a.animateScale && (p = 0), a.animateRotate && (i = g = c));\n        const m = {\n          x: l,\n          y: h,\n          innerRadius: 0,\n          outerRadius: p,\n          startAngle: i,\n          endAngle: g,\n          options: this.resolveDataElementOptions(d, e.active ? \"active\" : s)\n        };\n        this.updateElement(e, d, m, s);\n      }\n    }\n    countVisibleElements() {\n      const t = this._cachedMeta;\n      let e = 0;\n      return t.data.forEach((t, i) => {\n        !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && e++;\n      }), e;\n    }\n    _computeAngle(t, e, i) {\n      return this.chart.getDataVisibility(t) ? H(this.resolveDataElementOptions(t, e).angle || i) : 0;\n    }\n  }\n  In.id = \"polarArea\", In.defaults = {\n    dataElementType: \"arc\",\n    animation: {\n      animateRotate: !0,\n      animateScale: !0\n    },\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"x\", \"y\", \"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\"]\n      }\n    },\n    indexAxis: \"r\",\n    startAngle: 0\n  }, In.overrides = {\n    aspectRatio: 1,\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(t) {\n            const e = t.data;\n            if (e.labels.length && e.datasets.length) {\n              const {\n                labels: {\n                  pointStyle: i\n                }\n              } = t.legend.options;\n              return e.labels.map((e, s) => {\n                const n = t.getDatasetMeta(0).controller.getStyle(s);\n                return {\n                  text: e,\n                  fillStyle: n.backgroundColor,\n                  strokeStyle: n.borderColor,\n                  lineWidth: n.borderWidth,\n                  pointStyle: i,\n                  hidden: !t.getDataVisibility(s),\n                  index: s\n                };\n              });\n            }\n            return [];\n          }\n        },\n        onClick(t, e, i) {\n          i.chart.toggleDataVisibility(e.index), i.chart.update();\n        }\n      },\n      tooltip: {\n        callbacks: {\n          title: () => \"\",\n          label: t => t.chart.data.labels[t.dataIndex] + \": \" + t.formattedValue\n        }\n      }\n    },\n    scales: {\n      r: {\n        type: \"radialLinear\",\n        angleLines: {\n          display: !1\n        },\n        beginAtZero: !0,\n        grid: {\n          circular: !0\n        },\n        pointLabels: {\n          display: !1\n        },\n        startAngle: 0\n      }\n    }\n  };\n  class zn extends En {}\n  zn.id = \"pie\", zn.defaults = {\n    cutout: 0,\n    rotation: 0,\n    circumference: 360,\n    radius: \"100%\"\n  };\n  class Fn extends Ls {\n    getLabelAndValue(t) {\n      const e = this._cachedMeta.vScale,\n        i = this.getParsed(t);\n      return {\n        label: e.getLabels()[t],\n        value: \"\" + e.getLabelForValue(i[e.axis])\n      };\n    }\n    parseObjectData(t, e, i, s) {\n      return Ue.bind(this)(t, e, i, s);\n    }\n    update(t) {\n      const e = this._cachedMeta,\n        i = e.dataset,\n        s = e.data || [],\n        n = e.iScale.getLabels();\n      if (i.points = s, \"resize\" !== t) {\n        const e = this.resolveDatasetElementOptions(t);\n        this.options.showLine || (e.borderWidth = 0);\n        const o = {\n          _loop: !0,\n          _fullLoop: n.length === s.length,\n          options: e\n        };\n        this.updateElement(i, void 0, o, t);\n      }\n      this.updateElements(s, 0, s.length, t);\n    }\n    updateElements(t, e, i, s) {\n      const n = this._cachedMeta.rScale,\n        o = \"reset\" === s;\n      for (let a = e; a < e + i; a++) {\n        const e = t[a],\n          i = this.resolveDataElementOptions(a, e.active ? \"active\" : s),\n          r = n.getPointPositionForValue(a, this.getParsed(a).r),\n          l = o ? n.xCenter : r.x,\n          h = o ? n.yCenter : r.y,\n          c = {\n            x: l,\n            y: h,\n            angle: r.angle,\n            skip: isNaN(l) || isNaN(h),\n            options: i\n          };\n        this.updateElement(e, a, c, s);\n      }\n    }\n  }\n  Fn.id = \"radar\", Fn.defaults = {\n    datasetElementType: \"line\",\n    dataElementType: \"point\",\n    indexAxis: \"r\",\n    showLine: !0,\n    elements: {\n      line: {\n        fill: \"start\"\n      }\n    }\n  }, Fn.overrides = {\n    aspectRatio: 1,\n    scales: {\n      r: {\n        type: \"radialLinear\"\n      }\n    }\n  };\n  class Vn extends Ls {\n    update(t) {\n      const e = this._cachedMeta,\n        {\n          data: i = []\n        } = e,\n        s = this.chart._animationsDisabled;\n      let {\n        start: n,\n        count: o\n      } = gt(e, i, s);\n      if (this._drawStart = n, this._drawCount = o, pt(e) && (n = 0, o = i.length), this.options.showLine) {\n        const {\n          dataset: n,\n          _dataset: o\n        } = e;\n        n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!o._decimated, n.points = i;\n        const a = this.resolveDatasetElementOptions(t);\n        a.segment = this.options.segment, this.updateElement(n, void 0, {\n          animated: !s,\n          options: a\n        }, t);\n      }\n      this.updateElements(i, n, o, t);\n    }\n    addElements() {\n      const {\n        showLine: t\n      } = this.options;\n      !this.datasetElementType && t && (this.datasetElementType = Us.getElement(\"line\")), super.addElements();\n    }\n    updateElements(t, e, s, n) {\n      const o = \"reset\" === n,\n        {\n          iScale: a,\n          vScale: r,\n          _stacked: l,\n          _dataset: h\n        } = this._cachedMeta,\n        c = this.resolveDataElementOptions(e, n),\n        d = this.getSharedOptions(c),\n        u = this.includeOptions(n, d),\n        f = a.axis,\n        g = r.axis,\n        {\n          spanGaps: p,\n          segment: m\n        } = this.options,\n        b = B(p) ? p : Number.POSITIVE_INFINITY,\n        x = this.chart._animationsDisabled || o || \"none\" === n;\n      let _ = e > 0 && this.getParsed(e - 1);\n      for (let c = e; c < e + s; ++c) {\n        const e = t[c],\n          s = this.getParsed(c),\n          p = x ? e : {},\n          y = i(s[g]),\n          v = p[f] = a.getPixelForValue(s[f], c),\n          w = p[g] = o || y ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, s, l) : s[g], c);\n        p.skip = isNaN(v) || isNaN(w) || y, p.stop = c > 0 && Math.abs(s[f] - _[f]) > b, m && (p.parsed = s, p.raw = h.data[c]), u && (p.options = d || this.resolveDataElementOptions(c, e.active ? \"active\" : n)), x || this.updateElement(e, c, p, n), _ = s;\n      }\n      this.updateSharedOptions(d, n, c);\n    }\n    getMaxOverflow() {\n      const t = this._cachedMeta,\n        e = t.data || [];\n      if (!this.options.showLine) {\n        let t = 0;\n        for (let i = e.length - 1; i >= 0; --i) t = Math.max(t, e[i].size(this.resolveDataElementOptions(i)) / 2);\n        return t > 0 && t;\n      }\n      const i = t.dataset,\n        s = i.options && i.options.borderWidth || 0;\n      if (!e.length) return s;\n      const n = e[0].size(this.resolveDataElementOptions(0)),\n        o = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));\n      return Math.max(s, n, o) / 2;\n    }\n  }\n  Vn.id = \"scatter\", Vn.defaults = {\n    datasetElementType: !1,\n    dataElementType: \"point\",\n    showLine: !1,\n    fill: !1\n  }, Vn.overrides = {\n    interaction: {\n      mode: \"point\"\n    },\n    plugins: {\n      tooltip: {\n        callbacks: {\n          title: () => \"\",\n          label: t => \"(\" + t.label + \", \" + t.formattedValue + \")\"\n        }\n      }\n    },\n    scales: {\n      x: {\n        type: \"linear\"\n      },\n      y: {\n        type: \"linear\"\n      }\n    }\n  };\n  var Bn = Object.freeze({\n    __proto__: null,\n    BarController: Tn,\n    BubbleController: Ln,\n    DoughnutController: En,\n    LineController: Rn,\n    PolarAreaController: In,\n    PieController: zn,\n    RadarController: Fn,\n    ScatterController: Vn\n  });\n  function Nn(t, e, i) {\n    const {\n      startAngle: s,\n      pixelMargin: n,\n      x: o,\n      y: a,\n      outerRadius: r,\n      innerRadius: l\n    } = e;\n    let h = n / r;\n    t.beginPath(), t.arc(o, a, r, s - h, i + h), l > n ? (h = n / l, t.arc(o, a, l, i + h, s - h, !0)) : t.arc(o, a, n, i + L, s - L), t.closePath(), t.clip();\n  }\n  function Wn(t, e, i, s) {\n    const n = ui(t.options.borderRadius, [\"outerStart\", \"outerEnd\", \"innerStart\", \"innerEnd\"]);\n    const o = (i - e) / 2,\n      a = Math.min(o, s * e / 2),\n      r = t => {\n        const e = (i - Math.min(o, t)) * s / 2;\n        return Z(t, 0, Math.min(o, e));\n      };\n    return {\n      outerStart: r(n.outerStart),\n      outerEnd: r(n.outerEnd),\n      innerStart: Z(n.innerStart, 0, a),\n      innerEnd: Z(n.innerEnd, 0, a)\n    };\n  }\n  function jn(t, e, i, s) {\n    return {\n      x: i + t * Math.cos(e),\n      y: s + t * Math.sin(e)\n    };\n  }\n  function Hn(t, e, i, s, n, o) {\n    const {\n        x: a,\n        y: r,\n        startAngle: l,\n        pixelMargin: h,\n        innerRadius: c\n      } = e,\n      d = Math.max(e.outerRadius + s + i - h, 0),\n      u = c > 0 ? c + s + i + h : 0;\n    let f = 0;\n    const g = n - l;\n    if (s) {\n      const t = ((c > 0 ? c - s : 0) + (d > 0 ? d - s : 0)) / 2;\n      f = (g - (0 !== t ? g * t / (t + s) : g)) / 2;\n    }\n    const p = (g - Math.max(.001, g * d - i / D) / d) / 2,\n      m = l + p + f,\n      b = n - p - f,\n      {\n        outerStart: x,\n        outerEnd: _,\n        innerStart: y,\n        innerEnd: v\n      } = Wn(e, u, d, b - m),\n      w = d - x,\n      M = d - _,\n      k = m + x / w,\n      S = b - _ / M,\n      P = u + y,\n      O = u + v,\n      C = m + y / P,\n      A = b - v / O;\n    if (t.beginPath(), o) {\n      if (t.arc(a, r, d, k, S), _ > 0) {\n        const e = jn(M, S, a, r);\n        t.arc(e.x, e.y, _, S, b + L);\n      }\n      const e = jn(O, b, a, r);\n      if (t.lineTo(e.x, e.y), v > 0) {\n        const e = jn(O, A, a, r);\n        t.arc(e.x, e.y, v, b + L, A + Math.PI);\n      }\n      if (t.arc(a, r, u, b - v / u, m + y / u, !0), y > 0) {\n        const e = jn(P, C, a, r);\n        t.arc(e.x, e.y, y, C + Math.PI, m - L);\n      }\n      const i = jn(w, m, a, r);\n      if (t.lineTo(i.x, i.y), x > 0) {\n        const e = jn(w, k, a, r);\n        t.arc(e.x, e.y, x, m - L, k);\n      }\n    } else {\n      t.moveTo(a, r);\n      const e = Math.cos(k) * d + a,\n        i = Math.sin(k) * d + r;\n      t.lineTo(e, i);\n      const s = Math.cos(S) * d + a,\n        n = Math.sin(S) * d + r;\n      t.lineTo(s, n);\n    }\n    t.closePath();\n  }\n  function $n(t, e, i, s, n, o) {\n    const {\n        options: a\n      } = e,\n      {\n        borderWidth: r,\n        borderJoinStyle: l\n      } = a,\n      h = \"inner\" === a.borderAlign;\n    r && (h ? (t.lineWidth = 2 * r, t.lineJoin = l || \"round\") : (t.lineWidth = r, t.lineJoin = l || \"bevel\"), e.fullCircles && function (t, e, i) {\n      const {\n          x: s,\n          y: n,\n          startAngle: o,\n          pixelMargin: a,\n          fullCircles: r\n        } = e,\n        l = Math.max(e.outerRadius - a, 0),\n        h = e.innerRadius + a;\n      let c;\n      for (i && Nn(t, e, o + O), t.beginPath(), t.arc(s, n, h, o + O, o, !0), c = 0; c < r; ++c) t.stroke();\n      for (t.beginPath(), t.arc(s, n, l, o, o + O), c = 0; c < r; ++c) t.stroke();\n    }(t, e, h), h && Nn(t, e, n), Hn(t, e, i, s, n, o), t.stroke());\n  }\n  class Yn extends Es {\n    constructor(t) {\n      super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);\n    }\n    inRange(t, e, i) {\n      const s = this.getProps([\"x\", \"y\"], i),\n        {\n          angle: n,\n          distance: o\n        } = U(s, {\n          x: t,\n          y: e\n        }),\n        {\n          startAngle: a,\n          endAngle: l,\n          innerRadius: h,\n          outerRadius: c,\n          circumference: d\n        } = this.getProps([\"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"circumference\"], i),\n        u = this.options.spacing / 2,\n        f = r(d, l - a) >= O || G(n, a, l),\n        g = Q(o, h + u, c + u);\n      return f && g;\n    }\n    getCenterPoint(t) {\n      const {\n          x: e,\n          y: i,\n          startAngle: s,\n          endAngle: n,\n          innerRadius: o,\n          outerRadius: a\n        } = this.getProps([\"x\", \"y\", \"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"circumference\"], t),\n        {\n          offset: r,\n          spacing: l\n        } = this.options,\n        h = (s + n) / 2,\n        c = (o + a + l + r) / 2;\n      return {\n        x: e + Math.cos(h) * c,\n        y: i + Math.sin(h) * c\n      };\n    }\n    tooltipPosition(t) {\n      return this.getCenterPoint(t);\n    }\n    draw(t) {\n      const {\n          options: e,\n          circumference: i\n        } = this,\n        s = (e.offset || 0) / 2,\n        n = (e.spacing || 0) / 2,\n        o = e.circular;\n      if (this.pixelMargin = \"inner\" === e.borderAlign ? .33 : 0, this.fullCircles = i > O ? Math.floor(i / O) : 0, 0 === i || this.innerRadius < 0 || this.outerRadius < 0) return;\n      t.save();\n      let a = 0;\n      if (s) {\n        a = s / 2;\n        const e = (this.startAngle + this.endAngle) / 2;\n        t.translate(Math.cos(e) * a, Math.sin(e) * a), this.circumference >= D && (a = s);\n      }\n      t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor;\n      const r = function (t, e, i, s, n) {\n        const {\n          fullCircles: o,\n          startAngle: a,\n          circumference: r\n        } = e;\n        let l = e.endAngle;\n        if (o) {\n          Hn(t, e, i, s, a + O, n);\n          for (let e = 0; e < o; ++e) t.fill();\n          isNaN(r) || (l = a + r % O, r % O == 0 && (l += O));\n        }\n        return Hn(t, e, i, s, l, n), t.fill(), l;\n      }(t, this, a, n, o);\n      $n(t, this, a, n, r, o), t.restore();\n    }\n  }\n  function Un(t, e) {\n    let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : e;\n    t.lineCap = r(i.borderCapStyle, e.borderCapStyle), t.setLineDash(r(i.borderDash, e.borderDash)), t.lineDashOffset = r(i.borderDashOffset, e.borderDashOffset), t.lineJoin = r(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = r(i.borderWidth, e.borderWidth), t.strokeStyle = r(i.borderColor, e.borderColor);\n  }\n  function Xn(t, e, i) {\n    t.lineTo(i.x, i.y);\n  }\n  function qn(t, e) {\n    let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const s = t.length,\n      {\n        start: n = 0,\n        end: o = s - 1\n      } = i,\n      {\n        start: a,\n        end: r\n      } = e,\n      l = Math.max(n, a),\n      h = Math.min(o, r),\n      c = n < a && o < a || n > r && o > r;\n    return {\n      count: s,\n      start: l,\n      loop: e.loop,\n      ilen: h < l && !c ? s + h - l : h - l\n    };\n  }\n  function Kn(t, e, i, s) {\n    const {\n        points: n,\n        options: o\n      } = e,\n      {\n        count: a,\n        start: r,\n        loop: l,\n        ilen: h\n      } = qn(n, i, s),\n      c = function (t) {\n        return t.stepped ? Oe : t.tension || \"monotone\" === t.cubicInterpolationMode ? Ce : Xn;\n      }(o);\n    let d,\n      u,\n      f,\n      {\n        move: g = !0,\n        reverse: p\n      } = s || {};\n    for (d = 0; d <= h; ++d) u = n[(r + (p ? h - d : d)) % a], u.skip || (g ? (t.moveTo(u.x, u.y), g = !1) : c(t, f, u, p, o.stepped), f = u);\n    return l && (u = n[(r + (p ? h : 0)) % a], c(t, f, u, p, o.stepped)), !!l;\n  }\n  function Gn(t, e, i, s) {\n    const n = e.points,\n      {\n        count: o,\n        start: a,\n        ilen: r\n      } = qn(n, i, s),\n      {\n        move: l = !0,\n        reverse: h\n      } = s || {};\n    let c,\n      d,\n      u,\n      f,\n      g,\n      p,\n      m = 0,\n      b = 0;\n    const x = t => (a + (h ? r - t : t)) % o,\n      _ = () => {\n        f !== g && (t.lineTo(m, g), t.lineTo(m, f), t.lineTo(m, p));\n      };\n    for (l && (d = n[x(0)], t.moveTo(d.x, d.y)), c = 0; c <= r; ++c) {\n      if (d = n[x(c)], d.skip) continue;\n      const e = d.x,\n        i = d.y,\n        s = 0 | e;\n      s === u ? (i < f ? f = i : i > g && (g = i), m = (b * m + e) / ++b) : (_(), t.lineTo(e, i), u = s, b = 0, f = g = i), p = i;\n    }\n    _();\n  }\n  function Zn(t) {\n    const e = t.options,\n      i = e.borderDash && e.borderDash.length;\n    return !(t._decimated || t._loop || e.tension || \"monotone\" === e.cubicInterpolationMode || e.stepped || i) ? Gn : Kn;\n  }\n  Yn.id = \"arc\", Yn.defaults = {\n    borderAlign: \"center\",\n    borderColor: \"#fff\",\n    borderJoinStyle: void 0,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: void 0,\n    circular: !0\n  }, Yn.defaultRoutes = {\n    backgroundColor: \"backgroundColor\"\n  };\n  const Jn = \"function\" == typeof Path2D;\n  function Qn(t, e, i, s) {\n    Jn && !e.options.segment ? function (t, e, i, s) {\n      let n = e._path;\n      n || (n = e._path = new Path2D(), e.path(n, i, s) && n.closePath()), Un(t, e.options), t.stroke(n);\n    }(t, e, i, s) : function (t, e, i, s) {\n      const {\n          segments: n,\n          options: o\n        } = e,\n        a = Zn(e);\n      for (const r of n) Un(t, o, r.style), t.beginPath(), a(t, e, r, {\n        start: i,\n        end: i + s - 1\n      }) && t.closePath(), t.stroke();\n    }(t, e, i, s);\n  }\n  class to extends Es {\n    constructor(t) {\n      super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);\n    }\n    updateControlPoints(t, e) {\n      const i = this.options;\n      if ((i.tension || \"monotone\" === i.cubicInterpolationMode) && !i.stepped && !this._pointsUpdated) {\n        const s = i.spanGaps ? this._loop : this._fullLoop;\n        Qe(this._points, i, t, s, e), this._pointsUpdated = !0;\n      }\n    }\n    set points(t) {\n      this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;\n    }\n    get points() {\n      return this._points;\n    }\n    get segments() {\n      return this._segments || (this._segments = Di(this, this.options.segment));\n    }\n    first() {\n      const t = this.segments,\n        e = this.points;\n      return t.length && e[t[0].start];\n    }\n    last() {\n      const t = this.segments,\n        e = this.points,\n        i = t.length;\n      return i && e[t[i - 1].end];\n    }\n    interpolate(t, e) {\n      const i = this.options,\n        s = t[e],\n        n = this.points,\n        o = Pi(this, {\n          property: e,\n          start: s,\n          end: s\n        });\n      if (!o.length) return;\n      const a = [],\n        r = function (t) {\n          return t.stepped ? oi : t.tension || \"monotone\" === t.cubicInterpolationMode ? ai : ni;\n        }(i);\n      let l, h;\n      for (l = 0, h = o.length; l < h; ++l) {\n        const {\n            start: h,\n            end: c\n          } = o[l],\n          d = n[h],\n          u = n[c];\n        if (d === u) {\n          a.push(d);\n          continue;\n        }\n        const f = r(d, u, Math.abs((s - d[e]) / (u[e] - d[e])), i.stepped);\n        f[e] = t[e], a.push(f);\n      }\n      return 1 === a.length ? a[0] : a;\n    }\n    pathSegment(t, e, i) {\n      return Zn(this)(t, this, e, i);\n    }\n    path(t, e, i) {\n      const s = this.segments,\n        n = Zn(this);\n      let o = this._loop;\n      e = e || 0, i = i || this.points.length - e;\n      for (const a of s) o &= n(t, this, a, {\n        start: e,\n        end: e + i - 1\n      });\n      return !!o;\n    }\n    draw(t, e, i, s) {\n      const n = this.options || {};\n      (this.points || []).length && n.borderWidth && (t.save(), Qn(t, this, i, s), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);\n    }\n  }\n  function eo(t, e, i, s) {\n    const n = t.options,\n      {\n        [i]: o\n      } = t.getProps([i], s);\n    return Math.abs(e - o) < n.radius + n.hitRadius;\n  }\n  to.id = \"line\", to.defaults = {\n    borderCapStyle: \"butt\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: \"miter\",\n    borderWidth: 3,\n    capBezierPoints: !0,\n    cubicInterpolationMode: \"default\",\n    fill: !1,\n    spanGaps: !1,\n    stepped: !1,\n    tension: 0\n  }, to.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n  }, to.descriptors = {\n    _scriptable: !0,\n    _indexable: t => \"borderDash\" !== t && \"fill\" !== t\n  };\n  class io extends Es {\n    constructor(t) {\n      super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);\n    }\n    inRange(t, e, i) {\n      const s = this.options,\n        {\n          x: n,\n          y: o\n        } = this.getProps([\"x\", \"y\"], i);\n      return Math.pow(t - n, 2) + Math.pow(e - o, 2) < Math.pow(s.hitRadius + s.radius, 2);\n    }\n    inXRange(t, e) {\n      return eo(this, t, \"x\", e);\n    }\n    inYRange(t, e) {\n      return eo(this, t, \"y\", e);\n    }\n    getCenterPoint(t) {\n      const {\n        x: e,\n        y: i\n      } = this.getProps([\"x\", \"y\"], t);\n      return {\n        x: e,\n        y: i\n      };\n    }\n    size(t) {\n      let e = (t = t || this.options || {}).radius || 0;\n      e = Math.max(e, e && t.hoverRadius || 0);\n      return 2 * (e + (e && t.borderWidth || 0));\n    }\n    draw(t, e) {\n      const i = this.options;\n      this.skip || i.radius < .1 || !Se(this, e, this.size(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, Me(t, i, this.x, this.y));\n    }\n    getRange() {\n      const t = this.options || {};\n      return t.radius + t.hitRadius;\n    }\n  }\n  function so(t, e) {\n    const {\n      x: i,\n      y: s,\n      base: n,\n      width: o,\n      height: a\n    } = t.getProps([\"x\", \"y\", \"base\", \"width\", \"height\"], e);\n    let r, l, h, c, d;\n    return t.horizontal ? (d = a / 2, r = Math.min(i, n), l = Math.max(i, n), h = s - d, c = s + d) : (d = o / 2, r = i - d, l = i + d, h = Math.min(s, n), c = Math.max(s, n)), {\n      left: r,\n      top: h,\n      right: l,\n      bottom: c\n    };\n  }\n  function no(t, e, i, s) {\n    return t ? 0 : Z(e, i, s);\n  }\n  function oo(t) {\n    const e = so(t),\n      i = e.right - e.left,\n      s = e.bottom - e.top,\n      o = function (t, e, i) {\n        const s = t.options.borderWidth,\n          n = t.borderSkipped,\n          o = fi(s);\n        return {\n          t: no(n.top, o.top, 0, i),\n          r: no(n.right, o.right, 0, e),\n          b: no(n.bottom, o.bottom, 0, i),\n          l: no(n.left, o.left, 0, e)\n        };\n      }(t, i / 2, s / 2),\n      a = function (t, e, i) {\n        const {\n            enableBorderRadius: s\n          } = t.getProps([\"enableBorderRadius\"]),\n          o = t.options.borderRadius,\n          a = gi(o),\n          r = Math.min(e, i),\n          l = t.borderSkipped,\n          h = s || n(o);\n        return {\n          topLeft: no(!h || l.top || l.left, a.topLeft, 0, r),\n          topRight: no(!h || l.top || l.right, a.topRight, 0, r),\n          bottomLeft: no(!h || l.bottom || l.left, a.bottomLeft, 0, r),\n          bottomRight: no(!h || l.bottom || l.right, a.bottomRight, 0, r)\n        };\n      }(t, i / 2, s / 2);\n    return {\n      outer: {\n        x: e.left,\n        y: e.top,\n        w: i,\n        h: s,\n        radius: a\n      },\n      inner: {\n        x: e.left + o.l,\n        y: e.top + o.t,\n        w: i - o.l - o.r,\n        h: s - o.t - o.b,\n        radius: {\n          topLeft: Math.max(0, a.topLeft - Math.max(o.t, o.l)),\n          topRight: Math.max(0, a.topRight - Math.max(o.t, o.r)),\n          bottomLeft: Math.max(0, a.bottomLeft - Math.max(o.b, o.l)),\n          bottomRight: Math.max(0, a.bottomRight - Math.max(o.b, o.r))\n        }\n      }\n    };\n  }\n  function ao(t, e, i, s) {\n    const n = null === e,\n      o = null === i,\n      a = t && !(n && o) && so(t, s);\n    return a && (n || Q(e, a.left, a.right)) && (o || Q(i, a.top, a.bottom));\n  }\n  function ro(t, e) {\n    t.rect(e.x, e.y, e.w, e.h);\n  }\n  function lo(t, e) {\n    let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const s = t.x !== i.x ? -e : 0,\n      n = t.y !== i.y ? -e : 0,\n      o = (t.x + t.w !== i.x + i.w ? e : 0) - s,\n      a = (t.y + t.h !== i.y + i.h ? e : 0) - n;\n    return {\n      x: t.x + s,\n      y: t.y + n,\n      w: t.w + o,\n      h: t.h + a,\n      radius: t.radius\n    };\n  }\n  io.id = \"point\", io.defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: \"circle\",\n    radius: 3,\n    rotation: 0\n  }, io.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n  };\n  class ho extends Es {\n    constructor(t) {\n      super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);\n    }\n    draw(t) {\n      const {\n          inflateAmount: e,\n          options: {\n            borderColor: i,\n            backgroundColor: s\n          }\n        } = this,\n        {\n          inner: n,\n          outer: o\n        } = oo(this),\n        a = (r = o.radius).topLeft || r.topRight || r.bottomLeft || r.bottomRight ? Le : ro;\n      var r;\n      t.save(), o.w === n.w && o.h === n.h || (t.beginPath(), a(t, lo(o, e, n)), t.clip(), a(t, lo(n, -e, o)), t.fillStyle = i, t.fill(\"evenodd\")), t.beginPath(), a(t, lo(n, e)), t.fillStyle = s, t.fill(), t.restore();\n    }\n    inRange(t, e, i) {\n      return ao(this, t, e, i);\n    }\n    inXRange(t, e) {\n      return ao(this, t, null, e);\n    }\n    inYRange(t, e) {\n      return ao(this, null, t, e);\n    }\n    getCenterPoint(t) {\n      const {\n        x: e,\n        y: i,\n        base: s,\n        horizontal: n\n      } = this.getProps([\"x\", \"y\", \"base\", \"horizontal\"], t);\n      return {\n        x: n ? (e + s) / 2 : e,\n        y: n ? i : (i + s) / 2\n      };\n    }\n    getRange(t) {\n      return \"x\" === t ? this.width / 2 : this.height / 2;\n    }\n  }\n  ho.id = \"bar\", ho.defaults = {\n    borderSkipped: \"start\",\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: \"auto\",\n    pointStyle: void 0\n  }, ho.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n  };\n  var co = Object.freeze({\n    __proto__: null,\n    ArcElement: Yn,\n    LineElement: to,\n    PointElement: io,\n    BarElement: ho\n  });\n  function uo(t) {\n    if (t._decimated) {\n      const e = t._data;\n      delete t._decimated, delete t._data, Object.defineProperty(t, \"data\", {\n        value: e\n      });\n    }\n  }\n  function fo(t) {\n    t.data.datasets.forEach(t => {\n      uo(t);\n    });\n  }\n  var go = {\n    id: \"decimation\",\n    defaults: {\n      algorithm: \"min-max\",\n      enabled: !1\n    },\n    beforeElementsUpdate: (t, e, s) => {\n      if (!s.enabled) return void fo(t);\n      const n = t.width;\n      t.data.datasets.forEach((e, o) => {\n        const {\n            _data: a,\n            indexAxis: r\n          } = e,\n          l = t.getDatasetMeta(o),\n          h = a || e.data;\n        if (\"y\" === bi([r, t.options.indexAxis])) return;\n        if (!l.controller.supportsDecimation) return;\n        const c = t.scales[l.xAxisID];\n        if (\"linear\" !== c.type && \"time\" !== c.type) return;\n        if (t.options.parsing) return;\n        let {\n          start: d,\n          count: u\n        } = function (t, e) {\n          const i = e.length;\n          let s,\n            n = 0;\n          const {\n              iScale: o\n            } = t,\n            {\n              min: a,\n              max: r,\n              minDefined: l,\n              maxDefined: h\n            } = o.getUserBounds();\n          return l && (n = Z(et(e, o.axis, a).lo, 0, i - 1)), s = h ? Z(et(e, o.axis, r).hi + 1, n, i) - n : i - n, {\n            start: n,\n            count: s\n          };\n        }(l, h);\n        if (u <= (s.threshold || 4 * n)) return void uo(e);\n        let f;\n        switch (i(a) && (e._data = h, delete e.data, Object.defineProperty(e, \"data\", {\n          configurable: !0,\n          enumerable: !0,\n          get: function get() {\n            return this._decimated;\n          },\n          set: function set(t) {\n            this._data = t;\n          }\n        })), s.algorithm) {\n          case \"lttb\":\n            f = function (t, e, i, s, n) {\n              const o = n.samples || s;\n              if (o >= i) return t.slice(e, e + i);\n              const a = [],\n                r = (i - 2) / (o - 2);\n              let l = 0;\n              const h = e + i - 1;\n              let c,\n                d,\n                u,\n                f,\n                g,\n                p = e;\n              for (a[l++] = t[p], c = 0; c < o - 2; c++) {\n                let s,\n                  n = 0,\n                  o = 0;\n                const h = Math.floor((c + 1) * r) + 1 + e,\n                  m = Math.min(Math.floor((c + 2) * r) + 1, i) + e,\n                  b = m - h;\n                for (s = h; s < m; s++) n += t[s].x, o += t[s].y;\n                n /= b, o /= b;\n                const x = Math.floor(c * r) + 1 + e,\n                  _ = Math.min(Math.floor((c + 1) * r) + 1, i) + e,\n                  {\n                    x: y,\n                    y: v\n                  } = t[p];\n                for (u = f = -1, s = x; s < _; s++) f = .5 * Math.abs((y - n) * (t[s].y - v) - (y - t[s].x) * (o - v)), f > u && (u = f, d = t[s], g = s);\n                a[l++] = d, p = g;\n              }\n              return a[l++] = t[h], a;\n            }(h, d, u, n, s);\n            break;\n          case \"min-max\":\n            f = function (t, e, s, n) {\n              let o,\n                a,\n                r,\n                l,\n                h,\n                c,\n                d,\n                u,\n                f,\n                g,\n                p = 0,\n                m = 0;\n              const b = [],\n                x = e + s - 1,\n                _ = t[e].x,\n                y = t[x].x - _;\n              for (o = e; o < e + s; ++o) {\n                a = t[o], r = (a.x - _) / y * n, l = a.y;\n                const e = 0 | r;\n                if (e === h) l < f ? (f = l, c = o) : l > g && (g = l, d = o), p = (m * p + a.x) / ++m;else {\n                  const s = o - 1;\n                  if (!i(c) && !i(d)) {\n                    const e = Math.min(c, d),\n                      i = Math.max(c, d);\n                    e !== u && e !== s && b.push(_objectSpread(_objectSpread({}, t[e]), {}, {\n                      x: p\n                    })), i !== u && i !== s && b.push(_objectSpread(_objectSpread({}, t[i]), {}, {\n                      x: p\n                    }));\n                  }\n                  o > 0 && s !== u && b.push(t[s]), b.push(a), h = e, m = 0, f = g = l, c = d = u = o;\n                }\n              }\n              return b;\n            }(h, d, u, n);\n            break;\n          default:\n            throw new Error(\"Unsupported decimation algorithm '\".concat(s.algorithm, \"'\"));\n        }\n        e._decimated = f;\n      });\n    },\n    destroy(t) {\n      fo(t);\n    }\n  };\n  function po(t, e, i, s) {\n    if (s) return;\n    let n = e[t],\n      o = i[t];\n    return \"angle\" === t && (n = K(n), o = K(o)), {\n      property: t,\n      start: n,\n      end: o\n    };\n  }\n  function mo(t, e, i) {\n    for (; e > t; e--) {\n      const t = i[e];\n      if (!isNaN(t.x) && !isNaN(t.y)) break;\n    }\n    return e;\n  }\n  function bo(t, e, i, s) {\n    return t && e ? s(t[i], e[i]) : t ? t[i] : e ? e[i] : 0;\n  }\n  function xo(t, e) {\n    let i = [],\n      n = !1;\n    return s(t) ? (n = !0, i = t) : i = function (t, e) {\n      const {\n          x: i = null,\n          y: s = null\n        } = t || {},\n        n = e.points,\n        o = [];\n      return e.segments.forEach(_ref6 => {\n        let {\n          start: t,\n          end: e\n        } = _ref6;\n        e = mo(t, e, n);\n        const a = n[t],\n          r = n[e];\n        null !== s ? (o.push({\n          x: a.x,\n          y: s\n        }), o.push({\n          x: r.x,\n          y: s\n        })) : null !== i && (o.push({\n          x: i,\n          y: a.y\n        }), o.push({\n          x: i,\n          y: r.y\n        }));\n      }), o;\n    }(t, e), i.length ? new to({\n      points: i,\n      options: {\n        tension: 0\n      },\n      _loop: n,\n      _fullLoop: n\n    }) : null;\n  }\n  function _o(t) {\n    return t && !1 !== t.fill;\n  }\n  function yo(t, e, i) {\n    let s = t[e].fill;\n    const n = [e];\n    let a;\n    if (!i) return s;\n    for (; !1 !== s && -1 === n.indexOf(s);) {\n      if (!o(s)) return s;\n      if (a = t[s], !a) return !1;\n      if (a.visible) return s;\n      n.push(s), s = a.fill;\n    }\n    return !1;\n  }\n  function vo(t, e, i) {\n    const s = function (t) {\n      const e = t.options,\n        i = e.fill;\n      let s = r(i && i.target, i);\n      void 0 === s && (s = !!e.backgroundColor);\n      if (!1 === s || null === s) return !1;\n      if (!0 === s) return \"origin\";\n      return s;\n    }(t);\n    if (n(s)) return !isNaN(s.value) && s;\n    let a = parseFloat(s);\n    return o(a) && Math.floor(a) === a ? function (t, e, i, s) {\n      \"-\" !== t && \"+\" !== t || (i = e + i);\n      if (i === e || i < 0 || i >= s) return !1;\n      return i;\n    }(s[0], e, a, i) : [\"origin\", \"start\", \"end\", \"stack\", \"shape\"].indexOf(s) >= 0 && s;\n  }\n  function wo(t, e, i) {\n    const s = [];\n    for (let n = 0; n < i.length; n++) {\n      const o = i[n],\n        {\n          first: a,\n          last: r,\n          point: l\n        } = Mo(o, e, \"x\");\n      if (!(!l || a && r)) if (a) s.unshift(l);else if (t.push(l), !r) break;\n    }\n    t.push(...s);\n  }\n  function Mo(t, e, i) {\n    const s = t.interpolate(e, i);\n    if (!s) return {};\n    const n = s[i],\n      o = t.segments,\n      a = t.points;\n    let r = !1,\n      l = !1;\n    for (let t = 0; t < o.length; t++) {\n      const e = o[t],\n        s = a[e.start][i],\n        h = a[e.end][i];\n      if (Q(n, s, h)) {\n        r = n === s, l = n === h;\n        break;\n      }\n    }\n    return {\n      first: r,\n      last: l,\n      point: s\n    };\n  }\n  class ko {\n    constructor(t) {\n      this.x = t.x, this.y = t.y, this.radius = t.radius;\n    }\n    pathSegment(t, e, i) {\n      const {\n        x: s,\n        y: n,\n        radius: o\n      } = this;\n      return e = e || {\n        start: 0,\n        end: O\n      }, t.arc(s, n, o, e.end, e.start, !0), !i.bounds;\n    }\n    interpolate(t) {\n      const {\n          x: e,\n          y: i,\n          radius: s\n        } = this,\n        n = t.angle;\n      return {\n        x: e + Math.cos(n) * s,\n        y: i + Math.sin(n) * s,\n        angle: n\n      };\n    }\n  }\n  function So(t) {\n    const {\n      chart: e,\n      fill: i,\n      line: s\n    } = t;\n    if (o(i)) return function (t, e) {\n      const i = t.getDatasetMeta(e);\n      return i && t.isDatasetVisible(e) ? i.dataset : null;\n    }(e, i);\n    if (\"stack\" === i) return function (t) {\n      const {\n          scale: e,\n          index: i,\n          line: s\n        } = t,\n        n = [],\n        o = s.segments,\n        a = s.points,\n        r = function (t, e) {\n          const i = [],\n            s = t.getMatchingVisibleMetas(\"line\");\n          for (let t = 0; t < s.length; t++) {\n            const n = s[t];\n            if (n.index === e) break;\n            n.hidden || i.unshift(n.dataset);\n          }\n          return i;\n        }(e, i);\n      r.push(xo({\n        x: null,\n        y: e.bottom\n      }, s));\n      for (let t = 0; t < o.length; t++) {\n        const e = o[t];\n        for (let t = e.start; t <= e.end; t++) wo(n, a[t], r);\n      }\n      return new to({\n        points: n,\n        options: {}\n      });\n    }(t);\n    if (\"shape\" === i) return !0;\n    const a = function (t) {\n      if ((t.scale || {}).getPointPositionForValue) return function (t) {\n        const {\n            scale: e,\n            fill: i\n          } = t,\n          s = e.options,\n          o = e.getLabels().length,\n          a = s.reverse ? e.max : e.min,\n          r = function (t, e, i) {\n            let s;\n            return s = \"start\" === t ? i : \"end\" === t ? e.options.reverse ? e.min : e.max : n(t) ? t.value : e.getBaseValue(), s;\n          }(i, e, a),\n          l = [];\n        if (s.grid.circular) {\n          const t = e.getPointPositionForValue(0, a);\n          return new ko({\n            x: t.x,\n            y: t.y,\n            radius: e.getDistanceFromCenterForValue(r)\n          });\n        }\n        for (let t = 0; t < o; ++t) l.push(e.getPointPositionForValue(t, r));\n        return l;\n      }(t);\n      return function (t) {\n        const {\n            scale: e = {},\n            fill: i\n          } = t,\n          s = function (t, e) {\n            let i = null;\n            return \"start\" === t ? i = e.bottom : \"end\" === t ? i = e.top : n(t) ? i = e.getPixelForValue(t.value) : e.getBasePixel && (i = e.getBasePixel()), i;\n          }(i, e);\n        if (o(s)) {\n          const t = e.isHorizontal();\n          return {\n            x: t ? s : null,\n            y: t ? null : s\n          };\n        }\n        return null;\n      }(t);\n    }(t);\n    return a instanceof ko ? a : xo(a, s);\n  }\n  function Po(t, e, i) {\n    const s = So(e),\n      {\n        line: n,\n        scale: o,\n        axis: a\n      } = e,\n      r = n.options,\n      l = r.fill,\n      h = r.backgroundColor,\n      {\n        above: c = h,\n        below: d = h\n      } = l || {};\n    s && n.points.length && (Pe(t, i), function (t, e) {\n      const {\n          line: i,\n          target: s,\n          above: n,\n          below: o,\n          area: a,\n          scale: r\n        } = e,\n        l = i._loop ? \"angle\" : e.axis;\n      t.save(), \"x\" === l && o !== n && (Do(t, s, a.top), Oo(t, {\n        line: i,\n        target: s,\n        color: n,\n        scale: r,\n        property: l\n      }), t.restore(), t.save(), Do(t, s, a.bottom));\n      Oo(t, {\n        line: i,\n        target: s,\n        color: o,\n        scale: r,\n        property: l\n      }), t.restore();\n    }(t, {\n      line: n,\n      target: s,\n      above: c,\n      below: d,\n      area: i,\n      scale: o,\n      axis: a\n    }), De(t));\n  }\n  function Do(t, e, i) {\n    const {\n      segments: s,\n      points: n\n    } = e;\n    let o = !0,\n      a = !1;\n    t.beginPath();\n    for (const r of s) {\n      const {\n          start: s,\n          end: l\n        } = r,\n        h = n[s],\n        c = n[mo(s, l, n)];\n      o ? (t.moveTo(h.x, h.y), o = !1) : (t.lineTo(h.x, i), t.lineTo(h.x, h.y)), a = !!e.pathSegment(t, r, {\n        move: a\n      }), a ? t.closePath() : t.lineTo(c.x, i);\n    }\n    t.lineTo(e.first().x, i), t.closePath(), t.clip();\n  }\n  function Oo(t, e) {\n    const {\n        line: i,\n        target: s,\n        property: n,\n        color: o,\n        scale: a\n      } = e,\n      r = function (t, e, i) {\n        const s = t.segments,\n          n = t.points,\n          o = e.points,\n          a = [];\n        for (const t of s) {\n          let {\n            start: s,\n            end: r\n          } = t;\n          r = mo(s, r, n);\n          const l = po(i, n[s], n[r], t.loop);\n          if (!e.segments) {\n            a.push({\n              source: t,\n              target: l,\n              start: n[s],\n              end: n[r]\n            });\n            continue;\n          }\n          const h = Pi(e, l);\n          for (const e of h) {\n            const s = po(i, o[e.start], o[e.end], e.loop),\n              r = Si(t, n, s);\n            for (const t of r) a.push({\n              source: t,\n              target: e,\n              start: {\n                [i]: bo(l, s, \"start\", Math.max)\n              },\n              end: {\n                [i]: bo(l, s, \"end\", Math.min)\n              }\n            });\n          }\n        }\n        return a;\n      }(i, s, n);\n    for (const {\n      source: e,\n      target: l,\n      start: h,\n      end: c\n    } of r) {\n      const {\n          style: {\n            backgroundColor: r = o\n          } = {}\n        } = e,\n        d = !0 !== s;\n      t.save(), t.fillStyle = r, Co(t, a, d && po(n, h, c)), t.beginPath();\n      const u = !!i.pathSegment(t, e);\n      let f;\n      if (d) {\n        u ? t.closePath() : Ao(t, s, c, n);\n        const e = !!s.pathSegment(t, l, {\n          move: u,\n          reverse: !0\n        });\n        f = u && e, f || Ao(t, s, h, n);\n      }\n      t.closePath(), t.fill(f ? \"evenodd\" : \"nonzero\"), t.restore();\n    }\n  }\n  function Co(t, e, i) {\n    const {\n        top: s,\n        bottom: n\n      } = e.chart.chartArea,\n      {\n        property: o,\n        start: a,\n        end: r\n      } = i || {};\n    \"x\" === o && (t.beginPath(), t.rect(a, s, r - a, n - s), t.clip());\n  }\n  function Ao(t, e, i, s) {\n    const n = e.interpolate(i, s);\n    n && t.lineTo(n.x, n.y);\n  }\n  var To = {\n    id: \"filler\",\n    afterDatasetsUpdate(t, e, i) {\n      const s = (t.data.datasets || []).length,\n        n = [];\n      let o, a, r, l;\n      for (a = 0; a < s; ++a) o = t.getDatasetMeta(a), r = o.dataset, l = null, r && r.options && r instanceof to && (l = {\n        visible: t.isDatasetVisible(a),\n        index: a,\n        fill: vo(r, a, s),\n        chart: t,\n        axis: o.controller.options.indexAxis,\n        scale: o.vScale,\n        line: r\n      }), o.$filler = l, n.push(l);\n      for (a = 0; a < s; ++a) l = n[a], l && !1 !== l.fill && (l.fill = yo(n, a, i.propagate));\n    },\n    beforeDraw(t, e, i) {\n      const s = \"beforeDraw\" === i.drawTime,\n        n = t.getSortedVisibleDatasetMetas(),\n        o = t.chartArea;\n      for (let e = n.length - 1; e >= 0; --e) {\n        const i = n[e].$filler;\n        i && (i.line.updateControlPoints(o, i.axis), s && i.fill && Po(t.ctx, i, o));\n      }\n    },\n    beforeDatasetsDraw(t, e, i) {\n      if (\"beforeDatasetsDraw\" !== i.drawTime) return;\n      const s = t.getSortedVisibleDatasetMetas();\n      for (let e = s.length - 1; e >= 0; --e) {\n        const i = s[e].$filler;\n        _o(i) && Po(t.ctx, i, t.chartArea);\n      }\n    },\n    beforeDatasetDraw(t, e, i) {\n      const s = e.meta.$filler;\n      _o(s) && \"beforeDatasetDraw\" === i.drawTime && Po(t.ctx, s, t.chartArea);\n    },\n    defaults: {\n      propagate: !0,\n      drawTime: \"beforeDatasetDraw\"\n    }\n  };\n  const Lo = (t, e) => {\n    let {\n      boxHeight: i = e,\n      boxWidth: s = e\n    } = t;\n    return t.usePointStyle && (i = Math.min(i, e), s = t.pointStyleWidth || Math.min(s, e)), {\n      boxWidth: s,\n      boxHeight: i,\n      itemHeight: Math.max(e, i)\n    };\n  };\n  class Eo extends Es {\n    constructor(t) {\n      super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;\n    }\n    update(t, e, i) {\n      this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit();\n    }\n    setDimensions() {\n      this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);\n    }\n    buildLabels() {\n      const t = this.options.labels || {};\n      let e = c(t.generateLabels, [this.chart], this) || [];\n      t.filter && (e = e.filter(e => t.filter(e, this.chart.data))), t.sort && (e = e.sort((e, i) => t.sort(e, i, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e;\n    }\n    fit() {\n      const {\n        options: t,\n        ctx: e\n      } = this;\n      if (!t.display) return void (this.width = this.height = 0);\n      const i = t.labels,\n        s = mi(i.font),\n        n = s.size,\n        o = this._computeTitleHeight(),\n        {\n          boxWidth: a,\n          itemHeight: r\n        } = Lo(i, n);\n      let l, h;\n      e.font = s.string, this.isHorizontal() ? (l = this.maxWidth, h = this._fitRows(o, n, a, r) + 10) : (h = this.maxHeight, l = this._fitCols(o, n, a, r) + 10), this.width = Math.min(l, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight);\n    }\n    _fitRows(t, e, i, s) {\n      const {\n          ctx: n,\n          maxWidth: o,\n          options: {\n            labels: {\n              padding: a\n            }\n          }\n        } = this,\n        r = this.legendHitBoxes = [],\n        l = this.lineWidths = [0],\n        h = s + a;\n      let c = t;\n      n.textAlign = \"left\", n.textBaseline = \"middle\";\n      let d = -1,\n        u = -h;\n      return this.legendItems.forEach((t, f) => {\n        const g = i + e / 2 + n.measureText(t.text).width;\n        (0 === f || l[l.length - 1] + g + 2 * a > o) && (c += h, l[l.length - (f > 0 ? 0 : 1)] = 0, u += h, d++), r[f] = {\n          left: 0,\n          top: u,\n          row: d,\n          width: g,\n          height: s\n        }, l[l.length - 1] += g + a;\n      }), c;\n    }\n    _fitCols(t, e, i, s) {\n      const {\n          ctx: n,\n          maxHeight: o,\n          options: {\n            labels: {\n              padding: a\n            }\n          }\n        } = this,\n        r = this.legendHitBoxes = [],\n        l = this.columnSizes = [],\n        h = o - t;\n      let c = a,\n        d = 0,\n        u = 0,\n        f = 0,\n        g = 0;\n      return this.legendItems.forEach((t, o) => {\n        const p = i + e / 2 + n.measureText(t.text).width;\n        o > 0 && u + s + 2 * a > h && (c += d + a, l.push({\n          width: d,\n          height: u\n        }), f += d + a, g++, d = u = 0), r[o] = {\n          left: f,\n          top: u,\n          col: g,\n          width: p,\n          height: s\n        }, d = Math.max(d, p), u += s + a;\n      }), c += d, l.push({\n        width: d,\n        height: u\n      }), c;\n    }\n    adjustHitBoxes() {\n      if (!this.options.display) return;\n      const t = this._computeTitleHeight(),\n        {\n          legendHitBoxes: e,\n          options: {\n            align: i,\n            labels: {\n              padding: s\n            },\n            rtl: n\n          }\n        } = this,\n        o = yi(n, this.left, this.width);\n      if (this.isHorizontal()) {\n        let n = 0,\n          a = ut(i, this.left + s, this.right - this.lineWidths[n]);\n        for (const r of e) n !== r.row && (n = r.row, a = ut(i, this.left + s, this.right - this.lineWidths[n])), r.top += this.top + t + s, r.left = o.leftForLtr(o.x(a), r.width), a += r.width + s;\n      } else {\n        let n = 0,\n          a = ut(i, this.top + t + s, this.bottom - this.columnSizes[n].height);\n        for (const r of e) r.col !== n && (n = r.col, a = ut(i, this.top + t + s, this.bottom - this.columnSizes[n].height)), r.top = a, r.left += this.left + s, r.left = o.leftForLtr(o.x(r.left), r.width), a += r.height + s;\n      }\n    }\n    isHorizontal() {\n      return \"top\" === this.options.position || \"bottom\" === this.options.position;\n    }\n    draw() {\n      if (this.options.display) {\n        const t = this.ctx;\n        Pe(t, this), this._draw(), De(t);\n      }\n    }\n    _draw() {\n      const {\n          options: t,\n          columnSizes: e,\n          lineWidths: i,\n          ctx: s\n        } = this,\n        {\n          align: n,\n          labels: o\n        } = t,\n        a = ne.color,\n        l = yi(t.rtl, this.left, this.width),\n        h = mi(o.font),\n        {\n          color: c,\n          padding: d\n        } = o,\n        u = h.size,\n        f = u / 2;\n      let g;\n      this.drawTitle(), s.textAlign = l.textAlign(\"left\"), s.textBaseline = \"middle\", s.lineWidth = .5, s.font = h.string;\n      const {\n          boxWidth: p,\n          boxHeight: m,\n          itemHeight: b\n        } = Lo(o, u),\n        x = this.isHorizontal(),\n        _ = this._computeTitleHeight();\n      g = x ? {\n        x: ut(n, this.left + d, this.right - i[0]),\n        y: this.top + d + _,\n        line: 0\n      } : {\n        x: this.left + d,\n        y: ut(n, this.top + _ + d, this.bottom - e[0].height),\n        line: 0\n      }, vi(this.ctx, t.textDirection);\n      const y = b + d;\n      this.legendItems.forEach((v, w) => {\n        s.strokeStyle = v.fontColor || c, s.fillStyle = v.fontColor || c;\n        const M = s.measureText(v.text).width,\n          k = l.textAlign(v.textAlign || (v.textAlign = o.textAlign)),\n          S = p + f + M;\n        let P = g.x,\n          D = g.y;\n        l.setWidth(this.width), x ? w > 0 && P + S + d > this.right && (D = g.y += y, g.line++, P = g.x = ut(n, this.left + d, this.right - i[g.line])) : w > 0 && D + y > this.bottom && (P = g.x = P + e[g.line].width + d, g.line++, D = g.y = ut(n, this.top + _ + d, this.bottom - e[g.line].height));\n        !function (t, e, i) {\n          if (isNaN(p) || p <= 0 || isNaN(m) || m < 0) return;\n          s.save();\n          const n = r(i.lineWidth, 1);\n          if (s.fillStyle = r(i.fillStyle, a), s.lineCap = r(i.lineCap, \"butt\"), s.lineDashOffset = r(i.lineDashOffset, 0), s.lineJoin = r(i.lineJoin, \"miter\"), s.lineWidth = n, s.strokeStyle = r(i.strokeStyle, a), s.setLineDash(r(i.lineDash, [])), o.usePointStyle) {\n            const a = {\n                radius: m * Math.SQRT2 / 2,\n                pointStyle: i.pointStyle,\n                rotation: i.rotation,\n                borderWidth: n\n              },\n              r = l.xPlus(t, p / 2);\n            ke(s, a, r, e + f, o.pointStyleWidth && p);\n          } else {\n            const o = e + Math.max((u - m) / 2, 0),\n              a = l.leftForLtr(t, p),\n              r = gi(i.borderRadius);\n            s.beginPath(), Object.values(r).some(t => 0 !== t) ? Le(s, {\n              x: a,\n              y: o,\n              w: p,\n              h: m,\n              radius: r\n            }) : s.rect(a, o, p, m), s.fill(), 0 !== n && s.stroke();\n          }\n          s.restore();\n        }(l.x(P), D, v), P = ft(k, P + p + f, x ? P + S : this.right, t.rtl), function (t, e, i) {\n          Ae(s, i.text, t, e + b / 2, h, {\n            strikethrough: i.hidden,\n            textAlign: l.textAlign(i.textAlign)\n          });\n        }(l.x(P), D, v), x ? g.x += S + d : g.y += y;\n      }), wi(this.ctx, t.textDirection);\n    }\n    drawTitle() {\n      const t = this.options,\n        e = t.title,\n        i = mi(e.font),\n        s = pi(e.padding);\n      if (!e.display) return;\n      const n = yi(t.rtl, this.left, this.width),\n        o = this.ctx,\n        a = e.position,\n        r = i.size / 2,\n        l = s.top + r;\n      let h,\n        c = this.left,\n        d = this.width;\n      if (this.isHorizontal()) d = Math.max(...this.lineWidths), h = this.top + l, c = ut(t.align, c, this.right - d);else {\n        const e = this.columnSizes.reduce((t, e) => Math.max(t, e.height), 0);\n        h = l + ut(t.align, this.top, this.bottom - e - t.labels.padding - this._computeTitleHeight());\n      }\n      const u = ut(a, c, c + d);\n      o.textAlign = n.textAlign(dt(a)), o.textBaseline = \"middle\", o.strokeStyle = e.color, o.fillStyle = e.color, o.font = i.string, Ae(o, e.text, u, h, i);\n    }\n    _computeTitleHeight() {\n      const t = this.options.title,\n        e = mi(t.font),\n        i = pi(t.padding);\n      return t.display ? e.lineHeight + i.height : 0;\n    }\n    _getLegendItemAt(t, e) {\n      let i, s, n;\n      if (Q(t, this.left, this.right) && Q(e, this.top, this.bottom)) for (n = this.legendHitBoxes, i = 0; i < n.length; ++i) if (s = n[i], Q(t, s.left, s.left + s.width) && Q(e, s.top, s.top + s.height)) return this.legendItems[i];\n      return null;\n    }\n    handleEvent(t) {\n      const e = this.options;\n      if (!function (t, e) {\n        if ((\"mousemove\" === t || \"mouseout\" === t) && (e.onHover || e.onLeave)) return !0;\n        if (e.onClick && (\"click\" === t || \"mouseup\" === t)) return !0;\n        return !1;\n      }(t.type, e)) return;\n      const i = this._getLegendItemAt(t.x, t.y);\n      if (\"mousemove\" === t.type || \"mouseout\" === t.type) {\n        const o = this._hoveredItem,\n          a = (n = i, null !== (s = o) && null !== n && s.datasetIndex === n.datasetIndex && s.index === n.index);\n        o && !a && c(e.onLeave, [t, o, this], this), this._hoveredItem = i, i && !a && c(e.onHover, [t, i, this], this);\n      } else i && c(e.onClick, [t, i, this], this);\n      var s, n;\n    }\n  }\n  var Ro = {\n    id: \"legend\",\n    _element: Eo,\n    start(t, e, i) {\n      const s = t.legend = new Eo({\n        ctx: t.ctx,\n        options: i,\n        chart: t\n      });\n      Zi.configure(t, s, i), Zi.addBox(t, s);\n    },\n    stop(t) {\n      Zi.removeBox(t, t.legend), delete t.legend;\n    },\n    beforeUpdate(t, e, i) {\n      const s = t.legend;\n      Zi.configure(t, s, i), s.options = i;\n    },\n    afterUpdate(t) {\n      const e = t.legend;\n      e.buildLabels(), e.adjustHitBoxes();\n    },\n    afterEvent(t, e) {\n      e.replay || t.legend.handleEvent(e.event);\n    },\n    defaults: {\n      display: !0,\n      position: \"top\",\n      align: \"center\",\n      fullSize: !0,\n      reverse: !1,\n      weight: 1e3,\n      onClick(t, e, i) {\n        const s = e.datasetIndex,\n          n = i.chart;\n        n.isDatasetVisible(s) ? (n.hide(s), e.hidden = !0) : (n.show(s), e.hidden = !1);\n      },\n      onHover: null,\n      onLeave: null,\n      labels: {\n        color: t => t.chart.options.color,\n        boxWidth: 40,\n        padding: 10,\n        generateLabels(t) {\n          const e = t.data.datasets,\n            {\n              labels: {\n                usePointStyle: i,\n                pointStyle: s,\n                textAlign: n,\n                color: o\n              }\n            } = t.legend.options;\n          return t._getSortedDatasetMetas().map(t => {\n            const a = t.controller.getStyle(i ? 0 : void 0),\n              r = pi(a.borderWidth);\n            return {\n              text: e[t.index].label,\n              fillStyle: a.backgroundColor,\n              fontColor: o,\n              hidden: !t.visible,\n              lineCap: a.borderCapStyle,\n              lineDash: a.borderDash,\n              lineDashOffset: a.borderDashOffset,\n              lineJoin: a.borderJoinStyle,\n              lineWidth: (r.width + r.height) / 4,\n              strokeStyle: a.borderColor,\n              pointStyle: s || a.pointStyle,\n              rotation: a.rotation,\n              textAlign: n || a.textAlign,\n              borderRadius: 0,\n              datasetIndex: t.index\n            };\n          }, this);\n        }\n      },\n      title: {\n        color: t => t.chart.options.color,\n        display: !1,\n        position: \"center\",\n        text: \"\"\n      }\n    },\n    descriptors: {\n      _scriptable: t => !t.startsWith(\"on\"),\n      labels: {\n        _scriptable: t => ![\"generateLabels\", \"filter\", \"sort\"].includes(t)\n      }\n    }\n  };\n  class Io extends Es {\n    constructor(t) {\n      super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;\n    }\n    update(t, e) {\n      const i = this.options;\n      if (this.left = 0, this.top = 0, !i.display) return void (this.width = this.height = this.right = this.bottom = 0);\n      this.width = this.right = t, this.height = this.bottom = e;\n      const n = s(i.text) ? i.text.length : 1;\n      this._padding = pi(i.padding);\n      const o = n * mi(i.font).lineHeight + this._padding.height;\n      this.isHorizontal() ? this.height = o : this.width = o;\n    }\n    isHorizontal() {\n      const t = this.options.position;\n      return \"top\" === t || \"bottom\" === t;\n    }\n    _drawArgs(t) {\n      const {\n          top: e,\n          left: i,\n          bottom: s,\n          right: n,\n          options: o\n        } = this,\n        a = o.align;\n      let r,\n        l,\n        h,\n        c = 0;\n      return this.isHorizontal() ? (l = ut(a, i, n), h = e + t, r = n - i) : (\"left\" === o.position ? (l = i + t, h = ut(a, s, e), c = -.5 * D) : (l = n - t, h = ut(a, e, s), c = .5 * D), r = s - e), {\n        titleX: l,\n        titleY: h,\n        maxWidth: r,\n        rotation: c\n      };\n    }\n    draw() {\n      const t = this.ctx,\n        e = this.options;\n      if (!e.display) return;\n      const i = mi(e.font),\n        s = i.lineHeight / 2 + this._padding.top,\n        {\n          titleX: n,\n          titleY: o,\n          maxWidth: a,\n          rotation: r\n        } = this._drawArgs(s);\n      Ae(t, e.text, 0, 0, i, {\n        color: e.color,\n        maxWidth: a,\n        rotation: r,\n        textAlign: dt(e.align),\n        textBaseline: \"middle\",\n        translation: [n, o]\n      });\n    }\n  }\n  var zo = {\n    id: \"title\",\n    _element: Io,\n    start(t, e, i) {\n      !function (t, e) {\n        const i = new Io({\n          ctx: t.ctx,\n          options: e,\n          chart: t\n        });\n        Zi.configure(t, i, e), Zi.addBox(t, i), t.titleBlock = i;\n      }(t, i);\n    },\n    stop(t) {\n      const e = t.titleBlock;\n      Zi.removeBox(t, e), delete t.titleBlock;\n    },\n    beforeUpdate(t, e, i) {\n      const s = t.titleBlock;\n      Zi.configure(t, s, i), s.options = i;\n    },\n    defaults: {\n      align: \"center\",\n      display: !1,\n      font: {\n        weight: \"bold\"\n      },\n      fullSize: !0,\n      padding: 10,\n      position: \"top\",\n      text: \"\",\n      weight: 2e3\n    },\n    defaultRoutes: {\n      color: \"color\"\n    },\n    descriptors: {\n      _scriptable: !0,\n      _indexable: !1\n    }\n  };\n  const Fo = new WeakMap();\n  var Vo = {\n    id: \"subtitle\",\n    start(t, e, i) {\n      const s = new Io({\n        ctx: t.ctx,\n        options: i,\n        chart: t\n      });\n      Zi.configure(t, s, i), Zi.addBox(t, s), Fo.set(t, s);\n    },\n    stop(t) {\n      Zi.removeBox(t, Fo.get(t)), Fo.delete(t);\n    },\n    beforeUpdate(t, e, i) {\n      const s = Fo.get(t);\n      Zi.configure(t, s, i), s.options = i;\n    },\n    defaults: {\n      align: \"center\",\n      display: !1,\n      font: {\n        weight: \"normal\"\n      },\n      fullSize: !0,\n      padding: 0,\n      position: \"top\",\n      text: \"\",\n      weight: 1500\n    },\n    defaultRoutes: {\n      color: \"color\"\n    },\n    descriptors: {\n      _scriptable: !0,\n      _indexable: !1\n    }\n  };\n  const Bo = {\n    average(t) {\n      if (!t.length) return !1;\n      let e,\n        i,\n        s = 0,\n        n = 0,\n        o = 0;\n      for (e = 0, i = t.length; e < i; ++e) {\n        const i = t[e].element;\n        if (i && i.hasValue()) {\n          const t = i.tooltipPosition();\n          s += t.x, n += t.y, ++o;\n        }\n      }\n      return {\n        x: s / o,\n        y: n / o\n      };\n    },\n    nearest(t, e) {\n      if (!t.length) return !1;\n      let i,\n        s,\n        n,\n        o = e.x,\n        a = e.y,\n        r = Number.POSITIVE_INFINITY;\n      for (i = 0, s = t.length; i < s; ++i) {\n        const s = t[i].element;\n        if (s && s.hasValue()) {\n          const t = X(e, s.getCenterPoint());\n          t < r && (r = t, n = s);\n        }\n      }\n      if (n) {\n        const t = n.tooltipPosition();\n        o = t.x, a = t.y;\n      }\n      return {\n        x: o,\n        y: a\n      };\n    }\n  };\n  function No(t, e) {\n    return e && (s(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;\n  }\n  function Wo(t) {\n    return (\"string\" == typeof t || t instanceof String) && t.indexOf(\"\\n\") > -1 ? t.split(\"\\n\") : t;\n  }\n  function jo(t, e) {\n    const {\n        element: i,\n        datasetIndex: s,\n        index: n\n      } = e,\n      o = t.getDatasetMeta(s).controller,\n      {\n        label: a,\n        value: r\n      } = o.getLabelAndValue(n);\n    return {\n      chart: t,\n      label: a,\n      parsed: o.getParsed(n),\n      raw: t.data.datasets[s].data[n],\n      formattedValue: r,\n      dataset: o.getDataset(),\n      dataIndex: n,\n      datasetIndex: s,\n      element: i\n    };\n  }\n  function Ho(t, e) {\n    const i = t.chart.ctx,\n      {\n        body: s,\n        footer: n,\n        title: o\n      } = t,\n      {\n        boxWidth: a,\n        boxHeight: r\n      } = e,\n      l = mi(e.bodyFont),\n      h = mi(e.titleFont),\n      c = mi(e.footerFont),\n      u = o.length,\n      f = n.length,\n      g = s.length,\n      p = pi(e.padding);\n    let m = p.height,\n      b = 0,\n      x = s.reduce((t, e) => t + e.before.length + e.lines.length + e.after.length, 0);\n    if (x += t.beforeBody.length + t.afterBody.length, u && (m += u * h.lineHeight + (u - 1) * e.titleSpacing + e.titleMarginBottom), x) {\n      m += g * (e.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight) + (x - g) * l.lineHeight + (x - 1) * e.bodySpacing;\n    }\n    f && (m += e.footerMarginTop + f * c.lineHeight + (f - 1) * e.footerSpacing);\n    let _ = 0;\n    const y = function y(t) {\n      b = Math.max(b, i.measureText(t).width + _);\n    };\n    return i.save(), i.font = h.string, d(t.title, y), i.font = l.string, d(t.beforeBody.concat(t.afterBody), y), _ = e.displayColors ? a + 2 + e.boxPadding : 0, d(s, t => {\n      d(t.before, y), d(t.lines, y), d(t.after, y);\n    }), _ = 0, i.font = c.string, d(t.footer, y), i.restore(), b += p.width, {\n      width: b,\n      height: m\n    };\n  }\n  function $o(t, e, i, s) {\n    const {\n        x: n,\n        width: o\n      } = i,\n      {\n        width: a,\n        chartArea: {\n          left: r,\n          right: l\n        }\n      } = t;\n    let h = \"center\";\n    return \"center\" === s ? h = n <= (r + l) / 2 ? \"left\" : \"right\" : n <= o / 2 ? h = \"left\" : n >= a - o / 2 && (h = \"right\"), function (t, e, i, s) {\n      const {\n          x: n,\n          width: o\n        } = s,\n        a = i.caretSize + i.caretPadding;\n      return \"left\" === t && n + o + a > e.width || \"right\" === t && n - o - a < 0 || void 0;\n    }(h, t, e, i) && (h = \"center\"), h;\n  }\n  function Yo(t, e, i) {\n    const s = i.yAlign || e.yAlign || function (t, e) {\n      const {\n        y: i,\n        height: s\n      } = e;\n      return i < s / 2 ? \"top\" : i > t.height - s / 2 ? \"bottom\" : \"center\";\n    }(t, i);\n    return {\n      xAlign: i.xAlign || e.xAlign || $o(t, e, i, s),\n      yAlign: s\n    };\n  }\n  function Uo(t, e, i, s) {\n    const {\n        caretSize: n,\n        caretPadding: o,\n        cornerRadius: a\n      } = t,\n      {\n        xAlign: r,\n        yAlign: l\n      } = i,\n      h = n + o,\n      {\n        topLeft: c,\n        topRight: d,\n        bottomLeft: u,\n        bottomRight: f\n      } = gi(a);\n    let g = function (t, e) {\n      let {\n        x: i,\n        width: s\n      } = t;\n      return \"right\" === e ? i -= s : \"center\" === e && (i -= s / 2), i;\n    }(e, r);\n    const p = function (t, e, i) {\n      let {\n        y: s,\n        height: n\n      } = t;\n      return \"top\" === e ? s += i : s -= \"bottom\" === e ? n + i : n / 2, s;\n    }(e, l, h);\n    return \"center\" === l ? \"left\" === r ? g += h : \"right\" === r && (g -= h) : \"left\" === r ? g -= Math.max(c, u) + n : \"right\" === r && (g += Math.max(d, f) + n), {\n      x: Z(g, 0, s.width - e.width),\n      y: Z(p, 0, s.height - e.height)\n    };\n  }\n  function Xo(t, e, i) {\n    const s = pi(i.padding);\n    return \"center\" === e ? t.x + t.width / 2 : \"right\" === e ? t.x + t.width - s.right : t.x + s.left;\n  }\n  function qo(t) {\n    return No([], Wo(t));\n  }\n  function Ko(t, e) {\n    const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;\n    return i ? t.override(i) : t;\n  }\n  class Go extends Es {\n    constructor(t) {\n      super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart || t._chart, this._chart = this.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;\n    }\n    initialize(t) {\n      this.options = t, this._cachedAnimations = void 0, this.$context = void 0;\n    }\n    _resolveAnimations() {\n      const t = this._cachedAnimations;\n      if (t) return t;\n      const e = this.chart,\n        i = this.options.setContext(this.getContext()),\n        s = i.enabled && e.options.animation && i.animations,\n        n = new ys(this.chart, s);\n      return s._cacheable && (this._cachedAnimations = Object.freeze(n)), n;\n    }\n    getContext() {\n      return this.$context || (this.$context = (t = this.chart.getContext(), e = this, i = this._tooltipItems, _i(t, {\n        tooltip: e,\n        tooltipItems: i,\n        type: \"tooltip\"\n      })));\n      var t, e, i;\n    }\n    getTitle(t, e) {\n      const {\n          callbacks: i\n        } = e,\n        s = i.beforeTitle.apply(this, [t]),\n        n = i.title.apply(this, [t]),\n        o = i.afterTitle.apply(this, [t]);\n      let a = [];\n      return a = No(a, Wo(s)), a = No(a, Wo(n)), a = No(a, Wo(o)), a;\n    }\n    getBeforeBody(t, e) {\n      return qo(e.callbacks.beforeBody.apply(this, [t]));\n    }\n    getBody(t, e) {\n      const {\n          callbacks: i\n        } = e,\n        s = [];\n      return d(t, t => {\n        const e = {\n            before: [],\n            lines: [],\n            after: []\n          },\n          n = Ko(i, t);\n        No(e.before, Wo(n.beforeLabel.call(this, t))), No(e.lines, n.label.call(this, t)), No(e.after, Wo(n.afterLabel.call(this, t))), s.push(e);\n      }), s;\n    }\n    getAfterBody(t, e) {\n      return qo(e.callbacks.afterBody.apply(this, [t]));\n    }\n    getFooter(t, e) {\n      const {\n          callbacks: i\n        } = e,\n        s = i.beforeFooter.apply(this, [t]),\n        n = i.footer.apply(this, [t]),\n        o = i.afterFooter.apply(this, [t]);\n      let a = [];\n      return a = No(a, Wo(s)), a = No(a, Wo(n)), a = No(a, Wo(o)), a;\n    }\n    _createItems(t) {\n      const e = this._active,\n        i = this.chart.data,\n        s = [],\n        n = [],\n        o = [];\n      let a,\n        r,\n        l = [];\n      for (a = 0, r = e.length; a < r; ++a) l.push(jo(this.chart, e[a]));\n      return t.filter && (l = l.filter((e, s, n) => t.filter(e, s, n, i))), t.itemSort && (l = l.sort((e, s) => t.itemSort(e, s, i))), d(l, e => {\n        const i = Ko(t.callbacks, e);\n        s.push(i.labelColor.call(this, e)), n.push(i.labelPointStyle.call(this, e)), o.push(i.labelTextColor.call(this, e));\n      }), this.labelColors = s, this.labelPointStyles = n, this.labelTextColors = o, this.dataPoints = l, l;\n    }\n    update(t, e) {\n      const i = this.options.setContext(this.getContext()),\n        s = this._active;\n      let n,\n        o = [];\n      if (s.length) {\n        const t = Bo[i.position].call(this, s, this._eventPosition);\n        o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i);\n        const e = this._size = Ho(this, i),\n          a = Object.assign({}, t, e),\n          r = Yo(this.chart, i, a),\n          l = Uo(i, a, r, this.chart);\n        this.xAlign = r.xAlign, this.yAlign = r.yAlign, n = {\n          opacity: 1,\n          x: l.x,\n          y: l.y,\n          width: e.width,\n          height: e.height,\n          caretX: t.x,\n          caretY: t.y\n        };\n      } else 0 !== this.opacity && (n = {\n        opacity: 0\n      });\n      this._tooltipItems = o, this.$context = void 0, n && this._resolveAnimations().update(this, n), t && i.external && i.external.call(this, {\n        chart: this.chart,\n        tooltip: this,\n        replay: e\n      });\n    }\n    drawCaret(t, e, i, s) {\n      const n = this.getCaretPosition(t, i, s);\n      e.lineTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineTo(n.x3, n.y3);\n    }\n    getCaretPosition(t, e, i) {\n      const {\n          xAlign: s,\n          yAlign: n\n        } = this,\n        {\n          caretSize: o,\n          cornerRadius: a\n        } = i,\n        {\n          topLeft: r,\n          topRight: l,\n          bottomLeft: h,\n          bottomRight: c\n        } = gi(a),\n        {\n          x: d,\n          y: u\n        } = t,\n        {\n          width: f,\n          height: g\n        } = e;\n      let p, m, b, x, _, y;\n      return \"center\" === n ? (_ = u + g / 2, \"left\" === s ? (p = d, m = p - o, x = _ + o, y = _ - o) : (p = d + f, m = p + o, x = _ - o, y = _ + o), b = p) : (m = \"left\" === s ? d + Math.max(r, h) + o : \"right\" === s ? d + f - Math.max(l, c) - o : this.caretX, \"top\" === n ? (x = u, _ = x - o, p = m - o, b = m + o) : (x = u + g, _ = x + o, p = m + o, b = m - o), y = x), {\n        x1: p,\n        x2: m,\n        x3: b,\n        y1: x,\n        y2: _,\n        y3: y\n      };\n    }\n    drawTitle(t, e, i) {\n      const s = this.title,\n        n = s.length;\n      let o, a, r;\n      if (n) {\n        const l = yi(i.rtl, this.x, this.width);\n        for (t.x = Xo(this, i.titleAlign, i), e.textAlign = l.textAlign(i.titleAlign), e.textBaseline = \"middle\", o = mi(i.titleFont), a = i.titleSpacing, e.fillStyle = i.titleColor, e.font = o.string, r = 0; r < n; ++r) e.fillText(s[r], l.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + a, r + 1 === n && (t.y += i.titleMarginBottom - a);\n      }\n    }\n    _drawColorBox(t, e, i, s, o) {\n      const a = this.labelColors[i],\n        r = this.labelPointStyles[i],\n        {\n          boxHeight: l,\n          boxWidth: h,\n          boxPadding: c\n        } = o,\n        d = mi(o.bodyFont),\n        u = Xo(this, \"left\", o),\n        f = s.x(u),\n        g = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0,\n        p = e.y + g;\n      if (o.usePointStyle) {\n        const e = {\n            radius: Math.min(h, l) / 2,\n            pointStyle: r.pointStyle,\n            rotation: r.rotation,\n            borderWidth: 1\n          },\n          i = s.leftForLtr(f, h) + h / 2,\n          n = p + l / 2;\n        t.strokeStyle = o.multiKeyBackground, t.fillStyle = o.multiKeyBackground, Me(t, e, i, n), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, Me(t, e, i, n);\n      } else {\n        t.lineWidth = n(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0;\n        const e = s.leftForLtr(f, h - c),\n          i = s.leftForLtr(s.xPlus(f, 1), h - c - 2),\n          r = gi(a.borderRadius);\n        Object.values(r).some(t => 0 !== t) ? (t.beginPath(), t.fillStyle = o.multiKeyBackground, Le(t, {\n          x: e,\n          y: p,\n          w: h,\n          h: l,\n          radius: r\n        }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), Le(t, {\n          x: i,\n          y: p + 1,\n          w: h - 2,\n          h: l - 2,\n          radius: r\n        }), t.fill()) : (t.fillStyle = o.multiKeyBackground, t.fillRect(e, p, h, l), t.strokeRect(e, p, h, l), t.fillStyle = a.backgroundColor, t.fillRect(i, p + 1, h - 2, l - 2));\n      }\n      t.fillStyle = this.labelTextColors[i];\n    }\n    drawBody(t, e, i) {\n      const {\n          body: s\n        } = this,\n        {\n          bodySpacing: n,\n          bodyAlign: o,\n          displayColors: a,\n          boxHeight: r,\n          boxWidth: l,\n          boxPadding: h\n        } = i,\n        c = mi(i.bodyFont);\n      let u = c.lineHeight,\n        f = 0;\n      const g = yi(i.rtl, this.x, this.width),\n        p = function p(i) {\n          e.fillText(i, g.x(t.x + f), t.y + u / 2), t.y += u + n;\n        },\n        m = g.textAlign(o);\n      let b, x, _, y, v, w, M;\n      for (e.textAlign = o, e.textBaseline = \"middle\", e.font = c.string, t.x = Xo(this, m, i), e.fillStyle = i.bodyColor, d(this.beforeBody, p), f = a && \"right\" !== m ? \"center\" === o ? l / 2 + h : l + 2 + h : 0, y = 0, w = s.length; y < w; ++y) {\n        for (b = s[y], x = this.labelTextColors[y], e.fillStyle = x, d(b.before, p), _ = b.lines, a && _.length && (this._drawColorBox(e, t, y, g, i), u = Math.max(c.lineHeight, r)), v = 0, M = _.length; v < M; ++v) p(_[v]), u = c.lineHeight;\n        d(b.after, p);\n      }\n      f = 0, u = c.lineHeight, d(this.afterBody, p), t.y -= n;\n    }\n    drawFooter(t, e, i) {\n      const s = this.footer,\n        n = s.length;\n      let o, a;\n      if (n) {\n        const r = yi(i.rtl, this.x, this.width);\n        for (t.x = Xo(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = r.textAlign(i.footerAlign), e.textBaseline = \"middle\", o = mi(i.footerFont), e.fillStyle = i.footerColor, e.font = o.string, a = 0; a < n; ++a) e.fillText(s[a], r.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + i.footerSpacing;\n      }\n    }\n    drawBackground(t, e, i, s) {\n      const {\n          xAlign: n,\n          yAlign: o\n        } = this,\n        {\n          x: a,\n          y: r\n        } = t,\n        {\n          width: l,\n          height: h\n        } = i,\n        {\n          topLeft: c,\n          topRight: d,\n          bottomLeft: u,\n          bottomRight: f\n        } = gi(s.cornerRadius);\n      e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.beginPath(), e.moveTo(a + c, r), \"top\" === o && this.drawCaret(t, e, i, s), e.lineTo(a + l - d, r), e.quadraticCurveTo(a + l, r, a + l, r + d), \"center\" === o && \"right\" === n && this.drawCaret(t, e, i, s), e.lineTo(a + l, r + h - f), e.quadraticCurveTo(a + l, r + h, a + l - f, r + h), \"bottom\" === o && this.drawCaret(t, e, i, s), e.lineTo(a + u, r + h), e.quadraticCurveTo(a, r + h, a, r + h - u), \"center\" === o && \"left\" === n && this.drawCaret(t, e, i, s), e.lineTo(a, r + c), e.quadraticCurveTo(a, r, a + c, r), e.closePath(), e.fill(), s.borderWidth > 0 && e.stroke();\n    }\n    _updateAnimationTarget(t) {\n      const e = this.chart,\n        i = this.$animations,\n        s = i && i.x,\n        n = i && i.y;\n      if (s || n) {\n        const i = Bo[t.position].call(this, this._active, this._eventPosition);\n        if (!i) return;\n        const o = this._size = Ho(this, t),\n          a = Object.assign({}, i, this._size),\n          r = Yo(e, t, a),\n          l = Uo(t, a, r, e);\n        s._to === l.x && n._to === l.y || (this.xAlign = r.xAlign, this.yAlign = r.yAlign, this.width = o.width, this.height = o.height, this.caretX = i.x, this.caretY = i.y, this._resolveAnimations().update(this, l));\n      }\n    }\n    _willRender() {\n      return !!this.opacity;\n    }\n    draw(t) {\n      const e = this.options.setContext(this.getContext());\n      let i = this.opacity;\n      if (!i) return;\n      this._updateAnimationTarget(e);\n      const s = {\n          width: this.width,\n          height: this.height\n        },\n        n = {\n          x: this.x,\n          y: this.y\n        };\n      i = Math.abs(i) < .001 ? 0 : i;\n      const o = pi(e.padding),\n        a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n      e.enabled && a && (t.save(), t.globalAlpha = i, this.drawBackground(n, t, s, e), vi(t, e.textDirection), n.y += o.top, this.drawTitle(n, t, e), this.drawBody(n, t, e), this.drawFooter(n, t, e), wi(t, e.textDirection), t.restore());\n    }\n    getActiveElements() {\n      return this._active || [];\n    }\n    setActiveElements(t, e) {\n      const i = this._active,\n        s = t.map(_ref7 => {\n          let {\n            datasetIndex: t,\n            index: e\n          } = _ref7;\n          const i = this.chart.getDatasetMeta(t);\n          if (!i) throw new Error(\"Cannot find a dataset at index \" + t);\n          return {\n            datasetIndex: t,\n            element: i.data[e],\n            index: e\n          };\n        }),\n        n = !u(i, s),\n        o = this._positionChanged(s, e);\n      (n || o) && (this._active = s, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0));\n    }\n    handleEvent(t, e) {\n      let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;\n      if (e && this._ignoreReplayEvents) return !1;\n      this._ignoreReplayEvents = !1;\n      const s = this.options,\n        n = this._active || [],\n        o = this._getActiveElements(t, n, e, i),\n        a = this._positionChanged(o, t),\n        r = e || !u(o, n) || a;\n      return r && (this._active = o, (s.enabled || s.external) && (this._eventPosition = {\n        x: t.x,\n        y: t.y\n      }, this.update(!0, e))), r;\n    }\n    _getActiveElements(t, e, i, s) {\n      const n = this.options;\n      if (\"mouseout\" === t.type) return [];\n      if (!s) return e;\n      const o = this.chart.getElementsAtEventForMode(t, n.mode, n, i);\n      return n.reverse && o.reverse(), o;\n    }\n    _positionChanged(t, e) {\n      const {\n          caretX: i,\n          caretY: s,\n          options: n\n        } = this,\n        o = Bo[n.position].call(this, t, e);\n      return !1 !== o && (i !== o.x || s !== o.y);\n    }\n  }\n  Go.positioners = Bo;\n  var Zo = {\n      id: \"tooltip\",\n      _element: Go,\n      positioners: Bo,\n      afterInit(t, e, i) {\n        i && (t.tooltip = new Go({\n          chart: t,\n          options: i\n        }));\n      },\n      beforeUpdate(t, e, i) {\n        t.tooltip && t.tooltip.initialize(i);\n      },\n      reset(t, e, i) {\n        t.tooltip && t.tooltip.initialize(i);\n      },\n      afterDraw(t) {\n        const e = t.tooltip;\n        if (e && e._willRender()) {\n          const i = {\n            tooltip: e\n          };\n          if (!1 === t.notifyPlugins(\"beforeTooltipDraw\", i)) return;\n          e.draw(t.ctx), t.notifyPlugins(\"afterTooltipDraw\", i);\n        }\n      },\n      afterEvent(t, e) {\n        if (t.tooltip) {\n          const i = e.replay;\n          t.tooltip.handleEvent(e.event, i, e.inChartArea) && (e.changed = !0);\n        }\n      },\n      defaults: {\n        enabled: !0,\n        external: null,\n        position: \"average\",\n        backgroundColor: \"rgba(0,0,0,0.8)\",\n        titleColor: \"#fff\",\n        titleFont: {\n          weight: \"bold\"\n        },\n        titleSpacing: 2,\n        titleMarginBottom: 6,\n        titleAlign: \"left\",\n        bodyColor: \"#fff\",\n        bodySpacing: 2,\n        bodyFont: {},\n        bodyAlign: \"left\",\n        footerColor: \"#fff\",\n        footerSpacing: 2,\n        footerMarginTop: 6,\n        footerFont: {\n          weight: \"bold\"\n        },\n        footerAlign: \"left\",\n        padding: 6,\n        caretPadding: 2,\n        caretSize: 5,\n        cornerRadius: 6,\n        boxHeight: (t, e) => e.bodyFont.size,\n        boxWidth: (t, e) => e.bodyFont.size,\n        multiKeyBackground: \"#fff\",\n        displayColors: !0,\n        boxPadding: 0,\n        borderColor: \"rgba(0,0,0,0)\",\n        borderWidth: 0,\n        animation: {\n          duration: 400,\n          easing: \"easeOutQuart\"\n        },\n        animations: {\n          numbers: {\n            type: \"number\",\n            properties: [\"x\", \"y\", \"width\", \"height\", \"caretX\", \"caretY\"]\n          },\n          opacity: {\n            easing: \"linear\",\n            duration: 200\n          }\n        },\n        callbacks: {\n          beforeTitle: t,\n          title(t) {\n            if (t.length > 0) {\n              const e = t[0],\n                i = e.chart.data.labels,\n                s = i ? i.length : 0;\n              if (this && this.options && \"dataset\" === this.options.mode) return e.dataset.label || \"\";\n              if (e.label) return e.label;\n              if (s > 0 && e.dataIndex < s) return i[e.dataIndex];\n            }\n            return \"\";\n          },\n          afterTitle: t,\n          beforeBody: t,\n          beforeLabel: t,\n          label(t) {\n            if (this && this.options && \"dataset\" === this.options.mode) return t.label + \": \" + t.formattedValue || t.formattedValue;\n            let e = t.dataset.label || \"\";\n            e && (e += \": \");\n            const s = t.formattedValue;\n            return i(s) || (e += s), e;\n          },\n          labelColor(t) {\n            const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);\n            return {\n              borderColor: e.borderColor,\n              backgroundColor: e.backgroundColor,\n              borderWidth: e.borderWidth,\n              borderDash: e.borderDash,\n              borderDashOffset: e.borderDashOffset,\n              borderRadius: 0\n            };\n          },\n          labelTextColor() {\n            return this.options.bodyColor;\n          },\n          labelPointStyle(t) {\n            const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);\n            return {\n              pointStyle: e.pointStyle,\n              rotation: e.rotation\n            };\n          },\n          afterLabel: t,\n          afterBody: t,\n          beforeFooter: t,\n          footer: t,\n          afterFooter: t\n        }\n      },\n      defaultRoutes: {\n        bodyFont: \"font\",\n        footerFont: \"font\",\n        titleFont: \"font\"\n      },\n      descriptors: {\n        _scriptable: t => \"filter\" !== t && \"itemSort\" !== t && \"external\" !== t,\n        _indexable: !1,\n        callbacks: {\n          _scriptable: !1,\n          _indexable: !1\n        },\n        animation: {\n          _fallback: !1\n        },\n        animations: {\n          _fallback: \"animation\"\n        }\n      },\n      additionalOptionScopes: [\"interaction\"]\n    },\n    Jo = Object.freeze({\n      __proto__: null,\n      Decimation: go,\n      Filler: To,\n      Legend: Ro,\n      SubTitle: Vo,\n      Title: zo,\n      Tooltip: Zo\n    });\n  function Qo(t, e, i, s) {\n    const n = t.indexOf(e);\n    if (-1 === n) return ((t, e, i, s) => (\"string\" == typeof e ? (i = t.push(e) - 1, s.unshift({\n      index: i,\n      label: e\n    })) : isNaN(e) && (i = null), i))(t, e, i, s);\n    return n !== t.lastIndexOf(e) ? i : n;\n  }\n  class ta extends $s {\n    constructor(t) {\n      super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];\n    }\n    init(t) {\n      const e = this._addedLabels;\n      if (e.length) {\n        const t = this.getLabels();\n        for (const {\n          index: i,\n          label: s\n        } of e) t[i] === s && t.splice(i, 1);\n        this._addedLabels = [];\n      }\n      super.init(t);\n    }\n    parse(t, e) {\n      if (i(t)) return null;\n      const s = this.getLabels();\n      return ((t, e) => null === t ? null : Z(Math.round(t), 0, e))(e = isFinite(e) && s[e] === t ? e : Qo(s, t, r(e, t), this._addedLabels), s.length - 1);\n    }\n    determineDataLimits() {\n      const {\n        minDefined: t,\n        maxDefined: e\n      } = this.getUserBounds();\n      let {\n        min: i,\n        max: s\n      } = this.getMinMax(!0);\n      \"ticks\" === this.options.bounds && (t || (i = 0), e || (s = this.getLabels().length - 1)), this.min = i, this.max = s;\n    }\n    buildTicks() {\n      const t = this.min,\n        e = this.max,\n        i = this.options.offset,\n        s = [];\n      let n = this.getLabels();\n      n = 0 === t && e === n.length - 1 ? n : n.slice(t, e + 1), this._valueRange = Math.max(n.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0);\n      for (let i = t; i <= e; i++) s.push({\n        value: i\n      });\n      return s;\n    }\n    getLabelForValue(t) {\n      const e = this.getLabels();\n      return t >= 0 && t < e.length ? e[t] : t;\n    }\n    configure() {\n      super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);\n    }\n    getPixelForValue(t) {\n      return \"number\" != typeof t && (t = this.parse(t)), null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n    }\n    getPixelForTick(t) {\n      const e = this.ticks;\n      return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n    }\n    getValueForPixel(t) {\n      return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);\n    }\n    getBasePixel() {\n      return this.bottom;\n    }\n  }\n  function ea(t, e, _ref8) {\n    let {\n      horizontal: i,\n      minRotation: s\n    } = _ref8;\n    const n = H(s),\n      o = (i ? Math.sin(n) : Math.cos(n)) || .001,\n      a = .75 * e * (\"\" + t).length;\n    return Math.min(e / o, a);\n  }\n  ta.id = \"category\", ta.defaults = {\n    ticks: {\n      callback: ta.prototype.getLabelForValue\n    }\n  };\n  class ia extends $s {\n    constructor(t) {\n      super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;\n    }\n    parse(t, e) {\n      return i(t) || (\"number\" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t;\n    }\n    handleTickRangeOptions() {\n      const {\n          beginAtZero: t\n        } = this.options,\n        {\n          minDefined: e,\n          maxDefined: i\n        } = this.getUserBounds();\n      let {\n        min: s,\n        max: n\n      } = this;\n      const o = t => s = e ? s : t,\n        a = t => n = i ? n : t;\n      if (t) {\n        const t = z(s),\n          e = z(n);\n        t < 0 && e < 0 ? a(0) : t > 0 && e > 0 && o(0);\n      }\n      if (s === n) {\n        let e = 1;\n        (n >= Number.MAX_SAFE_INTEGER || s <= Number.MIN_SAFE_INTEGER) && (e = Math.abs(.05 * n)), a(n + e), t || o(s - e);\n      }\n      this.min = s, this.max = n;\n    }\n    getTickLimit() {\n      const t = this.options.ticks;\n      let e,\n        {\n          maxTicksLimit: i,\n          stepSize: s\n        } = t;\n      return s ? (e = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, e > 1e3 && (console.warn(\"scales.\".concat(this.id, \".ticks.stepSize: \").concat(s, \" would result generating up to \").concat(e, \" ticks. Limiting to 1000.\")), e = 1e3)) : (e = this.computeTickLimit(), i = i || 11), i && (e = Math.min(i, e)), e;\n    }\n    computeTickLimit() {\n      return Number.POSITIVE_INFINITY;\n    }\n    buildTicks() {\n      const t = this.options,\n        e = t.ticks;\n      let s = this.getTickLimit();\n      s = Math.max(2, s);\n      const n = function (t, e) {\n        const s = [],\n          {\n            bounds: n,\n            step: o,\n            min: a,\n            max: r,\n            precision: l,\n            count: h,\n            maxTicks: c,\n            maxDigits: d,\n            includeBounds: u\n          } = t,\n          f = o || 1,\n          g = c - 1,\n          {\n            min: p,\n            max: m\n          } = e,\n          b = !i(a),\n          x = !i(r),\n          _ = !i(h),\n          y = (m - p) / (d + 1);\n        let v,\n          w,\n          M,\n          k,\n          S = F((m - p) / g / f) * f;\n        if (S < 1e-14 && !b && !x) return [{\n          value: p\n        }, {\n          value: m\n        }];\n        k = Math.ceil(m / S) - Math.floor(p / S), k > g && (S = F(k * S / g / f) * f), i(l) || (v = Math.pow(10, l), S = Math.ceil(S * v) / v), \"ticks\" === n ? (w = Math.floor(p / S) * S, M = Math.ceil(m / S) * S) : (w = p, M = m), b && x && o && W((r - a) / o, S / 1e3) ? (k = Math.round(Math.min((r - a) / S, c)), S = (r - a) / k, w = a, M = r) : _ ? (w = b ? a : w, M = x ? r : M, k = h - 1, S = (M - w) / k) : (k = (M - w) / S, k = N(k, Math.round(k), S / 1e3) ? Math.round(k) : Math.ceil(k));\n        const P = Math.max(Y(S), Y(w));\n        v = Math.pow(10, i(l) ? P : l), w = Math.round(w * v) / v, M = Math.round(M * v) / v;\n        let D = 0;\n        for (b && (u && w !== a ? (s.push({\n          value: a\n        }), w < a && D++, N(Math.round((w + D * S) * v) / v, a, ea(a, y, t)) && D++) : w < a && D++); D < k; ++D) s.push({\n          value: Math.round((w + D * S) * v) / v\n        });\n        return x && u && M !== r ? s.length && N(s[s.length - 1].value, r, ea(r, y, t)) ? s[s.length - 1].value = r : s.push({\n          value: r\n        }) : x && M !== r || s.push({\n          value: M\n        }), s;\n      }({\n        maxTicks: s,\n        bounds: t.bounds,\n        min: t.min,\n        max: t.max,\n        precision: e.precision,\n        step: e.stepSize,\n        count: e.count,\n        maxDigits: this._maxDigits(),\n        horizontal: this.isHorizontal(),\n        minRotation: e.minRotation || 0,\n        includeBounds: !1 !== e.includeBounds\n      }, this._range || this);\n      return \"ticks\" === t.bounds && j(n, this, \"value\"), t.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n;\n    }\n    configure() {\n      const t = this.ticks;\n      let e = this.min,\n        i = this.max;\n      if (super.configure(), this.options.offset && t.length) {\n        const s = (i - e) / Math.max(t.length - 1, 1) / 2;\n        e -= s, i += s;\n      }\n      this._startValue = e, this._endValue = i, this._valueRange = i - e;\n    }\n    getLabelForValue(t) {\n      return li(t, this.chart.options.locale, this.options.ticks.format);\n    }\n  }\n  class sa extends ia {\n    determineDataLimits() {\n      const {\n        min: t,\n        max: e\n      } = this.getMinMax(!0);\n      this.min = o(t) ? t : 0, this.max = o(e) ? e : 1, this.handleTickRangeOptions();\n    }\n    computeTickLimit() {\n      const t = this.isHorizontal(),\n        e = t ? this.width : this.height,\n        i = H(this.options.ticks.minRotation),\n        s = (t ? Math.sin(i) : Math.cos(i)) || .001,\n        n = this._resolveTickFontOptions(0);\n      return Math.ceil(e / Math.min(40, n.lineHeight / s));\n    }\n    getPixelForValue(t) {\n      return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(t) {\n      return this._startValue + this.getDecimalForPixel(t) * this._valueRange;\n    }\n  }\n  function na(t) {\n    return 1 === t / Math.pow(10, Math.floor(I(t)));\n  }\n  sa.id = \"linear\", sa.defaults = {\n    ticks: {\n      callback: Is.formatters.numeric\n    }\n  };\n  class oa extends $s {\n    constructor(t) {\n      super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;\n    }\n    parse(t, e) {\n      const i = ia.prototype.parse.apply(this, [t, e]);\n      if (0 !== i) return o(i) && i > 0 ? i : null;\n      this._zero = !0;\n    }\n    determineDataLimits() {\n      const {\n        min: t,\n        max: e\n      } = this.getMinMax(!0);\n      this.min = o(t) ? Math.max(0, t) : null, this.max = o(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this.handleTickRangeOptions();\n    }\n    handleTickRangeOptions() {\n      const {\n        minDefined: t,\n        maxDefined: e\n      } = this.getUserBounds();\n      let i = this.min,\n        s = this.max;\n      const n = e => i = t ? i : e,\n        o = t => s = e ? s : t,\n        a = (t, e) => Math.pow(10, Math.floor(I(t)) + e);\n      i === s && (i <= 0 ? (n(1), o(10)) : (n(a(i, -1)), o(a(s, 1)))), i <= 0 && n(a(s, -1)), s <= 0 && o(a(i, 1)), this._zero && this.min !== this._suggestedMin && i === a(this.min, 0) && n(a(i, -1)), this.min = i, this.max = s;\n    }\n    buildTicks() {\n      const t = this.options,\n        e = function (t, e) {\n          const i = Math.floor(I(e.max)),\n            s = Math.ceil(e.max / Math.pow(10, i)),\n            n = [];\n          let o = a(t.min, Math.pow(10, Math.floor(I(e.min)))),\n            r = Math.floor(I(o)),\n            l = Math.floor(o / Math.pow(10, r)),\n            h = r < 0 ? Math.pow(10, Math.abs(r)) : 1;\n          do {\n            n.push({\n              value: o,\n              major: na(o)\n            }), ++l, 10 === l && (l = 1, ++r, h = r >= 0 ? 1 : h), o = Math.round(l * Math.pow(10, r) * h) / h;\n          } while (r < i || r === i && l < s);\n          const c = a(t.max, o);\n          return n.push({\n            value: c,\n            major: na(o)\n          }), n;\n        }({\n          min: this._userMin,\n          max: this._userMax\n        }, this);\n      return \"ticks\" === t.bounds && j(e, this, \"value\"), t.reverse ? (e.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), e;\n    }\n    getLabelForValue(t) {\n      return void 0 === t ? \"0\" : li(t, this.chart.options.locale, this.options.ticks.format);\n    }\n    configure() {\n      const t = this.min;\n      super.configure(), this._startValue = I(t), this._valueRange = I(this.max) - I(t);\n    }\n    getPixelForValue(t) {\n      return void 0 !== t && 0 !== t || (t = this.min), null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (I(t) - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(t) {\n      const e = this.getDecimalForPixel(t);\n      return Math.pow(10, this._startValue + e * this._valueRange);\n    }\n  }\n  function aa(t) {\n    const e = t.ticks;\n    if (e.display && t.display) {\n      const t = pi(e.backdropPadding);\n      return r(e.font && e.font.size, ne.font.size) + t.height;\n    }\n    return 0;\n  }\n  function ra(t, e, i, s, n) {\n    return t === s || t === n ? {\n      start: e - i / 2,\n      end: e + i / 2\n    } : t < s || t > n ? {\n      start: e - i,\n      end: e\n    } : {\n      start: e,\n      end: e + i\n    };\n  }\n  function la(t) {\n    const e = {\n        l: t.left + t._padding.left,\n        r: t.right - t._padding.right,\n        t: t.top + t._padding.top,\n        b: t.bottom - t._padding.bottom\n      },\n      i = Object.assign({}, e),\n      n = [],\n      o = [],\n      a = t._pointLabels.length,\n      r = t.options.pointLabels,\n      l = r.centerPointLabels ? D / a : 0;\n    for (let u = 0; u < a; u++) {\n      const a = r.setContext(t.getPointLabelContext(u));\n      o[u] = a.padding;\n      const f = t.getPointPosition(u, t.drawingArea + o[u], l),\n        g = mi(a.font),\n        p = (h = t.ctx, c = g, d = s(d = t._pointLabels[u]) ? d : [d], {\n          w: ye(h, c.string, d),\n          h: d.length * c.lineHeight\n        });\n      n[u] = p;\n      const m = K(t.getIndexAngle(u) + l),\n        b = Math.round($(m));\n      ha(i, e, m, ra(b, f.x, p.w, 0, 180), ra(b, f.y, p.h, 90, 270));\n    }\n    var h, c, d;\n    t.setCenterPoint(e.l - i.l, i.r - e.r, e.t - i.t, i.b - e.b), t._pointLabelItems = function (t, e, i) {\n      const s = [],\n        n = t._pointLabels.length,\n        o = t.options,\n        a = aa(o) / 2,\n        r = t.drawingArea,\n        l = o.pointLabels.centerPointLabels ? D / n : 0;\n      for (let o = 0; o < n; o++) {\n        const n = t.getPointPosition(o, r + a + i[o], l),\n          h = Math.round($(K(n.angle + L))),\n          c = e[o],\n          d = ua(n.y, c.h, h),\n          u = ca(h),\n          f = da(n.x, c.w, u);\n        s.push({\n          x: n.x,\n          y: d,\n          textAlign: u,\n          left: f,\n          top: d,\n          right: f + c.w,\n          bottom: d + c.h\n        });\n      }\n      return s;\n    }(t, n, o);\n  }\n  function ha(t, e, i, s, n) {\n    const o = Math.abs(Math.sin(i)),\n      a = Math.abs(Math.cos(i));\n    let r = 0,\n      l = 0;\n    s.start < e.l ? (r = (e.l - s.start) / o, t.l = Math.min(t.l, e.l - r)) : s.end > e.r && (r = (s.end - e.r) / o, t.r = Math.max(t.r, e.r + r)), n.start < e.t ? (l = (e.t - n.start) / a, t.t = Math.min(t.t, e.t - l)) : n.end > e.b && (l = (n.end - e.b) / a, t.b = Math.max(t.b, e.b + l));\n  }\n  function ca(t) {\n    return 0 === t || 180 === t ? \"center\" : t < 180 ? \"left\" : \"right\";\n  }\n  function da(t, e, i) {\n    return \"right\" === i ? t -= e : \"center\" === i && (t -= e / 2), t;\n  }\n  function ua(t, e, i) {\n    return 90 === i || 270 === i ? t -= e / 2 : (i > 270 || i < 90) && (t -= e), t;\n  }\n  function fa(t, e, i, s) {\n    const {\n      ctx: n\n    } = t;\n    if (i) n.arc(t.xCenter, t.yCenter, e, 0, O);else {\n      let i = t.getPointPosition(0, e);\n      n.moveTo(i.x, i.y);\n      for (let o = 1; o < s; o++) i = t.getPointPosition(o, e), n.lineTo(i.x, i.y);\n    }\n  }\n  oa.id = \"logarithmic\", oa.defaults = {\n    ticks: {\n      callback: Is.formatters.logarithmic,\n      major: {\n        enabled: !0\n      }\n    }\n  };\n  class ga extends ia {\n    constructor(t) {\n      super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];\n    }\n    setDimensions() {\n      const t = this._padding = pi(aa(this.options) / 2),\n        e = this.width = this.maxWidth - t.width,\n        i = this.height = this.maxHeight - t.height;\n      this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2);\n    }\n    determineDataLimits() {\n      const {\n        min: t,\n        max: e\n      } = this.getMinMax(!1);\n      this.min = o(t) && !isNaN(t) ? t : 0, this.max = o(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions();\n    }\n    computeTickLimit() {\n      return Math.ceil(this.drawingArea / aa(this.options));\n    }\n    generateTickLabels(t) {\n      ia.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((t, e) => {\n        const i = c(this.options.pointLabels.callback, [t, e], this);\n        return i || 0 === i ? i : \"\";\n      }).filter((t, e) => this.chart.getDataVisibility(e));\n    }\n    fit() {\n      const t = this.options;\n      t.display && t.pointLabels.display ? la(this) : this.setCenterPoint(0, 0, 0, 0);\n    }\n    setCenterPoint(t, e, i, s) {\n      this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - s) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, s));\n    }\n    getIndexAngle(t) {\n      return K(t * (O / (this._pointLabels.length || 1)) + H(this.options.startAngle || 0));\n    }\n    getDistanceFromCenterForValue(t) {\n      if (i(t)) return NaN;\n      const e = this.drawingArea / (this.max - this.min);\n      return this.options.reverse ? (this.max - t) * e : (t - this.min) * e;\n    }\n    getValueForDistanceFromCenter(t) {\n      if (i(t)) return NaN;\n      const e = t / (this.drawingArea / (this.max - this.min));\n      return this.options.reverse ? this.max - e : this.min + e;\n    }\n    getPointLabelContext(t) {\n      const e = this._pointLabels || [];\n      if (t >= 0 && t < e.length) {\n        const i = e[t];\n        return function (t, e, i) {\n          return _i(t, {\n            label: i,\n            index: e,\n            type: \"pointLabel\"\n          });\n        }(this.getContext(), t, i);\n      }\n    }\n    getPointPosition(t, e) {\n      let i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      const s = this.getIndexAngle(t) - L + i;\n      return {\n        x: Math.cos(s) * e + this.xCenter,\n        y: Math.sin(s) * e + this.yCenter,\n        angle: s\n      };\n    }\n    getPointPositionForValue(t, e) {\n      return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));\n    }\n    getBasePosition(t) {\n      return this.getPointPositionForValue(t || 0, this.getBaseValue());\n    }\n    getPointLabelPosition(t) {\n      const {\n        left: e,\n        top: i,\n        right: s,\n        bottom: n\n      } = this._pointLabelItems[t];\n      return {\n        left: e,\n        top: i,\n        right: s,\n        bottom: n\n      };\n    }\n    drawBackground() {\n      const {\n        backgroundColor: t,\n        grid: {\n          circular: e\n        }\n      } = this.options;\n      if (t) {\n        const i = this.ctx;\n        i.save(), i.beginPath(), fa(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore();\n      }\n    }\n    drawGrid() {\n      const t = this.ctx,\n        e = this.options,\n        {\n          angleLines: s,\n          grid: n\n        } = e,\n        o = this._pointLabels.length;\n      let a, r, l;\n      if (e.pointLabels.display && function (t, e) {\n        const {\n          ctx: s,\n          options: {\n            pointLabels: n\n          }\n        } = t;\n        for (let o = e - 1; o >= 0; o--) {\n          const e = n.setContext(t.getPointLabelContext(o)),\n            a = mi(e.font),\n            {\n              x: r,\n              y: l,\n              textAlign: h,\n              left: c,\n              top: d,\n              right: u,\n              bottom: f\n            } = t._pointLabelItems[o],\n            {\n              backdropColor: g\n            } = e;\n          if (!i(g)) {\n            const t = gi(e.borderRadius),\n              i = pi(e.backdropPadding);\n            s.fillStyle = g;\n            const n = c - i.left,\n              o = d - i.top,\n              a = u - c + i.width,\n              r = f - d + i.height;\n            Object.values(t).some(t => 0 !== t) ? (s.beginPath(), Le(s, {\n              x: n,\n              y: o,\n              w: a,\n              h: r,\n              radius: t\n            }), s.fill()) : s.fillRect(n, o, a, r);\n          }\n          Ae(s, t._pointLabels[o], r, l + a.lineHeight / 2, a, {\n            color: e.color,\n            textAlign: h,\n            textBaseline: \"middle\"\n          });\n        }\n      }(this, o), n.display && this.ticks.forEach((t, e) => {\n        if (0 !== e) {\n          r = this.getDistanceFromCenterForValue(t.value);\n          !function (t, e, i, s) {\n            const n = t.ctx,\n              o = e.circular,\n              {\n                color: a,\n                lineWidth: r\n              } = e;\n            !o && !s || !a || !r || i < 0 || (n.save(), n.strokeStyle = a, n.lineWidth = r, n.setLineDash(e.borderDash), n.lineDashOffset = e.borderDashOffset, n.beginPath(), fa(t, i, o, s), n.closePath(), n.stroke(), n.restore());\n          }(this, n.setContext(this.getContext(e - 1)), r, o);\n        }\n      }), s.display) {\n        for (t.save(), a = o - 1; a >= 0; a--) {\n          const i = s.setContext(this.getPointLabelContext(a)),\n            {\n              color: n,\n              lineWidth: o\n            } = i;\n          o && n && (t.lineWidth = o, t.strokeStyle = n, t.setLineDash(i.borderDash), t.lineDashOffset = i.borderDashOffset, r = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), l = this.getPointPosition(a, r), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke());\n        }\n        t.restore();\n      }\n    }\n    drawBorder() {}\n    drawLabels() {\n      const t = this.ctx,\n        e = this.options,\n        i = e.ticks;\n      if (!i.display) return;\n      const s = this.getIndexAngle(0);\n      let n, o;\n      t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(s), t.textAlign = \"center\", t.textBaseline = \"middle\", this.ticks.forEach((s, a) => {\n        if (0 === a && !e.reverse) return;\n        const r = i.setContext(this.getContext(a)),\n          l = mi(r.font);\n        if (n = this.getDistanceFromCenterForValue(this.ticks[a].value), r.showLabelBackdrop) {\n          t.font = l.string, o = t.measureText(s.label).width, t.fillStyle = r.backdropColor;\n          const e = pi(r.backdropPadding);\n          t.fillRect(-o / 2 - e.left, -n - l.size / 2 - e.top, o + e.width, l.size + e.height);\n        }\n        Ae(t, s.label, 0, -n, l, {\n          color: r.color\n        });\n      }), t.restore();\n    }\n    drawTitle() {}\n  }\n  ga.id = \"radialLinear\", ga.defaults = {\n    display: !0,\n    animate: !0,\n    position: \"chartArea\",\n    angleLines: {\n      display: !0,\n      lineWidth: 1,\n      borderDash: [],\n      borderDashOffset: 0\n    },\n    grid: {\n      circular: !1\n    },\n    startAngle: 0,\n    ticks: {\n      showLabelBackdrop: !0,\n      callback: Is.formatters.numeric\n    },\n    pointLabels: {\n      backdropColor: void 0,\n      backdropPadding: 2,\n      display: !0,\n      font: {\n        size: 10\n      },\n      callback: t => t,\n      padding: 5,\n      centerPointLabels: !1\n    }\n  }, ga.defaultRoutes = {\n    \"angleLines.color\": \"borderColor\",\n    \"pointLabels.color\": \"color\",\n    \"ticks.color\": \"color\"\n  }, ga.descriptors = {\n    angleLines: {\n      _fallback: \"grid\"\n    }\n  };\n  const pa = {\n      millisecond: {\n        common: !0,\n        size: 1,\n        steps: 1e3\n      },\n      second: {\n        common: !0,\n        size: 1e3,\n        steps: 60\n      },\n      minute: {\n        common: !0,\n        size: 6e4,\n        steps: 60\n      },\n      hour: {\n        common: !0,\n        size: 36e5,\n        steps: 24\n      },\n      day: {\n        common: !0,\n        size: 864e5,\n        steps: 30\n      },\n      week: {\n        common: !1,\n        size: 6048e5,\n        steps: 4\n      },\n      month: {\n        common: !0,\n        size: 2628e6,\n        steps: 12\n      },\n      quarter: {\n        common: !1,\n        size: 7884e6,\n        steps: 4\n      },\n      year: {\n        common: !0,\n        size: 3154e7\n      }\n    },\n    ma = Object.keys(pa);\n  function ba(t, e) {\n    return t - e;\n  }\n  function xa(t, e) {\n    if (i(e)) return null;\n    const s = t._adapter,\n      {\n        parser: n,\n        round: a,\n        isoWeekday: r\n      } = t._parseOpts;\n    let l = e;\n    return \"function\" == typeof n && (l = n(l)), o(l) || (l = \"string\" == typeof n ? s.parse(l, n) : s.parse(l)), null === l ? null : (a && (l = \"week\" !== a || !B(r) && !0 !== r ? s.startOf(l, a) : s.startOf(l, \"isoWeek\", r)), +l);\n  }\n  function _a(t, e, i, s) {\n    const n = ma.length;\n    for (let o = ma.indexOf(t); o < n - 1; ++o) {\n      const t = pa[ma[o]],\n        n = t.steps ? t.steps : Number.MAX_SAFE_INTEGER;\n      if (t.common && Math.ceil((i - e) / (n * t.size)) <= s) return ma[o];\n    }\n    return ma[n - 1];\n  }\n  function ya(t, e, i) {\n    if (i) {\n      if (i.length) {\n        const {\n          lo: s,\n          hi: n\n        } = tt(i, e);\n        t[i[s] >= e ? i[s] : i[n]] = !0;\n      }\n    } else t[e] = !0;\n  }\n  function va(t, e, i) {\n    const s = [],\n      n = {},\n      o = e.length;\n    let a, r;\n    for (a = 0; a < o; ++a) r = e[a], n[r] = a, s.push({\n      value: r,\n      major: !1\n    });\n    return 0 !== o && i ? function (t, e, i, s) {\n      const n = t._adapter,\n        o = +n.startOf(e[0].value, s),\n        a = e[e.length - 1].value;\n      let r, l;\n      for (r = o; r <= a; r = +n.add(r, 1, s)) l = i[r], l >= 0 && (e[l].major = !0);\n      return e;\n    }(t, s, n, i) : s;\n  }\n  class wa extends $s {\n    constructor(t) {\n      super(t), this._cache = {\n        data: [],\n        labels: [],\n        all: []\n      }, this._unit = \"day\", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;\n    }\n    init(t, e) {\n      const i = t.time || (t.time = {}),\n        s = this._adapter = new wn._date(t.adapters.date);\n      s.init(e), b(i.displayFormats, s.formats()), this._parseOpts = {\n        parser: i.parser,\n        round: i.round,\n        isoWeekday: i.isoWeekday\n      }, super.init(t), this._normalized = e.normalized;\n    }\n    parse(t, e) {\n      return void 0 === t ? null : xa(this, t);\n    }\n    beforeLayout() {\n      super.beforeLayout(), this._cache = {\n        data: [],\n        labels: [],\n        all: []\n      };\n    }\n    determineDataLimits() {\n      const t = this.options,\n        e = this._adapter,\n        i = t.time.unit || \"day\";\n      let {\n        min: s,\n        max: n,\n        minDefined: a,\n        maxDefined: r\n      } = this.getUserBounds();\n      function l(t) {\n        a || isNaN(t.min) || (s = Math.min(s, t.min)), r || isNaN(t.max) || (n = Math.max(n, t.max));\n      }\n      a && r || (l(this._getLabelBounds()), \"ticks\" === t.bounds && \"labels\" === t.ticks.source || l(this.getMinMax(!1))), s = o(s) && !isNaN(s) ? s : +e.startOf(Date.now(), i), n = o(n) && !isNaN(n) ? n : +e.endOf(Date.now(), i) + 1, this.min = Math.min(s, n - 1), this.max = Math.max(s + 1, n);\n    }\n    _getLabelBounds() {\n      const t = this.getLabelTimestamps();\n      let e = Number.POSITIVE_INFINITY,\n        i = Number.NEGATIVE_INFINITY;\n      return t.length && (e = t[0], i = t[t.length - 1]), {\n        min: e,\n        max: i\n      };\n    }\n    buildTicks() {\n      const t = this.options,\n        e = t.time,\n        i = t.ticks,\n        s = \"labels\" === i.source ? this.getLabelTimestamps() : this._generate();\n      \"ticks\" === t.bounds && s.length && (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]);\n      const n = this.min,\n        o = st(s, n, this.max);\n      return this._unit = e.unit || (i.autoSkip ? _a(e.minUnit, this.min, this.max, this._getLabelCapacity(n)) : function (t, e, i, s, n) {\n        for (let o = ma.length - 1; o >= ma.indexOf(i); o--) {\n          const i = ma[o];\n          if (pa[i].common && t._adapter.diff(n, s, i) >= e - 1) return i;\n        }\n        return ma[i ? ma.indexOf(i) : 0];\n      }(this, o.length, e.minUnit, this.min, this.max)), this._majorUnit = i.major.enabled && \"year\" !== this._unit ? function (t) {\n        for (let e = ma.indexOf(t) + 1, i = ma.length; e < i; ++e) if (pa[ma[e]].common) return ma[e];\n      }(this._unit) : void 0, this.initOffsets(s), t.reverse && o.reverse(), va(this, o, this._majorUnit);\n    }\n    afterAutoSkip() {\n      this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(t => +t.value));\n    }\n    initOffsets(t) {\n      let e,\n        i,\n        s = 0,\n        n = 0;\n      this.options.offset && t.length && (e = this.getDecimalForValue(t[0]), s = 1 === t.length ? 1 - e : (this.getDecimalForValue(t[1]) - e) / 2, i = this.getDecimalForValue(t[t.length - 1]), n = 1 === t.length ? i : (i - this.getDecimalForValue(t[t.length - 2])) / 2);\n      const o = t.length < 3 ? .5 : .25;\n      s = Z(s, 0, o), n = Z(n, 0, o), this._offsets = {\n        start: s,\n        end: n,\n        factor: 1 / (s + 1 + n)\n      };\n    }\n    _generate() {\n      const t = this._adapter,\n        e = this.min,\n        i = this.max,\n        s = this.options,\n        n = s.time,\n        o = n.unit || _a(n.minUnit, e, i, this._getLabelCapacity(e)),\n        a = r(n.stepSize, 1),\n        l = \"week\" === o && n.isoWeekday,\n        h = B(l) || !0 === l,\n        c = {};\n      let d,\n        u,\n        f = e;\n      if (h && (f = +t.startOf(f, \"isoWeek\", l)), f = +t.startOf(f, h ? \"day\" : o), t.diff(i, e, o) > 1e5 * a) throw new Error(e + \" and \" + i + \" are too far apart with stepSize of \" + a + \" \" + o);\n      const g = \"data\" === s.ticks.source && this.getDataTimestamps();\n      for (d = f, u = 0; d < i; d = +t.add(d, a, o), u++) ya(c, d, g);\n      return d !== i && \"ticks\" !== s.bounds && 1 !== u || ya(c, d, g), Object.keys(c).sort((t, e) => t - e).map(t => +t);\n    }\n    getLabelForValue(t) {\n      const e = this._adapter,\n        i = this.options.time;\n      return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime);\n    }\n    _tickFormatFunction(t, e, i, s) {\n      const n = this.options,\n        o = n.time.displayFormats,\n        a = this._unit,\n        r = this._majorUnit,\n        l = a && o[a],\n        h = r && o[r],\n        d = i[e],\n        u = r && h && d && d.major,\n        f = this._adapter.format(t, s || (u ? h : l)),\n        g = n.ticks.callback;\n      return g ? c(g, [f, e, i], this) : f;\n    }\n    generateTickLabels(t) {\n      let e, i, s;\n      for (e = 0, i = t.length; e < i; ++e) s = t[e], s.label = this._tickFormatFunction(s.value, e, t);\n    }\n    getDecimalForValue(t) {\n      return null === t ? NaN : (t - this.min) / (this.max - this.min);\n    }\n    getPixelForValue(t) {\n      const e = this._offsets,\n        i = this.getDecimalForValue(t);\n      return this.getPixelForDecimal((e.start + i) * e.factor);\n    }\n    getValueForPixel(t) {\n      const e = this._offsets,\n        i = this.getDecimalForPixel(t) / e.factor - e.end;\n      return this.min + i * (this.max - this.min);\n    }\n    _getLabelSize(t) {\n      const e = this.options.ticks,\n        i = this.ctx.measureText(t).width,\n        s = H(this.isHorizontal() ? e.maxRotation : e.minRotation),\n        n = Math.cos(s),\n        o = Math.sin(s),\n        a = this._resolveTickFontOptions(0).size;\n      return {\n        w: i * n + a * o,\n        h: i * o + a * n\n      };\n    }\n    _getLabelCapacity(t) {\n      const e = this.options.time,\n        i = e.displayFormats,\n        s = i[e.unit] || i.millisecond,\n        n = this._tickFormatFunction(t, 0, va(this, [t], this._majorUnit), s),\n        o = this._getLabelSize(n),\n        a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;\n      return a > 0 ? a : 1;\n    }\n    getDataTimestamps() {\n      let t,\n        e,\n        i = this._cache.data || [];\n      if (i.length) return i;\n      const s = this.getMatchingVisibleMetas();\n      if (this._normalized && s.length) return this._cache.data = s[0].controller.getAllParsedValues(this);\n      for (t = 0, e = s.length; t < e; ++t) i = i.concat(s[t].controller.getAllParsedValues(this));\n      return this._cache.data = this.normalize(i);\n    }\n    getLabelTimestamps() {\n      const t = this._cache.labels || [];\n      let e, i;\n      if (t.length) return t;\n      const s = this.getLabels();\n      for (e = 0, i = s.length; e < i; ++e) t.push(xa(this, s[e]));\n      return this._cache.labels = this._normalized ? t : this.normalize(t);\n    }\n    normalize(t) {\n      return rt(t.sort(ba));\n    }\n  }\n  function Ma(t, e, i) {\n    let s,\n      n,\n      o,\n      a,\n      r = 0,\n      l = t.length - 1;\n    i ? (e >= t[r].pos && e <= t[l].pos && ({\n      lo: r,\n      hi: l\n    } = et(t, \"pos\", e)), {\n      pos: s,\n      time: o\n    } = t[r], {\n      pos: n,\n      time: a\n    } = t[l]) : (e >= t[r].time && e <= t[l].time && ({\n      lo: r,\n      hi: l\n    } = et(t, \"time\", e)), {\n      time: s,\n      pos: o\n    } = t[r], {\n      time: n,\n      pos: a\n    } = t[l]);\n    const h = n - s;\n    return h ? o + (a - o) * (e - s) / h : o;\n  }\n  wa.id = \"time\", wa.defaults = {\n    bounds: \"data\",\n    adapters: {},\n    time: {\n      parser: !1,\n      unit: !1,\n      round: !1,\n      isoWeekday: !1,\n      minUnit: \"millisecond\",\n      displayFormats: {}\n    },\n    ticks: {\n      source: \"auto\",\n      major: {\n        enabled: !1\n      }\n    }\n  };\n  class ka extends wa {\n    constructor(t) {\n      super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;\n    }\n    initOffsets() {\n      const t = this._getTimestampsForTable(),\n        e = this._table = this.buildLookupTable(t);\n      this._minPos = Ma(e, this.min), this._tableRange = Ma(e, this.max) - this._minPos, super.initOffsets(t);\n    }\n    buildLookupTable(t) {\n      const {\n          min: e,\n          max: i\n        } = this,\n        s = [],\n        n = [];\n      let o, a, r, l, h;\n      for (o = 0, a = t.length; o < a; ++o) l = t[o], l >= e && l <= i && s.push(l);\n      if (s.length < 2) return [{\n        time: e,\n        pos: 0\n      }, {\n        time: i,\n        pos: 1\n      }];\n      for (o = 0, a = s.length; o < a; ++o) h = s[o + 1], r = s[o - 1], l = s[o], Math.round((h + r) / 2) !== l && n.push({\n        time: l,\n        pos: o / (a - 1)\n      });\n      return n;\n    }\n    _getTimestampsForTable() {\n      let t = this._cache.all || [];\n      if (t.length) return t;\n      const e = this.getDataTimestamps(),\n        i = this.getLabelTimestamps();\n      return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t;\n    }\n    getDecimalForValue(t) {\n      return (Ma(this._table, t) - this._minPos) / this._tableRange;\n    }\n    getValueForPixel(t) {\n      const e = this._offsets,\n        i = this.getDecimalForPixel(t) / e.factor - e.end;\n      return Ma(this._table, i * this._tableRange + this._minPos, !0);\n    }\n  }\n  ka.id = \"timeseries\", ka.defaults = wa.defaults;\n  var Sa = Object.freeze({\n    __proto__: null,\n    CategoryScale: ta,\n    LinearScale: sa,\n    LogarithmicScale: oa,\n    RadialLinearScale: ga,\n    TimeScale: wa,\n    TimeSeriesScale: ka\n  });\n  return bn.register(Bn, Sa, co, Jo), bn.helpers = _objectSpread({}, Ti), bn._adapters = wn, bn.Animation = xs, bn.Animations = ys, bn.animator = mt, bn.controllers = Us.controllers.items, bn.DatasetController = Ls, bn.Element = Es, bn.elements = co, bn.Interaction = Vi, bn.layouts = Zi, bn.platforms = ps, bn.Scale = $s, bn.Ticks = Is, Object.assign(bn, Bn, Sa, co, Jo, ps), bn.Chart = bn, \"undefined\" != typeof window && (window.Chart = bn), bn;\n});","export default \"data:image/svg+xml;base64,PHN2ZyBkYXRhLW5hbWU9IkxheWVyIDEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDcuNDggNy40OCIgc3R5bGU9InRyYW5zZm9ybTpyb3RhdGUoNDVkZWcpIj48cGF0aCBkPSJNMy43NCA2LjQ4VjFNMSAzLjc0aDUuNDgiIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiNmZmY7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS13aWR0aDoycHgiLz48L3N2Zz4=\"","export default \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgc3Ryb2tlPSIjNEM5N0ZGIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHBhdGggc3R5bGU9ImZpbGw6IzU3NWU3NTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MTtwYWludC1vcmRlcjptYXJrZXJzIHN0cm9rZSBmaWxsIiBkPSJNNCAzLjVjLS44MzEgMC0xLjUuNjY5LTEuNSAxLjV2MTBjMCAuODMxLjY2OSAxLjUgMS41IDEuNWgxMmMuODMxIDAgMS41LS42NjkgMS41LTEuNVY1YzAtLjgzMS0uNjY5LTEuNS0xLjUtMS41Wm0wIDFoMTJjLjI3NyAwIC41LjIyMy41LjV2MTBjMCAuMjc3LS4yMjMuNS0uNS41SDRhLjQ5OS40OTkgMCAwIDEtLjUtLjVWNWMwLS4yNzcuMjIzLS41LjUtLjVaIiBzdHJva2U9Im5vbmUiLz48cGF0aCBkPSJtNS40MTcgNy41IDMuNzUgMi41LTMuNzUgMi41bTUgMGg0LjE2NiIgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzhmOGY4ZjtzdHJva2Utd2lkdGg6MTtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIi8+PC9nPjwvc3ZnPg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGQ9Ik00LjU0OCA3aDEwLjkwNGEuNS41IDAgMCAxIC40OTguNTQ1bC0uNzg1IDguNjM1QTIgMiAwIDAgMSAxMy4xNzQgMThINi44MjdhMiAyIDAgMCAxLTEuOTkyLTEuODJMNC4wNSA3LjU0NkEuNS41IDAgMCAxIDQuNTQ4IDd6bTIuNzg1LTMgLjU1My0xLjY1OEEuNS41IDAgMCAxIDguMzYgMmgzLjI4YS41LjUgMCAwIDEgLjQ3NC4zNDJMMTIuNjY3IDRIMTYuNWEuNS41IDAgMCAxIC41LjV2MWEuNS41IDAgMCAxLS41LjVoLTEzYS41LjUgMCAwIDEtLjUtLjV2LTFhLjUuNSAwIDAgMSAuNS0uNWgzLjgzM3ptMS4wNTQgMGgzLjIyNmwtLjMzNC0xSDguNzIxbC0uMzM0IDF6TTEwIDExLjcybDEuNTk1LTEuNTk1YS41LjUgMCAwIDEgLjcwNyAwbC4wNzMuMDczYS41LjUgMCAwIDEgMCAuNzA3TDEwLjc4IDEyLjVsMS41OTUgMS41OTVhLjUuNSAwIDAgMSAwIC43MDdsLS4wNzMuMDczYS41LjUgMCAwIDEtLjcwNyAwTDEwIDEzLjI4bC0xLjU5NSAxLjU5NWEuNS41IDAgMCAxLS43MDcgMGwtLjA3My0uMDczYS41LjUgMCAwIDEgMC0uNzA3TDkuMjIgMTIuNWwtMS41OTUtMS41OTVhLjUuNSAwIDAgMSAwLS43MDdsLjA3My0uMDczYS41LjUgMCAwIDEgLjcwNyAwTDEwIDExLjcyeiIgaWQ9ImEiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48ZyBtYXNrPSJ1cmwoI2IpIiBmaWxsPSIjRkZGIj48cGF0aCBkPSJNMCAwaDIwdjIwSDB6Ii8+PC9nPjwvZz48L3N2Zz4=\"","export default \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTE0LjczIDguNzc5LTQuMjUzIDQuMjY0YS42MTkuNjE5IDAgMCAxLS44OSAwTDUuMzM2IDguNzc5QS42My42MyAwIDAgMSA1Ljc4OCA3LjdoMi4xMTdsMS4yNjMtNS4wMTZhLjkxMi45MTIgMCAwIDEgMS4xMDYtLjY1Ni44OS44OSAwIDAgMSAuNjY4LjY1NkwxMi4yMDYgNy43aDIuMDcyYy41NTkgMCAuODU2LjY3LjQ1MSAxLjA3OHpNMTggMTEuODEydjIuNTc5QzE4IDE2LjM3NSAxNi4zOTUgMTggMTQuNDE3IDE4SDUuNkEzLjYwNyAzLjYwNyAwIDAgMSAyIDE0LjM5di0yLjU3OGExLjE3IDEuMTcgMCAxIDEgMi4zMzcgMHYyLjU3OUExLjI3IDEuMjcgMCAwIDAgNS42IDE1LjY1Nmg4LjgxN2MuNjg2IDAgMS4yNDYtLjU3OCAxLjI0Ni0xLjI2NXYtMi41NzljMC0uNjU2LjUzLTEuMTcyIDEuMTY5LTEuMTcyLjY1NCAwIDEuMTY4LjUxNiAxLjE2OCAxLjE3MnoiIGZpbGw9IiNGRkYiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgMjQgMjQiIHN0eWxlPSItbXMtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKSI+PHBhdGggZD0iTTEyIDE0YTEuMjUgMS4yNSAwIDEgMCAxLjI1IDEuMjVBMS4yNSAxLjI1IDAgMCAwIDEyIDE0em0wLTEuNWExIDEgMCAwIDAgMS0xdi0zYTEgMSAwIDAgMC0yIDB2M2ExIDEgMCAwIDAgMSAxek0xMiAyYTEwIDEwIDAgMSAwIDEwIDEwQTEwLjAxMSAxMC4wMTEgMCAwIDAgMTIgMnptMCAxOGE4IDggMCAxIDEgOC04IDguMDEgOC4wMSAwIDAgMS04IDh6IiBmaWxsPSJyZWQiLz48L3N2Zz4=\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgMjQgMjQiIHN0eWxlPSItbXMtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKSI+PHBhdGggZD0iTTMgN2gxOGExIDEgMCAwIDAgMC0ySDNhMSAxIDAgMCAwIDAgMnptMCA0aDE0YTEgMSAwIDAgMCAwLTJIM2ExIDEgMCAwIDAgMCAyem0xOCAySDNhMSAxIDAgMCAwIDAgMmgxOGExIDEgMCAwIDAgMC0yem0tNCA0SDNhMSAxIDAgMCAwIDAgMmgxNGExIDEgMCAwIDAgMC0yeiIgZmlsbD0iIzg1NWNkNiIvPjwvc3ZnPg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlPSJjdXJyZW50Q29sb3IiPjxwYXRoIHN0cm9rZT0iIzg1NWNkNiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiIGQ9Ik05IDE5di02YTIgMiAwIDAgMC0yLTJINWEyIDIgMCAwIDAtMiAydjZhMiAyIDAgMCAwIDIgMmgyYTIgMiAwIDAgMCAyLTJ6bTAgMFY5YTIgMiAwIDAgMSAyLTJoMmEyIDIgMCAwIDEgMiAydjEwbS02IDBhMiAyIDAgMCAwIDIgMmgyYTIgMiAwIDAgMCAyLTJtMCAwVjVhMiAyIDAgMCAxIDItMmgyYTIgMiAwIDAgMSAyIDJ2MTRhMiAyIDAgMCAxLTIgMmgtMmEyIDIgMCAwIDEtMi0yeiIvPjwvc3ZnPg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDkiIGhlaWdodD0iNTIiIHZpZXdCb3g9Ii01IDAgNDkgNDgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGQ9Ik0xNy4yMjEgOC4zNDVjMi41NTYtNC4yNTkgNi43MDItNC4yNTIgOS4yNTQgMGwxMy42NzcgMjIuNzk2YzIuNTU1IDQuMjU4LjU5NyA3LjcxLTQuMzggNy43MUg3LjkyNGMtNC45NzMgMC02LjkzLTMuNDU4LTQuMzgtNy43MUwxNy4yMjIgOC4zNDV6IiBpZD0iYSIvPjwvZGVmcz48dXNlIHN0cm9rZT0iI0ZGRiIgZmlsbD0iI0ZGRiIgeGxpbms6aHJlZj0iI2EiIHRyYW5zZm9ybT0icm90YXRlKDkwIDIwLjg1IDIzLjAwMykiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkiIGhlaWdodD0iMTkiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMjIuNjggMTIuMmExLjYgMS42IDAgMCAxLTEuMjcuNjNoLTcuNjlhMS41OSAxLjU5IDAgMCAxLTEuMTYtMi41OGwxLjEyLTEuNDFhNC44MiA0LjgyIDAgMCAwLTMuMTQtLjc3IDQuMzEgNC4zMSAwIDAgMC0yIC44QTQuMjUgNC4yNSAwIDAgMCA3LjIgMTAuNmE1LjA2IDUuMDYgMCAwIDAgLjU0IDQuNjJBNS41OCA1LjU4IDAgMCAwIDEyIDE3Ljc0YTIuMjYgMi4yNiAwIDAgMS0uMTYgNC41MkExMC4yNSAxMC4yNSAwIDAgMSAzLjc0IDE4YTEwLjE0IDEwLjE0IDAgMCAxLTEuNDktOS4yMiA5LjcgOS43IDAgMCAxIDIuODMtNC4xNEE5LjkyIDkuOTIgMCAwIDEgOS42NiAyLjVhMTAuNjYgMTAuNjYgMCAwIDEgNy43MiAxLjY4bDEuMDgtMS4zNWExLjU3IDEuNTcgMCAwIDEgMS4yNC0uNiAxLjYgMS42IDAgMCAxIDEuNTQgMS4yMWwxLjcgNy4zN2ExLjU3IDEuNTcgMCAwIDEtLjI2IDEuMzlaIiBzdHlsZT0iZmlsbDojZmZmIi8+PHBhdGggZD0iTTIxLjM4IDExLjgzaC03LjYxYS41OS41OSAwIDAgMS0uNDMtMWwxLjc1LTIuMTlhNS45IDUuOSAwIDAgMC00LjctMS41OCA1LjA3IDUuMDcgMCAwIDAtNC4xMSAzLjE3QTYgNiAwIDAgMCA3IDE1Ljc3YTYuNTEgNi41MSAwIDAgMCA1IDIuOTIgMS4zMSAxLjMxIDAgMCAxLS4wOCAyLjYyIDkuMyA5LjMgMCAwIDEtNy4zNS0zLjgyIDkuMTYgOS4xNiAwIDAgMS0xLjQtOC4zN0E4LjUxIDguNTEgMCAwIDEgNS43MSA1LjRhOC43NiA4Ljc2IDAgMCAxIDQuMTEtMS45MiA5LjcxIDkuNzEgMCAwIDEgNy43NSAyLjA3bDEuNjctMi4xYS41OS41OSAwIDAgMSAxIC4yMUwyMiAxMS4wOGEuNTkuNTkgMCAwIDEtLjYyLjc1WiIgc3R5bGU9ImZpbGw6I2ZmZiIvPjwvc3ZnPg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgMjQgMjQiIHN0eWxlPSItbXMtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKSI+PHBhdGggZD0iTTIwLjkyIDEyLjYyYTEgMSAwIDAgMC0uMjEtLjMzbC0zLTNhMSAxIDAgMCAwLTEuNDIgMS40MmwxLjMgMS4yOUg4YTEgMSAwIDAgMS0xLTFWN2ExIDEgMCAwIDAtMiAwdjRhMyAzIDAgMCAwIDMgM2g5LjU5bC0xLjMgMS4yOWExIDEgMCAwIDAgMCAxLjQyIDEgMSAwIDAgMCAxLjQyIDBsMy0zYTEgMSAwIDAgMCAuMjEtLjMzIDEgMSAwIDAgMCAwLS43NnoiIGZpbGw9ImdyYXkiLz48L3N2Zz4=\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgMjQgMjQiIHN0eWxlPSItbXMtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKSI+PHBhdGggZD0iTTE5IDJIOWEzIDMgMCAwIDAtMyAzdjFINWEzIDMgMCAwIDAtMyAzdjEwYTMgMyAwIDAgMCAzIDNoMTBhMyAzIDAgMCAwIDMtM3YtMWgxYTMgMyAwIDAgMCAzLTNWNWEzIDMgMCAwIDAtMy0zem0tMyAxN2ExIDEgMCAwIDEtMSAxSDVhMSAxIDAgMCAxLTEtMXYtN2gxMnptMC05SDRWOWExIDEgMCAwIDEgMS0xaDEwYTEgMSAwIDAgMSAxIDF6bTQgNWExIDEgMCAwIDEtMSAxaC0xVjlhMyAzIDAgMCAwLS4xOC0xSDIwem0wLTlIOFY1YTEgMSAwIDAgMSAxLTFoMTBhMSAxIDAgMCAxIDEgMXoiIGZpbGw9IiM4NTVjZDYiLz48L3N2Zz4=\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgMjQgMjQiIHN0eWxlPSItbXMtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKSI+PHBhdGggZD0iTTEyIDE2YTEgMSAwIDEgMCAxIDEgMSAxIDAgMCAwLTEtMXptMTAuNjcgMS40Ny04LjA1LTE0YTMgMyAwIDAgMC01LjI0IDBsLTggMTRBMyAzIDAgMCAwIDMuOTQgMjJoMTYuMTJhMyAzIDAgMCAwIDIuNjEtNC41M3ptLTEuNzMgMmExIDEgMCAwIDEtLjg4LjUxSDMuOTRhMSAxIDAgMCAxLS44OC0uNTEgMSAxIDAgMCAxIDAtMWw4LTE0YTEgMSAwIDAgMSAxLjc4IDBsOC4wNSAxNGExIDEgMCAwIDEgLjA1IDEuMDJ6TTEyIDhhMSAxIDAgMCAwLTEgMXY0YTEgMSAwIDAgMCAyIDBWOWExIDEgMCAwIDAtMS0xeiIgZmlsbD0iI2UwYmIwMCIvPjwvc3ZnPg==\""],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9BA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3NA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7KA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrLA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/kBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1HA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/BA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACp5TA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;A","sourceRoot":""}