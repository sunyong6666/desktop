{"version":3,"file":"addon-entry-blocks2image.index.js","sources":["webpack:///./node_modules/scratch-gui/src/addons/addons/blocks2image/_runtime_entry.js","webpack:///./node_modules/scratch-gui/src/addons/addons/blocks2image/userscript.js"],"sourcesContent":["/* generated by pull.js */\nimport _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js\n};","export default async function (_ref) {\n  let {\n    addon,\n    console,\n    msg\n  } = _ref;\n  const Blockly = await addon.tab.traps.getBlockly();\n  function makeStyle() {\n    let style = document.createElement(\"style\");\n    style.textContent = \"\\n    .blocklyText {\\n        fill: \".concat(Blockly.Colours.text, \";\\n        font-family: \\\"Helvetica Neue\\\", Helvetica, sans-serif;\\n        font-size: 12pt;\\n        font-weight: 500;\\n    }\\n    .blocklyNonEditableText>text, .blocklyEditableText>text {\\n        fill: \").concat(Blockly.Colours.textFieldText, \";\\n    }\\n    .blocklyDropdownText {\\n        fill: \").concat(Blockly.Colours.text, \" !important;\\n    }\\n    \");\n    for (let userstyle of document.querySelectorAll(\".scratch-addons-style[data-addons*='editor-theme3']\")) {\n      if (userstyle.disabled) continue;\n      style.textContent += userstyle.textContent;\n    }\n    return style;\n  }\n  function setCSSVars(element) {\n    for (let property of document.documentElement.style) {\n      if (property.startsWith(\"--editorTheme3-\")) element.style.setProperty(property, document.documentElement.style.getPropertyValue(property));\n    }\n  }\n  let exSVG = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  exSVG.setAttribute(\"xmlns:html\", \"http://www.w3.org/1999/xhtml\");\n  exSVG.setAttribute(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n  exSVG.setAttribute(\"version\", \"1.1\");\n  addon.tab.createBlockContextMenu(items => {\n    var _svgchild$childNodes, _svgchild$childNodes2;\n    if (addon.self.disabled) return items;\n    let svgchild = document.querySelector(\"svg.blocklySvg g.blocklyBlockCanvas\");\n    const pasteItemIndex = items.findIndex(obj => obj._isDevtoolsFirstItem);\n    const insertBeforeIndex = pasteItemIndex !== -1 ?\n    // If \"paste\" button exists, add own items before it\n    pasteItemIndex :\n    // If there's no such button, insert at end\n    items.length;\n    items.splice(insertBeforeIndex, 0, {\n      enabled: !!(svgchild !== null && svgchild !== void 0 && (_svgchild$childNodes = svgchild.childNodes) !== null && _svgchild$childNodes !== void 0 && _svgchild$childNodes.length),\n      text: msg(\"export_all_to_SVG\"),\n      callback: () => {\n        exportBlock(false);\n      },\n      separator: true\n    }, {\n      enabled: !!(svgchild !== null && svgchild !== void 0 && (_svgchild$childNodes2 = svgchild.childNodes) !== null && _svgchild$childNodes2 !== void 0 && _svgchild$childNodes2.length),\n      text: msg(\"export_all_to_PNG\"),\n      callback: () => {\n        exportBlock(true);\n      },\n      separator: false\n    });\n    return items;\n  }, {\n    workspace: true\n  });\n  addon.tab.createBlockContextMenu((items, block) => {\n    if (addon.self.disabled) return items;\n    const makeSpaceItemIndex = items.findIndex(obj => obj._isDevtoolsFirstItem);\n    const insertBeforeIndex = makeSpaceItemIndex !== -1 ?\n    // If \"make space\" button exists, add own items before it\n    makeSpaceItemIndex :\n    // If there's no such button, insert at end\n    items.length;\n    items.splice(insertBeforeIndex, 0, {\n      enabled: true,\n      text: msg(\"export_selected_to_SVG\"),\n      callback: () => {\n        exportBlock(false, block);\n      },\n      separator: true\n    }, {\n      enabled: true,\n      text: msg(\"export_selected_to_PNG\"),\n      callback: () => {\n        exportBlock(true, block);\n      },\n      separator: false\n    });\n    return items;\n  }, {\n    blocks: true\n  });\n  async function exportBlock(isExportPNG, block) {\n    let svg;\n    if (block) {\n      svg = selectedBlocks(isExportPNG, block);\n    } else {\n      svg = allBlocks(isExportPNG);\n    }\n    // resolve nbsp whitespace\n    svg.querySelectorAll(\"text\").forEach(text => {\n      text.innerHTML = text.innerHTML.replace(/&nbsp;/g, \" \");\n    });\n\n    // replace external images with data URIs\n    await Promise.all(Array.from(svg.querySelectorAll(\"image\")).map(async item => {\n      const iconUrl = item.getAttribute(\"xlink:href\");\n      if (iconUrl.startsWith(\"data:\")) return;\n      const blob = await (await fetch(iconUrl)).blob();\n      const reader = new FileReader();\n      const dataUri = await new Promise(resolve => {\n        reader.addEventListener(\"load\", () => resolve(reader.result));\n        reader.readAsDataURL(blob);\n      });\n      item.setAttribute(\"xlink:href\", dataUri);\n    }));\n    if (!isExportPNG) {\n      exportData(new XMLSerializer().serializeToString(svg));\n    } else {\n      exportPNG(svg);\n    }\n  }\n  function selectedBlocks(isExportPNG, block) {\n    let svg = exSVG.cloneNode();\n    let svgchild = block.svgGroup_;\n    svgchild = svgchild.cloneNode(true);\n    let dataShapes = svgchild.getAttribute(\"data-shapes\");\n    let translateY = 0; // blocks no hat\n    const scale = isExportPNG ? 2 : 1;\n    if (dataShapes === \"c-block c-1 hat\") {\n      translateY = 20; // for My block\n    }\n    if (dataShapes === \"hat\") {\n      translateY = 16; // for Events\n      if (block.CAT_BLOCKS) {\n        translateY += 16; // for cat ears\n      }\n    }\n    svgchild.setAttribute(\"transform\", \"translate(0,\".concat(scale * translateY, \") scale(\").concat(scale, \")\"));\n    setCSSVars(svg);\n    svg.append(makeStyle());\n    svg.append(svgchild);\n    return svg;\n  }\n  function allBlocks(isExportPNG) {\n    let svg = exSVG.cloneNode();\n    let svgchild = document.querySelector(\"svg.blocklySvg g.blocklyBlockCanvas\");\n    svgchild = svgchild.cloneNode(true);\n    let xArr = [];\n    let yArr = [];\n    svgchild.childNodes.forEach(g => {\n      let x = g.getAttribute(\"transform\").match(/translate\\((.*?),(.*?)\\)/)[1] || 0;\n      let y = g.getAttribute(\"transform\").match(/translate\\((.*?),(.*?)\\)/)[2] || 0;\n      xArr.push(x * (isExportPNG ? 2 : 1));\n      yArr.push(y * (isExportPNG ? 2 : 1));\n      g.style.display = \"\"; // because of TW scratch-blocks changes\n    });\n    svgchild.setAttribute(\"transform\", \"translate(\".concat(-Math.min(...xArr), \",\").concat(-Math.min(...yArr) + 18 * (isExportPNG ? 2 : 1), \") \").concat(isExportPNG ? \"scale(2)\" : \"\"));\n    setCSSVars(svg);\n    svg.append(makeStyle());\n    svg.append(svgchild);\n    return svg;\n  }\n  function exportData(text) {\n    const saveLink = document.createElement(\"a\");\n    document.body.appendChild(saveLink);\n    const data = new Blob([text], {\n      type: \"text\"\n    });\n    const url = window.URL.createObjectURL(data);\n    saveLink.href = url;\n\n    // File name: project-DATE-TIME\n    const date = new Date();\n    const timestamp = \"\".concat(date.toLocaleDateString(), \"-\").concat(date.toLocaleTimeString());\n    saveLink.download = \"block_\".concat(timestamp, \".svg\");\n    saveLink.click();\n    window.URL.revokeObjectURL(url);\n    document.body.removeChild(saveLink);\n  }\n  function exportPNG(svg) {\n    const serializer = new XMLSerializer();\n    const iframe = document.createElement(\"iframe\");\n    // iframe.style.display = \"none\"\n    document.body.append(iframe);\n    iframe.contentDocument.write(serializer.serializeToString(svg));\n    let {\n      width,\n      height\n    } = iframe.contentDocument.body.querySelector(\"svg g\").getBoundingClientRect();\n    svg.setAttribute(\"width\", width + \"px\");\n    svg.setAttribute(\"height\", height + \"px\");\n    let canvas = document.createElement(\"canvas\");\n    let ctx = canvas.getContext(\"2d\");\n    let img = document.createElement(\"img\");\n    img.setAttribute(\"src\", \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(serializer.serializeToString(svg)))));\n    img.onload = function () {\n      canvas.height = img.height;\n      canvas.width = img.width;\n      ctx.drawImage(img, 0, 0, img.width, img.height);\n      // Now is done\n      let dataURL = canvas.toDataURL(\"image/png\");\n      let link = document.createElement(\"a\");\n      const date = new Date();\n      const timestamp = \"\".concat(date.toLocaleDateString(), \"-\").concat(date.toLocaleTimeString());\n      link.download = \"block_\".concat(timestamp, \".png\");\n      link.href = dataURL;\n      link.click();\n      iframe.remove();\n    };\n  }\n}"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}