{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{1375:function(e,t,n){\"use strict\";function s(e,t,n){const s=n.Events.isEnabled();if(n.Events.disable(),t){e.editingTarget&&e.emitWorkspaceUpdate();const n=t.getFlyout();if(n){const e=n.getWorkspace();window.Blockly.Xml.clearWorkspaceAndLoadFromXml(window.Blockly.Xml.workspaceToDom(e),e),t.getToolbox().refreshSelection(),t.toolboxRefreshEnabled_=!0}}s&&n.Events.enable()}n.d(t,\"a\",(function(){return s}))},1377:function(e,t,n){\"use strict\";n.d(t,\"b\",(function(){return a})),n.d(t,\"a\",(function(){return d})),n.d(t,\"c\",(function(){return r}));var s=n(366);const o=new Map,c=1e3,l=new s.a,i=\"clearTextCache\";function a(e){let t=e.innerHTML;if(0===t.length)return 0;let n=o.get(t);return n||(n=e.getBoundingClientRect().width,o.set(t,n),o.size>c&&o.delete(o.keys().next()),n)}function d(){o.clear(),l.dispatchEvent(new CustomEvent(i))}function r(e){l.addEventListener(i,e)}},1541:function(e,t,n){\"use strict\";n.r(t),n.d(t,\"resources\",(function(){return c}));var s=n(1375),o=n(1377);const c={\"userscript.js\":async function(e){let{addon:t,console:n}=e,c=100;const l=t.tab.traps.vm,i=await t.tab.traps.getBlockly(),a=document.createElement(\"style\");a.textContent=\"\\n    .blocklyText,\\n    .blocklyHtmlInput {\\n      font-size: calc(var(--customBlockText-sizeSetting) * 0.12pt) !important;\\n    }\\n    .blocklyFlyoutLabelText {\\n      font-size: calc(var(--customBlockText-sizeSetting) * 0.14pt) !important;\\n    }\",a.disabled=!0,document.head.appendChild(a);const d=document.createElement(\"style\");d.textContent=\"\\n    .blocklyText,\\n    .blocklyHtmlInput {\\n      font-weight: bold;\\n    }\",d.disabled=!0,document.head.appendChild(d);const r=document.createElement(\"style\");r.textContent=\"\\n    .blocklyDraggable > .blocklyText,\\n    .blocklyDraggable > g > text {\\n      text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.4);\\n    }\",r.disabled=!0,document.head.appendChild(r);const u=()=>{i.Field.cacheWidths_={},Object(o.a)(),Object(s.a)(l,t.tab.traps.getWorkspace(),i)},g=e=>{if(100!==e&&document.documentElement.style.setProperty(\"--customBlockText-sizeSetting\",e),100===e)return a.disabled=!0,void(c=100);e!==c&&(c=e,a.disabled=!1)},b=e=>{d.disabled=!e},p=e=>{r.disabled=!e};t.settings.addEventListener(\"change\",(()=>{g(t.settings.get(\"size\")),b(t.settings.get(\"bold\")),p(t.settings.get(\"shadow\")),u()})),t.self.addEventListener(\"disabled\",(()=>{g(100),b(!1),p(!1),u()})),t.self.addEventListener(\"reenabled\",(()=>{g(t.settings.get(\"size\")),b(t.settings.get(\"bold\")),p(t.settings.get(\"shadow\")),u()})),g(t.settings.get(\"size\")),b(t.settings.get(\"bold\")),p(t.settings.get(\"shadow\")),u()}}}}]);","name":"8.index.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[8],{\n\n/***/ 1375:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return updateAllBlocks; });\nfunction updateAllBlocks(vm, workspace, blockly) {\n  const eventsOriginallyEnabled = blockly.Events.isEnabled();\n  blockly.Events.disable(); // Clears workspace right-clickâ†’undo (see SA/SA#6691)\n\n  if (workspace) {\n    if (vm.editingTarget) {\n      vm.emitWorkspaceUpdate();\n    }\n    const flyout = workspace.getFlyout();\n    if (flyout) {\n      const flyoutWorkspace = flyout.getWorkspace();\n      window.Blockly.Xml.clearWorkspaceAndLoadFromXml(window.Blockly.Xml.workspaceToDom(flyoutWorkspace), flyoutWorkspace);\n      workspace.getToolbox().refreshSelection();\n      workspace.toolboxRefreshEnabled_ = true;\n    }\n  }\n\n  // There's no particular reason for checking whether events were originally enabled.\n  // Unconditionally enabling events at this point could, in theory, cause bugs in the future.\n  if (eventsOriginallyEnabled) blockly.Events.enable(); // Re-enable events\n}\n\n/***/ }),\n\n/***/ 1377:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return getTextWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return clearTextWidthCache; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return onClearTextWidthCache; });\n/* harmony import */ var _event_target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(366);\n /* inserted by pull.js */\n\nconst textWidthCache = new Map();\nconst textWidthCacheSize = 1000;\nconst eventTarget = new _event_target_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"]();\nconst eventClearTextCache = \"clearTextCache\";\n\n/**\n * Gets the width of an svg text element, with caching.\n * @param {SVGTextElement} textElement\n */\nfunction getTextWidth(textElement) {\n  let string = textElement.innerHTML;\n  if (string.length === 0) return 0;\n  let width = textWidthCache.get(string);\n  if (width) return width;\n  width = textElement.getBoundingClientRect().width;\n  textWidthCache.set(string, width);\n  if (textWidthCache.size > textWidthCacheSize) {\n    textWidthCache.delete(textWidthCache.keys().next());\n  }\n  return width;\n}\n\n/**\n * Clears the text width cache of the middle click popup.\n */\nfunction clearTextWidthCache() {\n  textWidthCache.clear();\n  eventTarget.dispatchEvent(new CustomEvent(eventClearTextCache));\n}\n\n/**\n * @param {() => void} func\n */\nfunction onClearTextWidthCache(func) {\n  eventTarget.addEventListener(eventClearTextCache, func);\n}\n\n/***/ }),\n\n/***/ 1541:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"resources\", function() { return /* binding */ resources; });\n\n// EXTERNAL MODULE: ./node_modules/scratch-gui/src/addons/addons/custom-block-shape/update-all-blocks.js\nvar update_all_blocks = __webpack_require__(1375);\n\n// EXTERNAL MODULE: ./node_modules/scratch-gui/src/addons/addons/middle-click-popup/module.js\nvar middle_click_popup_module = __webpack_require__(1377);\n\n// CONCATENATED MODULE: ./node_modules/scratch-gui/src/addons/addons/custom-block-text/userscript.js\n\n\n/* harmony default export */ var userscript = (async function (_ref) {\n  let {\n    addon,\n    console\n  } = _ref;\n  let currentTextSize = 100;\n  const vm = addon.tab.traps.vm;\n  const blocklyInstance = await addon.tab.traps.getBlockly();\n\n  // Handling the CSS from here instead of a userstyle is much more stable, as\n  // there's no code outside of this addon dynamically toggling the styles.\n  // This way, we can clearly control the execution order of style operations.\n  // For example, we always want to call updateAllBlocks() after the styles\n  // were updated according to the user's settings, not before.\n  const fontSizeCss = document.createElement(\"style\");\n  // Be careful with specificity because we're adding this userstyle manually\n  // to the <head> without checking if other styles are above or below.\n  fontSizeCss.textContent = \"\\n    .blocklyText,\\n    .blocklyHtmlInput {\\n      font-size: calc(var(--customBlockText-sizeSetting) * 0.12pt) !important;\\n    }\\n    .blocklyFlyoutLabelText {\\n      font-size: calc(var(--customBlockText-sizeSetting) * 0.14pt) !important;\\n    }\";\n  fontSizeCss.disabled = true;\n  document.head.appendChild(fontSizeCss);\n  //\n  const boldCss = document.createElement(\"style\");\n  boldCss.textContent = \"\\n    .blocklyText,\\n    .blocklyHtmlInput {\\n      font-weight: bold;\\n    }\";\n  boldCss.disabled = true;\n  document.head.appendChild(boldCss);\n  //\n  const textShadowCss = document.createElement(\"style\");\n  textShadowCss.textContent = \"\\n    .blocklyDraggable > .blocklyText,\\n    .blocklyDraggable > g > text {\\n      text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.4);\\n    }\";\n  textShadowCss.disabled = true;\n  document.head.appendChild(textShadowCss);\n  const updateBlockly = () => {\n    blocklyInstance.Field.cacheWidths_ = {}; // Clear text width cache\n    // If font size has changed, middle click popup needs to clear it's cache too\n    Object(middle_click_popup_module[\"a\" /* clearTextWidthCache */])();\n    Object(update_all_blocks[\"a\" /* updateAllBlocks */])(vm, addon.tab.traps.getWorkspace(), blocklyInstance);\n  };\n  const setFontSize = wantedSize => {\n    if (wantedSize !== 100) document.documentElement.style.setProperty(\"--customBlockText-sizeSetting\", wantedSize);\n    if (wantedSize === 100) {\n      fontSizeCss.disabled = true;\n      currentTextSize = 100;\n      return;\n    } else if (wantedSize === currentTextSize) return;\n    currentTextSize = wantedSize;\n    fontSizeCss.disabled = false;\n  };\n  const setBold = bool => {\n    boldCss.disabled = !bool;\n  };\n  const setTextShadow = bool => {\n    textShadowCss.disabled = !bool;\n  };\n  addon.settings.addEventListener(\"change\", () => {\n    setFontSize(addon.settings.get(\"size\"));\n    setBold(addon.settings.get(\"bold\"));\n    setTextShadow(addon.settings.get(\"shadow\"));\n    updateBlockly();\n  });\n  addon.self.addEventListener(\"disabled\", () => {\n    setFontSize(100);\n    setBold(false);\n    setTextShadow(false);\n    updateBlockly();\n  });\n  addon.self.addEventListener(\"reenabled\", () => {\n    setFontSize(addon.settings.get(\"size\"));\n    setBold(addon.settings.get(\"bold\"));\n    setTextShadow(addon.settings.get(\"shadow\"));\n    updateBlockly();\n  });\n  setFontSize(addon.settings.get(\"size\"));\n  setBold(addon.settings.get(\"bold\"));\n  setTextShadow(addon.settings.get(\"shadow\"));\n  updateBlockly();\n});\n// CONCATENATED MODULE: ./node_modules/scratch-gui/src/addons/addons/custom-block-text/_runtime_entry.js\n/* generated by pull.js */\n\nconst resources = {\n  \"userscript.js\": userscript\n};\n\n/***/ })\n\n}]);","inputSourceMap":null}