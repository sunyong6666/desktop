{"code":"!function(n){var e={};function t(r){if(e[r])return e[r].exports;var a=e[r]={i:r,l:!1,exports:{}};return n[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(n,\"__esModule\",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&\"object\"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:n}),2&e&&\"string\"!=typeof n)for(var a in n)t.d(r,a,function(e){return n[e]}.bind(null,a));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,\"a\",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p=\"\",t(t.s=7)}([function(n,e,t){const r=t(17);r.enable(),n.exports=r(\"vm\")},function(n,e){n.exports={ANGLE:\"angle\",BOOLEAN:\"Boolean\",COLOR:\"color\",NUMBER:\"number\",STRING:\"string\",MATRIX:\"matrix\",NOTE:\"note\",IMAGE:\"image\",COSTUME:\"costume\",SOUND:\"sound\"}},function(n,e){n.exports={BOOLEAN:\"Boolean\",BUTTON:\"button\",LABEL:\"label\",COMMAND:\"command\",CONDITIONAL:\"conditional\",EVENT:\"event\",HAT:\"hat\",LOOP:\"loop\",REPORTER:\"reporter\",XML:\"xml\"}},function(n,e){n.exports={isWorker:!0,centralDispatchService:self}},function(n,e){var t=\"long\",r=\"short\",a=\"narrow\",i=\"numeric\",o=\"2-digit\";n.exports={number:{decimal:{style:\"decimal\"},integer:{style:\"decimal\",maximumFractionDigits:0},currency:{style:\"currency\",currency:\"USD\"},percent:{style:\"percent\"},default:{style:\"decimal\"}},date:{short:{month:i,day:i,year:o},medium:{month:r,day:i,year:i},long:{month:t,day:i,year:i},full:{month:t,day:i,year:i,weekday:t},default:{month:r,day:i,year:i}},time:{short:{hour:i,minute:i},medium:{hour:i,minute:i,second:i},long:{hour:i,minute:i,second:i,timeZoneName:r},full:{hour:i,minute:i,second:i,timeZoneName:r},default:{hour:i,minute:i,second:i}},duration:{default:{hours:{minimumIntegerDigits:1,maximumFractionDigits:0},minutes:{minimumIntegerDigits:2,maximumFractionDigits:0},seconds:{minimumIntegerDigits:2,maximumFractionDigits:3}}},parseNumberPattern:function(n){if(n){var e={},t=n.match(/\\b[A-Z]{3}\\b/i),r=n.replace(/[^¤]/g,\"\").length;if(!r&&t&&(r=1),r?(e.style=\"currency\",e.currencyDisplay=1===r?\"symbol\":2===r?\"code\":\"name\",e.currency=t?t[0].toUpperCase():\"USD\"):n.indexOf(\"%\")>=0&&(e.style=\"percent\"),!/[@#0]/.test(n))return e.style?e:void 0;if(e.useGrouping=n.indexOf(\",\")>=0,/E\\+?[@#0]+/i.test(n)||n.indexOf(\"@\")>=0){var a=n.replace(/E\\+?[@#0]+|[^@#0]/gi,\"\");e.minimumSignificantDigits=Math.min(Math.max(a.replace(/[^@0]/g,\"\").length,1),21),e.maximumSignificantDigits=Math.min(Math.max(a.length,1),21)}else{for(var i=n.replace(/[^#0.]/g,\"\").split(\".\"),o=i[0],s=o.length-1;\"0\"===o[s];)--s;e.minimumIntegerDigits=Math.min(Math.max(o.length-1-s,1),21);var c=i[1]||\"\";for(s=0;\"0\"===c[s];)++s;for(e.minimumFractionDigits=Math.min(Math.max(s,0),20);\"#\"===c[s];)++s;e.maximumFractionDigits=Math.min(Math.max(s,0),20)}return e}},parseDatePattern:function(n){if(n){for(var e={},s=0;s<n.length;){for(var c=n[s],l=1;n[++s]===c;)++l;switch(c){case\"G\":e.era=5===l?a:4===l?t:r;break;case\"y\":case\"Y\":e.year=2===l?o:i;break;case\"M\":case\"L\":l=Math.min(Math.max(l-1,0),4),e.month=[i,o,r,t,a][l];break;case\"E\":case\"e\":case\"c\":e.weekday=5===l?a:4===l?t:r;break;case\"d\":case\"D\":e.day=2===l?o:i;break;case\"h\":case\"K\":e.hour12=!0,e.hour=2===l?o:i;break;case\"H\":case\"k\":e.hour12=!1,e.hour=2===l?o:i;break;case\"m\":e.minute=2===l?o:i;break;case\"s\":case\"S\":e.second=2===l?o:i;break;case\"z\":case\"Z\":case\"v\":case\"V\":e.timeZoneName=1===l?r:t}}return Object.keys(e).length?e:void 0}}}},function(n,e){n.exports=function(n,e){if(\"string\"==typeof n&&e[n])return n;for(var t=[].concat(n||[]),r=0,a=t.length;r<a;++r)for(var i=t[r].split(\"-\");i.length;){var o=i.join(\"-\");if(e[o])return o;i.pop()}}},function(n,e,t){\"use strict\";var r=\"zero\",a=\"one\",i=\"two\",o=\"few\",s=\"many\",c=\"other\",l=[function(n){return 1===+n?a:c},function(n){var e=+n;return 0<=e&&e<=1?a:c},function(n){return 0===Math.floor(Math.abs(+n))||1===+n?a:c},function(n){var e=+n;return 0===e?r:1===e?a:2===e?i:3<=e%100&&e%100<=10?o:11<=e%100&&e%100<=99?s:c},function(n){var e=Math.floor(Math.abs(+n)),t=(n+\".\").split(\".\")[1].length;return 1===e&&0===t?a:c},function(n){var e=+n;return e%10==1&&e%100!=11?a:2<=e%10&&e%10<=4&&(e%100<12||14<e%100)?o:e%10==0||5<=e%10&&e%10<=9||11<=e%100&&e%100<=14?s:c},function(n){var e=+n;return e%10==1&&e%100!=11&&e%100!=71&&e%100!=91?a:e%10==2&&e%100!=12&&e%100!=72&&e%100!=92?i:(3<=e%10&&e%10<=4||e%10==9)&&(e%100<10||19<e%100)&&(e%100<70||79<e%100)&&(e%100<90||99<e%100)?o:0!==e&&e%1e6==0?s:c},function(n){var e=Math.floor(Math.abs(+n)),t=(n+\".\").split(\".\")[1].length,r=+(n+\".\").split(\".\")[1];return 0===t&&e%10==1&&e%100!=11||r%10==1&&r%100!=11?a:0===t&&2<=e%10&&e%10<=4&&(e%100<12||14<e%100)||2<=r%10&&r%10<=4&&(r%100<12||14<r%100)?o:c},function(n){var e=Math.floor(Math.abs(+n)),t=(n+\".\").split(\".\")[1].length;return 1===e&&0===t?a:2<=e&&e<=4&&0===t?o:0!==t?s:c},function(n){var e=+n;return 0===e?r:1===e?a:2===e?i:3===e?o:6===e?s:c},function(n){var e=Math.floor(Math.abs(+n)),t=+(\"\"+n).replace(/^[^.]*.?|0+$/g,\"\");return 1===+n||0!==t&&(0===e||1===e)?a:c},function(n){var e=Math.floor(Math.abs(+n)),t=(n+\".\").split(\".\")[1].length,r=+(n+\".\").split(\".\")[1];return 0===t&&e%100==1||r%100==1?a:0===t&&e%100==2||r%100==2?i:0===t&&3<=e%100&&e%100<=4||3<=r%100&&r%100<=4?o:c},function(n){var e=Math.floor(Math.abs(+n));return 0===e||1===e?a:c},function(n){var e=Math.floor(Math.abs(+n)),t=(n+\".\").split(\".\")[1].length,r=+(n+\".\").split(\".\")[1];return 0===t&&(1===e||2===e||3===e)||0===t&&e%10!=4&&e%10!=6&&e%10!=9||0!==t&&r%10!=4&&r%10!=6&&r%10!=9?a:c},function(n){var e=+n;return 1===e?a:2===e?i:3<=e&&e<=6?o:7<=e&&e<=10?s:c},function(n){var e=+n;return 1===e||11===e?a:2===e||12===e?i:3<=e&&e<=10||13<=e&&e<=19?o:c},function(n){var e=Math.floor(Math.abs(+n)),t=(n+\".\").split(\".\")[1].length;return 0===t&&e%10==1?a:0===t&&e%10==2?i:0!==t||e%100!=0&&e%100!=20&&e%100!=40&&e%100!=60&&e%100!=80?0!==t?s:c:o},function(n){var e=Math.floor(Math.abs(+n)),t=(n+\".\").split(\".\")[1].length,r=+n;return 1===e&&0===t?a:2===e&&0===t?i:0===t&&(r<0||10<r)&&r%10==0?s:c},function(n){var e=Math.floor(Math.abs(+n)),t=+(\"\"+n).replace(/^[^.]*.?|0+$/g,\"\");return 0===t&&e%10==1&&e%100!=11||0!==t?a:c},function(n){var e=+n;return 1===e?a:2===e?i:c},function(n){var e=+n;return 0===e?r:1===e?a:c},function(n){var e=Math.floor(Math.abs(+n)),t=+n;return 0===t?r:0!==e&&1!==e||0===t?c:a},function(n){var e=+(n+\".\").split(\".\")[1],t=+n;return t%10==1&&(t%100<11||19<t%100)?a:2<=t%10&&t%10<=9&&(t%100<11||19<t%100)?o:0!==e?s:c},function(n){var e=(n+\".\").split(\".\")[1].length,t=+(n+\".\").split(\".\")[1],i=+n;return i%10==0||11<=i%100&&i%100<=19||2===e&&11<=t%100&&t%100<=19?r:i%10==1&&i%100!=11||2===e&&t%10==1&&t%100!=11||2!==e&&t%10==1?a:c},function(n){var e=Math.floor(Math.abs(+n)),t=(n+\".\").split(\".\")[1].length,r=+(n+\".\").split(\".\")[1];return 0===t&&e%10==1&&e%100!=11||r%10==1&&r%100!=11?a:c},function(n){var e=Math.floor(Math.abs(+n)),t=(n+\".\").split(\".\")[1].length,r=+n;return 1===e&&0===t?a:0!==t||0===r||1!==r&&1<=r%100&&r%100<=19?o:c},function(n){var e=+n;return 1===e?a:0===e||2<=e%100&&e%100<=10?o:11<=e%100&&e%100<=19?s:c},function(n){var e=Math.floor(Math.abs(+n)),t=(n+\".\").split(\".\")[1].length;return 1===e&&0===t?a:0===t&&2<=e%10&&e%10<=4&&(e%100<12||14<e%100)?o:0===t&&1!==e&&0<=e%10&&e%10<=1||0===t&&5<=e%10&&e%10<=9||0===t&&12<=e%100&&e%100<=14?s:c},function(n){var e=Math.floor(Math.abs(+n));return 0<=e&&e<=1?a:c},function(n){var e=Math.floor(Math.abs(+n)),t=(n+\".\").split(\".\")[1].length;return 0===t&&e%10==1&&e%100!=11?a:0===t&&2<=e%10&&e%10<=4&&(e%100<12||14<e%100)?o:0===t&&e%10==0||0===t&&5<=e%10&&e%10<=9||0===t&&11<=e%100&&e%100<=14?s:c},function(n){var e=+n;return 0===Math.floor(Math.abs(+n))||1===e?a:2<=e&&e<=10?o:c},function(n){var e=Math.floor(Math.abs(+n)),t=+(n+\".\").split(\".\")[1],r=+n;return 0===r||1===r||0===e&&1===t?a:c},function(n){var e=Math.floor(Math.abs(+n)),t=(n+\".\").split(\".\")[1].length;return 0===t&&e%100==1?a:0===t&&e%100==2?i:0===t&&3<=e%100&&e%100<=4||0!==t?o:c},function(n){var e=+n;return 0<=e&&e<=1||11<=e&&e<=99?a:c},function(n){var e=+n;return 1===e||5===e||7===e||8===e||9===e||10===e?a:2===e||3===e?i:4===e?o:6===e?s:c},function(n){var e=Math.floor(Math.abs(+n));return e%10==1||e%10==2||e%10==5||e%10==7||e%10==8||e%100==20||e%100==50||e%100==70||e%100==80?a:e%10==3||e%10==4||e%1e3==100||e%1e3==200||e%1e3==300||e%1e3==400||e%1e3==500||e%1e3==600||e%1e3==700||e%1e3==800||e%1e3==900?o:0===e||e%10==6||e%100==40||e%100==60||e%100==90?s:c},function(n){var e=+n;return e%10!=2&&e%10!=3||e%100==12||e%100==13?c:o},function(n){var e=+n;return 1===e||3===e?a:2===e?i:4===e?o:c},function(n){var e=+n;return 0===e||7===e||8===e||9===e?r:1===e?a:2===e?i:3===e||4===e?o:5===e||6===e?s:c},function(n){var e=+n;return e%10==1&&e%100!=11?a:e%10==2&&e%100!=12?i:e%10==3&&e%100!=13?o:c},function(n){var e=+n;return 1===e||11===e?a:2===e||12===e?i:3===e||13===e?o:c},function(n){var e=+n;return 1===e?a:2===e||3===e?i:4===e?o:6===e?s:c},function(n){var e=+n;return 1===e||5===e?a:c},function(n){var e=+n;return 11===e||8===e||80===e||800===e?s:c},function(n){var e=Math.floor(Math.abs(+n));return 1===e?a:0===e||2<=e%100&&e%100<=20||e%100==40||e%100==60||e%100==80?s:c},function(n){var e=+n;return e%10==6||e%10==9||e%10==0&&0!==e?s:c},function(n){var e=Math.floor(Math.abs(+n));return e%10==1&&e%100!=11?a:e%10==2&&e%100!=12?i:e%10!=7&&e%10!=8||e%100==17||e%100==18?c:s},function(n){var e=+n;return 1===e?a:2===e||3===e?i:4===e?o:c},function(n){var e=+n;return 1<=e&&e<=4?a:c},function(n){var e=+n;return 1===e||5===e||7<=e&&e<=9?a:2===e||3===e?i:4===e?o:6===e?s:c},function(n){var e=+n;return 1===e?a:e%10==4&&e%100!=14?s:c},function(n){var e=+n;return e%10!=1&&e%10!=2||e%100==11||e%100==12?c:a},function(n){var e=+n;return e%10==6||e%10==9||10===e?o:c},function(n){var e=+n;return e%10==3&&e%100!=13?o:c}];n.exports={af:{cardinal:l[0]},ak:{cardinal:l[1]},am:{cardinal:l[2]},ar:{cardinal:l[3]},ars:{cardinal:l[3]},as:{cardinal:l[2],ordinal:l[34]},asa:{cardinal:l[0]},ast:{cardinal:l[4]},az:{cardinal:l[0],ordinal:l[35]},be:{cardinal:l[5],ordinal:l[36]},bem:{cardinal:l[0]},bez:{cardinal:l[0]},bg:{cardinal:l[0]},bh:{cardinal:l[1]},bn:{cardinal:l[2],ordinal:l[34]},br:{cardinal:l[6]},brx:{cardinal:l[0]},bs:{cardinal:l[7]},ca:{cardinal:l[4],ordinal:l[37]},ce:{cardinal:l[0]},cgg:{cardinal:l[0]},chr:{cardinal:l[0]},ckb:{cardinal:l[0]},cs:{cardinal:l[8]},cy:{cardinal:l[9],ordinal:l[38]},da:{cardinal:l[10]},de:{cardinal:l[4]},dsb:{cardinal:l[11]},dv:{cardinal:l[0]},ee:{cardinal:l[0]},el:{cardinal:l[0]},en:{cardinal:l[4],ordinal:l[39]},eo:{cardinal:l[0]},es:{cardinal:l[0]},et:{cardinal:l[4]},eu:{cardinal:l[0]},fa:{cardinal:l[2]},ff:{cardinal:l[12]},fi:{cardinal:l[4]},fil:{cardinal:l[13],ordinal:l[0]},fo:{cardinal:l[0]},fr:{cardinal:l[12],ordinal:l[0]},fur:{cardinal:l[0]},fy:{cardinal:l[4]},ga:{cardinal:l[14],ordinal:l[0]},gd:{cardinal:l[15],ordinal:l[40]},gl:{cardinal:l[4]},gsw:{cardinal:l[0]},gu:{cardinal:l[2],ordinal:l[41]},guw:{cardinal:l[1]},gv:{cardinal:l[16]},ha:{cardinal:l[0]},haw:{cardinal:l[0]},he:{cardinal:l[17]},hi:{cardinal:l[2],ordinal:l[41]},hr:{cardinal:l[7]},hsb:{cardinal:l[11]},hu:{cardinal:l[0],ordinal:l[42]},hy:{cardinal:l[12],ordinal:l[0]},ia:{cardinal:l[4]},io:{cardinal:l[4]},is:{cardinal:l[18]},it:{cardinal:l[4],ordinal:l[43]},iu:{cardinal:l[19]},iw:{cardinal:l[17]},jgo:{cardinal:l[0]},ji:{cardinal:l[4]},jmc:{cardinal:l[0]},ka:{cardinal:l[0],ordinal:l[44]},kab:{cardinal:l[12]},kaj:{cardinal:l[0]},kcg:{cardinal:l[0]},kk:{cardinal:l[0],ordinal:l[45]},kkj:{cardinal:l[0]},kl:{cardinal:l[0]},kn:{cardinal:l[2]},ks:{cardinal:l[0]},ksb:{cardinal:l[0]},ksh:{cardinal:l[20]},ku:{cardinal:l[0]},kw:{cardinal:l[19]},ky:{cardinal:l[0]},lag:{cardinal:l[21]},lb:{cardinal:l[0]},lg:{cardinal:l[0]},ln:{cardinal:l[1]},lt:{cardinal:l[22]},lv:{cardinal:l[23]},mas:{cardinal:l[0]},mg:{cardinal:l[1]},mgo:{cardinal:l[0]},mk:{cardinal:l[24],ordinal:l[46]},ml:{cardinal:l[0]},mn:{cardinal:l[0]},mo:{cardinal:l[25],ordinal:l[0]},mr:{cardinal:l[2],ordinal:l[47]},mt:{cardinal:l[26]},nah:{cardinal:l[0]},naq:{cardinal:l[19]},nb:{cardinal:l[0]},nd:{cardinal:l[0]},ne:{cardinal:l[0],ordinal:l[48]},nl:{cardinal:l[4]},nn:{cardinal:l[0]},nnh:{cardinal:l[0]},no:{cardinal:l[0]},nr:{cardinal:l[0]},nso:{cardinal:l[1]},ny:{cardinal:l[0]},nyn:{cardinal:l[0]},om:{cardinal:l[0]},or:{cardinal:l[0],ordinal:l[49]},os:{cardinal:l[0]},pa:{cardinal:l[1]},pap:{cardinal:l[0]},pl:{cardinal:l[27]},prg:{cardinal:l[23]},ps:{cardinal:l[0]},pt:{cardinal:l[28]},\"pt-PT\":{cardinal:l[4]},rm:{cardinal:l[0]},ro:{cardinal:l[25],ordinal:l[0]},rof:{cardinal:l[0]},ru:{cardinal:l[29]},rwk:{cardinal:l[0]},saq:{cardinal:l[0]},sc:{cardinal:l[4],ordinal:l[43]},scn:{cardinal:l[4],ordinal:l[43]},sd:{cardinal:l[0]},sdh:{cardinal:l[0]},se:{cardinal:l[19]},seh:{cardinal:l[0]},sh:{cardinal:l[7]},shi:{cardinal:l[30]},si:{cardinal:l[31]},sk:{cardinal:l[8]},sl:{cardinal:l[32]},sma:{cardinal:l[19]},smi:{cardinal:l[19]},smj:{cardinal:l[19]},smn:{cardinal:l[19]},sms:{cardinal:l[19]},sn:{cardinal:l[0]},so:{cardinal:l[0]},sq:{cardinal:l[0],ordinal:l[50]},sr:{cardinal:l[7]},ss:{cardinal:l[0]},ssy:{cardinal:l[0]},st:{cardinal:l[0]},sv:{cardinal:l[4],ordinal:l[51]},sw:{cardinal:l[4]},syr:{cardinal:l[0]},ta:{cardinal:l[0]},te:{cardinal:l[0]},teo:{cardinal:l[0]},ti:{cardinal:l[1]},tig:{cardinal:l[0]},tk:{cardinal:l[0],ordinal:l[52]},tl:{cardinal:l[13],ordinal:l[0]},tn:{cardinal:l[0]},tr:{cardinal:l[0]},ts:{cardinal:l[0]},tzm:{cardinal:l[33]},ug:{cardinal:l[0]},uk:{cardinal:l[29],ordinal:l[53]},ur:{cardinal:l[4]},uz:{cardinal:l[0]},ve:{cardinal:l[0]},vo:{cardinal:l[0]},vun:{cardinal:l[0]},wa:{cardinal:l[1]},wae:{cardinal:l[0]},xh:{cardinal:l[0]},xog:{cardinal:l[0]},yi:{cardinal:l[4]},zu:{cardinal:l[2]},lo:{ordinal:l[0]},ms:{ordinal:l[0]},vi:{ordinal:l[0]}}},function(n,e,t){(function(n){const e=t(9),r=t(13),a=t(15),i=t(0),{isWorker:o}=t(3),s=t(18)(null);n.Scratch=n.Scratch||{},Object.assign(n.Scratch,e,{canFetch:()=>Promise.resolve(!0),fetch:function(n){function e(e,t){return n.apply(this,arguments)}return e.toString=function(){return n.toString()},e}(((n,e)=>fetch(n,e))),canOpenWindow:()=>Promise.resolve(!1),openWindow:()=>Promise.reject(new Error(\"Scratch.openWindow not supported in sandboxed extensions\")),canRedirect:()=>Promise.resolve(!1),redirect:()=>Promise.reject(new Error(\"Scratch.redirect not supported in sandboxed extensions\")),canRecordAudio:()=>Promise.resolve(!1),canRecordVideo:()=>Promise.resolve(!1),canReadClipboard:()=>Promise.resolve(!1),canNotify:()=>Promise.resolve(!1),canGeolocate:()=>Promise.resolve(!1),canEmbed:()=>Promise.resolve(!1),translate:s});const c=new class{constructor(){this.nextExtensionId=0,this.initialRegistrations=[],this.firstRegistrationPromise=new Promise((n=>{this.firstRegistrationCallback=n})),a.waitForConnection.then((()=>{a.call(\"extensions\",\"allocateWorker\").then((async n=>{const[e,t]=n;this.workerId=e;try{await(n=>{if(!o)return new Promise(((e,t)=>{const r=document.createElement(\"script\");r.onload=()=>e(),r.onerror=()=>{t(new Error(\"Error in sandboxed script: \".concat(n,\". Check the console for more information.\")))},r.src=n,document.body.appendChild(r)}));importScripts(n)})(t),await this.firstRegistrationPromise;const n=this.initialRegistrations;this.initialRegistrations=null,Promise.all(n).then((()=>a.call(\"extensions\",\"onWorkerInit\",e)))}catch(n){i.error(n),a.call(\"extensions\",\"onWorkerInit\",e,\"\".concat(n))}}))})),this.extensions=[]}register(n){const e=this.nextExtensionId++;this.extensions.push(n);const t=\"extension.\".concat(this.workerId,\".\").concat(e),r=a.setService(t,n).then((()=>a.call(\"extensions\",\"registerExtensionService\",t)));return this.initialRegistrations&&(this.firstRegistrationCallback(),this.initialRegistrations.push(r)),r}};n.Scratch.extensions={register:c.register.bind(c)},n.ScratchExtensions=r(n.Scratch)}).call(this,t(8))},function(n,e){var t;t=function(){return this}();try{t=t||new Function(\"return this\")()}catch(n){\"object\"==typeof window&&(t=window)}n.exports=t},function(n,e,t){const r={ArgumentType:t(1),BlockType:t(2),TargetType:t(10),Cast:t(11)};n.exports=r},function(n,e){n.exports={SPRITE:\"sprite\",STAGE:\"stage\"}},function(n,e,t){const r=t(12),a=n=>{if(\"string\"!=typeof n)return!1;for(let e=0;e<n.length;e++){const t=n.charCodeAt(e);if(48===t||9===t)return!1}return!0};class i{static toNumber(n){if(\"number\"==typeof n)return Number.isNaN(n)?0:n;const e=Number(n);return Number.isNaN(e)?0:e}static toBoolean(n){return\"boolean\"==typeof n?n:\"string\"==typeof n?\"\"!==n&&\"0\"!==n&&\"false\"!==n.toLowerCase():Boolean(n)}static toString(n){return String(n)}static toRgbColorList(n){const e=i.toRgbColorObject(n);return[e.r,e.g,e.b]}static toRgbColorObject(n){let e;return\"string\"==typeof n&&\"#\"===n.substring(0,1)?(e=r.hexToRgb(n),e||(e={r:0,g:0,b:0,a:255})):e=r.decimalToRgb(i.toNumber(n)),e}static isWhiteSpace(n){return null===n||\"string\"==typeof n&&0===n.trim().length}static compare(n,e){let t=Number(n),r=Number(e);if(0===t&&a(n)?t=NaN:0===r&&a(e)&&(r=NaN),isNaN(t)||isNaN(r)){const t=String(n).toLowerCase(),r=String(e).toLowerCase();return t<r?-1:t>r?1:0}return t===1/0&&r===1/0||t===-1/0&&r===-1/0?0:t-r}static isInt(n){return\"number\"==typeof n?!!isNaN(n)||n===Math.floor(n):\"boolean\"==typeof n||\"string\"==typeof n&&n.indexOf(\".\")<0}static get LIST_INVALID(){return\"INVALID\"}static get LIST_ALL(){return\"ALL\"}static toListIndex(n,e,t){if(\"number\"!=typeof n){if(\"all\"===n)return t?i.LIST_ALL:i.LIST_INVALID;if(\"last\"===n)return e>0?e:i.LIST_INVALID;if(\"random\"===n||\"any\"===n)return e>0?1+Math.floor(Math.random()*e):i.LIST_INVALID}return(n=Math.floor(i.toNumber(n)))<1||n>e?i.LIST_INVALID:n}}n.exports=i},function(n,e){class t{static get RGB_BLACK(){return{r:0,g:0,b:0}}static get RGB_WHITE(){return{r:255,g:255,b:255}}static decimalToHex(n){n<0&&(n+=16777216);let e=Number(n).toString(16);return e=\"#\".concat(\"000000\".substr(0,6-e.length)).concat(e),e}static decimalToRgb(n){const e=n>>24&255;return{r:n>>16&255,g:n>>8&255,b:255&n,a:e>0?e:255}}static hexToRgb(n){n.startsWith(\"#\")&&(n=n.substring(1));const e=parseInt(n,16);if(isNaN(e))return null;if(6===n.length)return{r:e>>16&255,g:e>>8&255,b:255&e};if(3===n.length){const n=e>>8&15,t=e>>4&15,r=15&e;return{r:n<<4|n,g:t<<4|t,b:r<<4|r}}return null}static rgbToHex(n){return t.decimalToHex(t.rgbToDecimal(n))}static rgbToDecimal(n){return(n.r<<16)+(n.g<<8)+n.b}static hexToDecimal(n){return t.rgbToDecimal(t.hexToRgb(n))}static hsvToRgb(n){let e=n.h%360;e<0&&(e+=360);const t=Math.max(0,Math.min(n.s,1)),r=Math.max(0,Math.min(n.v,1)),a=Math.floor(e/60),i=e/60-a,o=r*(1-t),s=r*(1-t*i),c=r*(1-t*(1-i));let l,u,d;switch(a){default:case 0:l=r,u=c,d=o;break;case 1:l=s,u=r,d=o;break;case 2:l=o,u=r,d=c;break;case 3:l=o,u=s,d=r;break;case 4:l=c,u=o,d=r;break;case 5:l=r,u=o,d=s}return{r:Math.floor(255*l),g:Math.floor(255*u),b:Math.floor(255*d)}}static rgbToHsv(n){const e=n.r/255,t=n.g/255,r=n.b/255,a=Math.min(Math.min(e,t),r),i=Math.max(Math.max(e,t),r);let o=0,s=0;if(a!==i){o=60*((e===a?3:t===a?5:1)-(e===a?t-r:t===a?r-e:e-t)/(i-a))%360,s=(i-a)/i}return{h:o,s:s,v:i}}static mixRgb(n,e,t){if(t<=0)return n;if(t>=1)return e;const r=1-t;return{r:r*n.r+t*e.r,g:r*n.g+t*e.g,b:r*n.b+t*e.b}}}n.exports=t},function(n,e,t){const r=t(1),a=t(2),{argumentIndexToId:i,generateExtensionId:o}=t(14),s=n=>{if(\"\"===n||\" \"===n||\"w\"===n)return{type:a.COMMAND,async:\"w\"===n};if(\"r\"===n||\"R\"===n)return{type:a.REPORTER,async:\"R\"===n};if(\"b\"===n)return{type:a.BOOLEAN,async:!1};if(\"h\"===n)return{type:a.HAT,async:!1};throw new Error(\"Unknown ScratchX block type: \".concat(n))},c=(n,e)=>{const t={},a=\"string\"==typeof(i=e)||\"number\"==typeof i||\"boolean\"==typeof i;var i;if(a&&\"b\"!==n&&(t.defaultValue=e),\"s\"===n)t.type=r.STRING,a||(t.defaultValue=\"\");else if(\"n\"===n)t.type=r.NUMBER,a||(t.defaultValue=0);else if(\"m\"===n[0]){t.type=r.STRING;const e=n.split(/\\.|:/)[1];t.menu=e}else{if(\"b\"!==n)throw new Error(\"Unknown ScratchX argument type: \".concat(n));t.type=r.BOOLEAN}return t},l=(n,e,t)=>r=>{const a=[];for(let n=0;n<e;n++)a.push(r[i(n)]);return t?new Promise((e=>{n(...a,e)})):n(...a)},u=new Map;n.exports=n=>({register:(e,t,r)=>{const a=((n,e,t)=>{const r={id:o(n),name:e.displayName||n,blocks:[],color1:\"#4a4a5e\",color2:\"#31323f\",color3:\"#191a21\"},a={getInfo:()=>r,_getStatus:t._getStatus};e.url&&(r.docsURI=e.url);for(const n of e.blocks){if(1===n.length){r.blocks.push(\"---\");continue}const e=n[0],o=n[1],u=n[2],d=n.slice(3);let f=\"\";const h=[],m=o.split(/%([\\w.:]+)/g);for(let n=0;n<m.length;n++){const e=m[n];if(n%2==1){c(e);const t=Math.floor(n/2).toString(),r=d[t],a=i(t);h[a]=c(e,r),f+=\"[\".concat(a,\"]\")}else f+=e}const p=s(e),g={opcode:u,blockType:p.type,text:f,arguments:h};r.blocks.push(g);const b=t[u],v=h.length;a[u]=l(b,v,p.async)}const u=e.menus;if(u){const n={};for(const e of Object.keys(u)||{}){const t={items:u[e]};n[e]=t}r.menus=n}return a})(e,t,r);u.set(e,a),n.extensions.register(a)},getStatus:n=>{const e=u.get(n);return e?e._getStatus():{status:0,msg:\"does not exist\"}}})},function(n,e){n.exports={generateExtensionId:n=>{const e=n.replace(/[^a-z0-9]/gi,\"\").toLowerCase();return\"sbx\".concat(e)},argumentIndexToId:n=>n.toString()}},function(n,e,t){const r=t(16),a=t(0),{centralDispatchService:i}=t(3);n.exports=new class extends r{constructor(){super(),this._connectionPromise=new Promise((n=>{this._onConnect=n})),this.services={},this._onMessage=this._onMessage.bind(this,i),\"undefined\"!=typeof self&&(self.onmessage=this._onMessage)}get waitForConnection(){return this._connectionPromise}setService(n,e){return Object.prototype.hasOwnProperty.call(this.services,n)&&a.warn(\"Worker dispatch replacing existing service provider for \".concat(n)),this.services[n]=e,this.waitForConnection.then((()=>this._remoteCall(i,\"dispatch\",\"setService\",n)))}_getServiceProvider(n){const e=this.services[n];return{provider:e||i,isRemote:!e}}_onDispatchMessage(n,e){let t;switch(e.method){case\"handshake\":t=this._onConnect();break;case\"terminate\":setTimeout((()=>self.close()),0),t=Promise.resolve();break;default:a.error(\"Worker dispatch received message for unknown method: \".concat(e.method))}return t}}},function(n,e,t){const r=t(0);n.exports=class{constructor(){this.callbacks=[],this.nextResponseId=0}call(n,e){for(var t=arguments.length,r=new Array(t>2?t-2:0),a=2;a<t;a++)r[a-2]=arguments[a];return this.transferCall(n,e,null,...r)}transferCall(n,e,t){try{const{provider:o,isRemote:s}=this._getServiceProvider(n);if(o){for(var r=arguments.length,a=new Array(r>3?r-3:0),i=3;i<r;i++)a[i-3]=arguments[i];if(s)return this._remoteTransferCall(o,n,e,t,...a);const c=o[e].apply(o,a);return Promise.resolve(c)}return Promise.reject(new Error(\"Service not found: \".concat(n)))}catch(n){return Promise.reject(n)}}_isRemoteService(n){return this._getServiceProvider(n).isRemote}_remoteCall(n,e,t){for(var r=arguments.length,a=new Array(r>3?r-3:0),i=3;i<r;i++)a[i-3]=arguments[i];return this._remoteTransferCall(n,e,t,null,...a)}_remoteTransferCall(n,e,t,r){for(var a=arguments.length,i=new Array(a>4?a-4:0),o=4;o<a;o++)i[o-4]=arguments[o];return new Promise(((a,o)=>{const s=this._storeCallbacks(a,o);i.length>0&&\"function\"==typeof i[i.length-1].func&&(i.pop(),i.pop()),r?n.postMessage({service:e,method:t,responseId:s,args:i},r):n.postMessage({service:e,method:t,responseId:s,args:i})}))}_storeCallbacks(n,e){const t=this.nextResponseId++;return this.callbacks[t]=[n,e],t}_deliverResponse(n,e){try{const[t,r]=this.callbacks[n];delete this.callbacks[n],e.error?r(e.error):t(e.result)}catch(n){r.error(\"Dispatch callback failed: \".concat(n))}}_onMessage(n,e){const t=e.data;let a;t.args=t.args||[],t.service?a=\"dispatch\"===t.service?this._onDispatchMessage(n,t):this.call(t.service,t.method,...t.args):void 0===t.responseId?r.error(\"Dispatch caught malformed message from a worker: \".concat(JSON.stringify(e))):this._deliverResponse(t.responseId,t),a&&(void 0===t.responseId?r.error(\"Dispatch message missing required response ID: \".concat(JSON.stringify(e))):a.then((e=>n.postMessage({responseId:t.responseId,result:e})),(e=>n.postMessage({responseId:t.responseId,error:\"\".concat(e)}))))}_getServiceProvider(n){throw new Error(\"Could not get provider for \".concat(n,\": _getServiceProvider not implemented\"))}_onDispatchMessage(n,e){throw new Error(\"Unimplemented dispatch message handler cannot handle \".concat(e.method,\" method\"))}}},function(n,e){const t=\"undefined\"==typeof document,r=t?\"\u001b[0m\":\"\",a=t?\"\u001b[90m\":\"\",i=t?\"\u001b[36m\":\"\",o=t?\"\u001b[33m\":\"\",s=t?\"\u001b[31m\":\"\",c=\"\".concat(t?\"\u001b[34m\":\"\",\"debug\").concat(r),l=\"\".concat(i,\"info\").concat(r),u=\"\".concat(o,\"warn\").concat(r),d=\"\".concat(s,\"error\").concat(r),f=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"\";const e=e=>f(n?\"\".concat(n,\" \").concat(e):e),t=n?[\"\".concat(a).concat(n).concat(r)]:[];return e.debug=e.log=console.debug.bind(console,...t,c),e.info=console.log.bind(console,...t,l),e.warn=e.warning=console.warn.bind(console,...t,u),e.error=console.error.bind(console,...t,d),e};f.enable=f.disable=()=>{},n.exports=f},function(n,e,t){const r=t(19);n.exports=n=>{const e=r.namespace(),t=(n,t)=>{if(n&&\"object\"==typeof n);else{if(\"string\"!=typeof n)throw new Error(\"unsupported data type in translate()\");n={default:n}}return e(n,t)},a=n=>\"_\".concat(n),i=()=>n?n.getLocale():\"undefined\"!=typeof navigator?navigator.language:\"en\";let o={};return t.setup=n=>{n&&(o=n),e.setup({locale:i(),missingTranslation:\"ignore\",generateId:a,translations:o})},Object.defineProperty(t,\"language\",{configurable:!0,enumerable:!0,get:()=>i()}),t.setup({}),n&&n.on(\"LOCALE_CHANGED\",(()=>{t.setup(null)})),t}},function(n,e,t){\"use strict\";var r=t(20),a=t(21),i=t(6),o=t(5),s=t(4);function c(n,e){return Object.keys(e).forEach((function(t){n[t]=e[t]})),n}n.exports=function n(){var e=c({},s),t=\"en\",l={},u=function(n){return n},d=null,f=\"warning\",h={};function m(n,e,i){var o=\"string\"==typeof n?n:n.default,s=b(o,\"object\"==typeof n&&n.id||u(o),i||t);return(s.format||(s.format=a(r(s.message),i||t,h)))(e)}m.rich=function(n,e,i){var o=\"string\"==typeof n?n:n.default,s=b(o,\"object\"==typeof n&&n.id||u(o),i||t);return(s.toParts||(s.toParts=a.toParts(r(s.message,{tagsType:p}),i||t,h)))(e)};var p=\"<>\";function g(n,e){var t=n[2];return function(n,e){var r=\"object\"==typeof t?function(n,e){return Object.keys(n).reduce((function(t,r){return t[r]=n[r](e),t}),{})}(t,e):t;return\"function\"==typeof n?n(r):n}}function b(n,e,t){var r=o(t,l)||\"en\",a=l[r]||(l[r]={}),i=a[e];if(\"string\"==typeof i&&(i=a[e]={message:i}),!i){var s='Translation for \"'+e+'\" in \"'+r+'\" is missing';if(\"warning\"===f)\"undefined\"!=typeof console&&console.warn(s);else if(\"ignore\"!==f)throw new Error(s);var c=\"function\"==typeof d?d(n,e,r)||n:d||n;i=a[e]={message:c}}return i}function v(n,e,r,a,s){\"object\"==typeof r&&\"object\"!=typeof a&&(s=a,a=r,r=0);var c=o(s||t,i),l=c&&i[c][n]||x;return a[\"=\"+ +e]||a[l(e-r)]||a.other}function x(){return\"other\"}return h[p]=g,m.setup=function(n){return(n=n||{}).locale&&(t=n.locale),\"translations\"in n&&(l=n.translations||{}),n.generateId&&(u=n.generateId),\"missingReplacement\"in n&&(d=n.missingReplacement),n.missingTranslation&&(f=n.missingTranslation),n.formats&&(n.formats.number&&c(e.number,n.formats.number),n.formats.date&&c(e.date,n.formats.date),n.formats.time&&c(e.time,n.formats.time)),n.types&&((h=n.types)[p]=g),{locale:t,translations:l,generateId:u,missingReplacement:d,missingTranslation:f,formats:e,types:h}},m.number=function(n,r,a){var i=r&&e.number[r]||e.parseNumberPattern(r)||e.number.default;return new Intl.NumberFormat(a||t,i).format(n)},m.date=function(n,r,a){var i=r&&e.date[r]||e.parseDatePattern(r)||e.date.default;return new Intl.DateTimeFormat(a||t,i).format(n)},m.time=function(n,r,a){var i=r&&e.time[r]||e.parseDatePattern(r)||e.time.default;return new Intl.DateTimeFormat(a||t,i).format(n)},m.select=function(n,e){return e[n]||e.other},m.custom=function(n,e,t,r){return n[1]in h?h[n[1]](n,e)(t,r):t},m.plural=v.bind(null,\"cardinal\"),m.selectordinal=v.bind(null,\"ordinal\"),m.namespace=n,m}()},function(n,e,t){\"use strict\";var r=\"{\",a=\"}\",i=\",\",o=\"#\",s=\"<\",c=\">\",l=\"</\",u=\"/>\",d=\"'\",f=\"offset:\",h=[\"number\",\"date\",\"time\",\"ordinal\",\"duration\",\"spellout\"],m=[\"plural\",\"select\",\"selectordinal\"];function p(n,e){var t=n.pattern,r=t.length,i=[],o=n.index,s=g(n,e);for(s&&i.push(s),s&&n.tokens&&n.tokens.push([\"text\",t.slice(o,n.index)]);n.index<r;){if(t[n.index]===a){if(!e)throw S(n);break}if(e&&n.tagsType&&t.slice(n.index,n.index+l.length)===l)break;i.push(x(n)),o=n.index,(s=g(n,e))&&i.push(s),s&&n.tokens&&n.tokens.push([\"text\",t.slice(o,n.index)])}return i}function g(n,e){for(var t=n.pattern,i=t.length,c=\"plural\"===e||\"selectordinal\"===e,l=!!n.tagsType,u=\"{style}\"===e,f=\"\";n.index<i;){var h=t[n.index];if(h===r||h===a||c&&h===o||l&&h===s||u&&b(h.charCodeAt(0)))break;if(h===d)if((h=t[++n.index])===d)f+=h,++n.index;else if(h===r||h===a||c&&h===o||l&&h===s||u)for(f+=h;++n.index<i;)if((h=t[n.index])===d&&t[n.index+1]===d)f+=d,++n.index;else{if(h===d){++n.index;break}f+=h}else f+=d;else f+=h,++n.index}return f}function b(n){return n>=9&&n<=13||32===n||133===n||160===n||6158===n||n>=8192&&n<=8205||8232===n||8233===n||8239===n||8287===n||8288===n||12288===n||65279===n}function v(n){for(var e=n.pattern,t=e.length,r=n.index;n.index<t&&b(e.charCodeAt(n.index));)++n.index;r<n.index&&n.tokens&&n.tokens.push([\"space\",n.pattern.slice(r,n.index)])}function x(n){var e=n.pattern;if(e[n.index]===o)return n.tokens&&n.tokens.push([\"syntax\",o]),++n.index,[o];var t=function(n){var e=n.tagsType;if(!e||n.pattern[n.index]!==s)return;if(n.pattern.slice(n.index,n.index+l.length)===l)throw S(n,null,\"closing tag without matching opening tag\");n.tokens&&n.tokens.push([\"syntax\",s]);++n.index;var t=y(n,!0);if(!t)throw S(n,\"placeholder id\");n.tokens&&n.tokens.push([\"id\",t]);if(v(n),n.pattern.slice(n.index,n.index+u.length)===u)return n.tokens&&n.tokens.push([\"syntax\",u]),n.index+=u.length,[t,e];if(n.pattern[n.index]!==c)throw S(n,c);n.tokens&&n.tokens.push([\"syntax\",c]);++n.index;var r=p(n,e),a=n.index;if(n.pattern.slice(n.index,n.index+l.length)!==l)throw S(n,l+t+c);n.tokens&&n.tokens.push([\"syntax\",l]);n.index+=l.length;var i=y(n,!0);i&&n.tokens&&n.tokens.push([\"id\",i]);if(t!==i)throw n.index=a,S(n,l+t+c,l+i+c);if(v(n),n.pattern[n.index]!==c)throw S(n,c);n.tokens&&n.tokens.push([\"syntax\",c]);return++n.index,[t,e,{children:r}]}(n);if(t)return t;if(e[n.index]!==r)throw S(n,r);n.tokens&&n.tokens.push([\"syntax\",r]),++n.index,v(n);var d=y(n);if(!d)throw S(n,\"placeholder id\");n.tokens&&n.tokens.push([\"id\",d]),v(n);var m=e[n.index];if(m===a)return n.tokens&&n.tokens.push([\"syntax\",a]),++n.index,[d];if(m!==i)throw S(n,i+\" or \"+a);n.tokens&&n.tokens.push([\"syntax\",i]),++n.index,v(n);var g,b=y(n);if(!b)throw S(n,\"placeholder type\");if(n.tokens&&n.tokens.push([\"type\",b]),v(n),(m=e[n.index])===a){if(n.tokens&&n.tokens.push([\"syntax\",a]),\"plural\"===b||\"selectordinal\"===b||\"select\"===b)throw S(n,b+\" sub-messages\");return++n.index,[d,b]}if(m!==i)throw S(n,i+\" or \"+a);if(n.tokens&&n.tokens.push([\"syntax\",i]),++n.index,v(n),\"plural\"===b||\"selectordinal\"===b){var x=function(n){var e=n.pattern,t=e.length,r=0;if(e.slice(n.index,n.index+f.length)===f){n.tokens&&n.tokens.push([\"offset\",\"offset\"],[\"syntax\",\":\"]),n.index+=f.length,v(n);for(var a=n.index;n.index<t&&w(e.charCodeAt(n.index));)++n.index;if(a===n.index)throw S(n,\"offset number\");n.tokens&&n.tokens.push([\"number\",e.slice(a,n.index)]),r=+e.slice(a,n.index)}return r}(n);v(n),g=[d,b,x,M(n,b)]}else if(\"select\"===b)g=[d,b,M(n,b)];else if(h.indexOf(b)>=0)g=[d,b,k(n)];else{var I=n.index,T=k(n);v(n),e[n.index]===r&&(n.index=I,T=M(n,b)),g=[d,b,T]}if(v(n),e[n.index]!==a)throw S(n,a);return n.tokens&&n.tokens.push([\"syntax\",a]),++n.index,g}function y(n,e){for(var t=n.pattern,l=t.length,u=\"\";n.index<l;){var f=t[n.index];if(f===r||f===a||f===i||f===o||f===d||b(f.charCodeAt(0))||e&&(f===s||f===c||\"/\"===f))break;u+=f,++n.index}return u}function k(n){var e=n.index,t=g(n,\"{style}\");if(!t)throw S(n,\"placeholder style name\");return n.tokens&&n.tokens.push([\"style\",n.pattern.slice(e,n.index)]),t}function w(n){return n>=48&&n<=57}function M(n,e){for(var t=n.pattern,r=t.length,i={};n.index<r&&t[n.index]!==a;){var o=y(n);if(!o)throw S(n,\"sub-message selector\");n.tokens&&n.tokens.push([\"selector\",o]),v(n),i[o]=I(n,e),v(n)}if(!i.other&&m.indexOf(e)>=0)throw S(n,null,null,'\"other\" sub-message must be specified in '+e);return i}function I(n,e){if(n.pattern[n.index]!==r)throw S(n,r+\" to start sub-message\");n.tokens&&n.tokens.push([\"syntax\",r]),++n.index;var t=p(n,e);if(n.pattern[n.index]!==a)throw S(n,a+\" to end sub-message\");return n.tokens&&n.tokens.push([\"syntax\",a]),++n.index,t}function S(n,e,t,r){var a=n.pattern,i=a.slice(0,n.index).split(/\\r?\\n/),o=n.index,s=i.length,c=i.slice(-1)[0].length;return t=t||(n.index>=a.length?\"end of message pattern\":y(n)||a[n.index]),r||(r=function(n,e){return n?\"Expected \"+n+\" but found \"+e:\"Unexpected \"+e+\" found\"}(e,t)),new T(r+=\" in \"+a.replace(/\\r?\\n/g,\"\\n\"),e,t,o,s,c)}function T(n,e,t,r,a,i){Error.call(this,n),this.name=\"SyntaxError\",this.message=n,this.expected=e,this.found=t,this.offset=r,this.line=a,this.column=i}e=n.exports=function(n,e){return p({pattern:String(n),index:0,tagsType:e&&e.tagsType||null,tokens:e&&e.tokens||null},\"\")},T.prototype=Object.create(Error.prototype),e.SyntaxError=T},function(n,e,t){\"use strict\";var r=t(4),a=t(5),i=t(6);function o(n,e,t,r,a){var i=n.map((function(n){return function(n,e,t,r,a){if(\"string\"==typeof n){var i=n;return function(){return i}}var c,l=n[0],u=n[1];if(e&&\"#\"===n[0]){l=e[0];var d=e[2],h=(r.number||f.number)([l,\"number\"],t);return function(n){return h(s(l,n)-d,n)}}\"plural\"===u||\"selectordinal\"===u?(c={},Object.keys(n[3]).forEach((function(e){c[e]=o(n[3][e],n,t,r,a)})),n=[n[0],n[1],n[2],c]):n[2]&&\"object\"==typeof n[2]&&(c={},Object.keys(n[2]).forEach((function(e){c[e]=o(n[2][e],n,t,r,a)})),n=[n[0],n[1],c]);var m=u&&(r[u]||f[u]);if(m){var p=m(n,t);return function(n){return p(s(l,n),n)}}return a?function(n){return String(s(l,n))}:function(n){return s(l,n)}}(n,e,t,r,a)}));return a?1===i.length?i[0]:function(n){for(var e=\"\",t=0;t<i.length;++t)e+=i[t](n);return e}:function(n){return i.reduce((function(e,t){return e.concat(t(n))}),[])}}function s(n,e){if(e&&n in e)return e[n];for(var t=n.split(\".\"),r=e,a=0,i=t.length;r&&a<i;++a)r=r[t[a]];return r}function c(n,e){var t=n[2],a=r.number[t]||r.parseNumberPattern(t)||r.number.default;return new Intl.NumberFormat(e,a).format}function l(n,e){var t=n[1],a=n[2],i=r[t][a]||r.parseDatePattern(a)||r[t].default;return new Intl.DateTimeFormat(e,i).format}function u(n,e){var t,r=\"selectordinal\"===n[1]?\"ordinal\":\"cardinal\",o=n[2],s=n[3];if(Intl.PluralRules&&Intl.PluralRules.supportedLocalesOf(e).length>0)t=new Intl.PluralRules(e,{type:r});else{var c=a(e,i),l=c&&i[c][r]||d;t={select:l}}return function(n,e){return(s[\"=\"+ +n]||s[t.select(n-o)]||s.other)(e)}}function d(){return\"other\"}(e=n.exports=function(n,e,t){return o(n,null,e||\"en\",t||{},!0)}).toParts=function(n,e,t){return o(n,null,e||\"en\",t||{},!1)};var f={number:c,ordinal:c,spellout:c,duration:function(n,e){var t=n[2],a=r.duration[t]||r.duration.default,i=new Intl.NumberFormat(e,a.seconds).format,o=new Intl.NumberFormat(e,a.minutes).format,s=new Intl.NumberFormat(e,a.hours).format,c=/^fi$|^fi-|^da/.test(String(e))?\".\":\":\";return function(n,e){if(n=+n,!isFinite(n))return i(n);var t=~~(n/60/60),r=~~(n/60%60),a=(t?s(Math.abs(t))+c:\"\")+o(Math.abs(r))+c+i(Math.abs(n%60));return n<0?s(-1).replace(s(1),a):a}},date:l,time:l,plural:u,selectordinal:u,select:function(n,e){var t=n[2];return function(n,e){return(t[n]||t.other)(e)}}};e.types=f}]);","name":"js/extension-worker/extension-worker.3b92c2a8b4f791184bee.js","input":"/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nconst nanolog = __webpack_require__(17);\nnanolog.enable();\nmodule.exports = nanolog('vm');\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n/**\n * Block argument types\n * @enum {string}\n */\nconst ArgumentType = {\n  /**\n   * Numeric value with angle picker\n   */\n  ANGLE: 'angle',\n  /**\n   * Boolean value with hexagonal placeholder\n   */\n  BOOLEAN: 'Boolean',\n  /**\n   * Numeric value with color picker\n   */\n  COLOR: 'color',\n  /**\n   * Numeric value with text field\n   */\n  NUMBER: 'number',\n  /**\n   * String value with text field\n   */\n  STRING: 'string',\n  /**\n   * String value with matrix field\n   */\n  MATRIX: 'matrix',\n  /**\n   * MIDI note number with note picker (piano) field\n   */\n  NOTE: 'note',\n  /**\n   * Inline image on block (as part of the label)\n   */\n  IMAGE: 'image',\n  /**\n   * Name of costume in the current target\n   */\n  COSTUME: 'costume',\n  /**\n   * Name of sound in the current target\n   */\n  SOUND: 'sound'\n};\nmodule.exports = ArgumentType;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n/**\n * Types of block\n * @enum {string}\n */\nconst BlockType = {\n  /**\n   * Boolean reporter with hexagonal shape\n   */\n  BOOLEAN: 'Boolean',\n  /**\n   * A button (not an actual block) for some special action, like making a variable\n   */\n  BUTTON: 'button',\n  /**\n   * A text label (not an actual block) for adding comments or labling blocks\n   */\n  LABEL: 'label',\n  /**\n   * Command block\n   */\n  COMMAND: 'command',\n  /**\n   * Specialized command block which may or may not run a child branch\n   * The thread continues with the next block whether or not a child branch ran.\n   */\n  CONDITIONAL: 'conditional',\n  /**\n   * Specialized hat block with no implementation function\n   * This stack only runs if the corresponding event is emitted by other code.\n   */\n  EVENT: 'event',\n  /**\n   * Hat block which conditionally starts a block stack\n   */\n  HAT: 'hat',\n  /**\n   * Specialized command block which may or may not run a child branch\n   * If a child branch runs, the thread evaluates the loop block again.\n   */\n  LOOP: 'loop',\n  /**\n   * General reporter with numeric or string value\n   */\n  REPORTER: 'reporter',\n  /**\n   * Arbitrary scratch-blocks XML.\n   */\n  XML: 'xml'\n};\nmodule.exports = BlockType;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n  isWorker: true,\n  // centralDispatchService is the object to call postMessage() on to send a message to parent.\n  centralDispatchService: self\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n// @flow\nvar LONG = 'long';\nvar SHORT = 'short';\nvar NARROW = 'narrow';\nvar NUMERIC = 'numeric';\nvar TWODIGIT = '2-digit';\n\n/**\n * formatting information\n **/\nmodule.exports = {\n  number: {\n    decimal: {\n      style: 'decimal'\n    },\n    integer: {\n      style: 'decimal',\n      maximumFractionDigits: 0\n    },\n    currency: {\n      style: 'currency',\n      currency: 'USD'\n    },\n    percent: {\n      style: 'percent'\n    },\n    default: {\n      style: 'decimal'\n    }\n  },\n  date: {\n    short: {\n      month: NUMERIC,\n      day: NUMERIC,\n      year: TWODIGIT\n    },\n    medium: {\n      month: SHORT,\n      day: NUMERIC,\n      year: NUMERIC\n    },\n    long: {\n      month: LONG,\n      day: NUMERIC,\n      year: NUMERIC\n    },\n    full: {\n      month: LONG,\n      day: NUMERIC,\n      year: NUMERIC,\n      weekday: LONG\n    },\n    default: {\n      month: SHORT,\n      day: NUMERIC,\n      year: NUMERIC\n    }\n  },\n  time: {\n    short: {\n      hour: NUMERIC,\n      minute: NUMERIC\n    },\n    medium: {\n      hour: NUMERIC,\n      minute: NUMERIC,\n      second: NUMERIC\n    },\n    long: {\n      hour: NUMERIC,\n      minute: NUMERIC,\n      second: NUMERIC,\n      timeZoneName: SHORT\n    },\n    full: {\n      hour: NUMERIC,\n      minute: NUMERIC,\n      second: NUMERIC,\n      timeZoneName: SHORT\n    },\n    default: {\n      hour: NUMERIC,\n      minute: NUMERIC,\n      second: NUMERIC\n    }\n  },\n  duration: {\n    default: {\n      hours: {\n        minimumIntegerDigits: 1,\n        maximumFractionDigits: 0\n      },\n      minutes: {\n        minimumIntegerDigits: 2,\n        maximumFractionDigits: 0\n      },\n      seconds: {\n        minimumIntegerDigits: 2,\n        maximumFractionDigits: 3\n      }\n    }\n  },\n  parseNumberPattern: function parseNumberPattern(pattern /*: ?string */) {\n    if (!pattern) return;\n    var options = {};\n    var currency = pattern.match(/\\b[A-Z]{3}\\b/i);\n    var syms = pattern.replace(/[^¤]/g, '').length;\n    if (!syms && currency) syms = 1;\n    if (syms) {\n      options.style = 'currency';\n      options.currencyDisplay = syms === 1 ? 'symbol' : syms === 2 ? 'code' : 'name';\n      options.currency = currency ? currency[0].toUpperCase() : 'USD';\n    } else if (pattern.indexOf('%') >= 0) {\n      options.style = 'percent';\n    }\n    if (!/[@#0]/.test(pattern)) return options.style ? options : undefined;\n    options.useGrouping = pattern.indexOf(',') >= 0;\n    if (/E\\+?[@#0]+/i.test(pattern) || pattern.indexOf('@') >= 0) {\n      var size = pattern.replace(/E\\+?[@#0]+|[^@#0]/gi, '');\n      options.minimumSignificantDigits = Math.min(Math.max(size.replace(/[^@0]/g, '').length, 1), 21);\n      options.maximumSignificantDigits = Math.min(Math.max(size.length, 1), 21);\n    } else {\n      var parts = pattern.replace(/[^#0.]/g, '').split('.');\n      var integer = parts[0];\n      var n = integer.length - 1;\n      while (integer[n] === '0') --n;\n      options.minimumIntegerDigits = Math.min(Math.max(integer.length - 1 - n, 1), 21);\n      var fraction = parts[1] || '';\n      n = 0;\n      while (fraction[n] === '0') ++n;\n      options.minimumFractionDigits = Math.min(Math.max(n, 0), 20);\n      while (fraction[n] === '#') ++n;\n      options.maximumFractionDigits = Math.min(Math.max(n, 0), 20);\n    }\n    return options;\n  },\n  parseDatePattern: function parseDatePattern(pattern /*: ?string */) {\n    if (!pattern) return;\n    var options = {};\n    for (var i = 0; i < pattern.length;) {\n      var current = pattern[i];\n      var n = 1;\n      while (pattern[++i] === current) ++n;\n      switch (current) {\n        case 'G':\n          options.era = n === 5 ? NARROW : n === 4 ? LONG : SHORT;\n          break;\n        case 'y':\n        case 'Y':\n          options.year = n === 2 ? TWODIGIT : NUMERIC;\n          break;\n        case 'M':\n        case 'L':\n          n = Math.min(Math.max(n - 1, 0), 4);\n          options.month = [NUMERIC, TWODIGIT, SHORT, LONG, NARROW][n];\n          break;\n        case 'E':\n        case 'e':\n        case 'c':\n          options.weekday = n === 5 ? NARROW : n === 4 ? LONG : SHORT;\n          break;\n        case 'd':\n        case 'D':\n          options.day = n === 2 ? TWODIGIT : NUMERIC;\n          break;\n        case 'h':\n        case 'K':\n          options.hour12 = true;\n          options.hour = n === 2 ? TWODIGIT : NUMERIC;\n          break;\n        case 'H':\n        case 'k':\n          options.hour12 = false;\n          options.hour = n === 2 ? TWODIGIT : NUMERIC;\n          break;\n        case 'm':\n          options.minute = n === 2 ? TWODIGIT : NUMERIC;\n          break;\n        case 's':\n        case 'S':\n          options.second = n === 2 ? TWODIGIT : NUMERIC;\n          break;\n        case 'z':\n        case 'Z':\n        case 'v':\n        case 'V':\n          options.timeZoneName = n === 1 ? SHORT : LONG;\n          break;\n      }\n    }\n    return Object.keys(options).length ? options : undefined;\n  }\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n// @flow\n// \"lookup\" algorithm http://tools.ietf.org/html/rfc4647#section-3.4\n// assumes normalized language tags, and matches in a case sensitive manner\nmodule.exports = function lookupClosestLocale(locale /*: string | string[] | void */, available /*: { [string]: any } */) /*: ?string */{\n  if (typeof locale === 'string' && available[locale]) return locale;\n  var locales = [].concat(locale || []);\n  for (var l = 0, ll = locales.length; l < ll; ++l) {\n    var current = locales[l].split('-');\n    while (current.length) {\n      var candidate = current.join('-');\n      if (available[candidate]) return candidate;\n      current.pop();\n    }\n  }\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// @flow\n\n\n/*:: export type Rule = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other' */\nvar zero = 'zero',\n  one = 'one',\n  two = 'two',\n  few = 'few',\n  many = 'many',\n  other = 'other';\nvar f = [function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 1 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return 0 <= n && n <= 1 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var n = +s;\n  return i === 0 || n === 1 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 0 ? zero : n === 1 ? one : n === 2 ? two : 3 <= n % 100 && n % 100 <= 10 ? few : 11 <= n % 100 && n % 100 <= 99 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var v = (s + '.').split('.')[1].length;\n  return i === 1 && v === 0 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n % 10 === 1 && n % 100 !== 11 ? one : 2 <= n % 10 && n % 10 <= 4 && (n % 100 < 12 || 14 < n % 100) ? few : n % 10 === 0 || 5 <= n % 10 && n % 10 <= 9 || 11 <= n % 100 && n % 100 <= 14 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n % 10 === 1 && n % 100 !== 11 && n % 100 !== 71 && n % 100 !== 91 ? one : n % 10 === 2 && n % 100 !== 12 && n % 100 !== 72 && n % 100 !== 92 ? two : (3 <= n % 10 && n % 10 <= 4 || n % 10 === 9) && (n % 100 < 10 || 19 < n % 100) && (n % 100 < 70 || 79 < n % 100) && (n % 100 < 90 || 99 < n % 100) ? few : n !== 0 && n % 1000000 === 0 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var v = (s + '.').split('.')[1].length;\n  var f = +(s + '.').split('.')[1];\n  return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one : v === 0 && 2 <= i % 10 && i % 10 <= 4 && (i % 100 < 12 || 14 < i % 100) || 2 <= f % 10 && f % 10 <= 4 && (f % 100 < 12 || 14 < f % 100) ? few : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var v = (s + '.').split('.')[1].length;\n  return i === 1 && v === 0 ? one : 2 <= i && i <= 4 && v === 0 ? few : v !== 0 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 0 ? zero : n === 1 ? one : n === 2 ? two : n === 3 ? few : n === 6 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var t = +('' + s).replace(/^[^.]*.?|0+$/g, '');\n  var n = +s;\n  return n === 1 || t !== 0 && (i === 0 || i === 1) ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var v = (s + '.').split('.')[1].length;\n  var f = +(s + '.').split('.')[1];\n  return v === 0 && i % 100 === 1 || f % 100 === 1 ? one : v === 0 && i % 100 === 2 || f % 100 === 2 ? two : v === 0 && 3 <= i % 100 && i % 100 <= 4 || 3 <= f % 100 && f % 100 <= 4 ? few : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  return i === 0 || i === 1 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var v = (s + '.').split('.')[1].length;\n  var f = +(s + '.').split('.')[1];\n  return v === 0 && (i === 1 || i === 2 || i === 3) || v === 0 && i % 10 !== 4 && i % 10 !== 6 && i % 10 !== 9 || v !== 0 && f % 10 !== 4 && f % 10 !== 6 && f % 10 !== 9 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 1 ? one : n === 2 ? two : 3 <= n && n <= 6 ? few : 7 <= n && n <= 10 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 1 || n === 11 ? one : n === 2 || n === 12 ? two : 3 <= n && n <= 10 || 13 <= n && n <= 19 ? few : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var v = (s + '.').split('.')[1].length;\n  return v === 0 && i % 10 === 1 ? one : v === 0 && i % 10 === 2 ? two : v === 0 && (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80) ? few : v !== 0 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var v = (s + '.').split('.')[1].length;\n  var n = +s;\n  return i === 1 && v === 0 ? one : i === 2 && v === 0 ? two : v === 0 && (n < 0 || 10 < n) && n % 10 === 0 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var t = +('' + s).replace(/^[^.]*.?|0+$/g, '');\n  return t === 0 && i % 10 === 1 && i % 100 !== 11 || t !== 0 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 1 ? one : n === 2 ? two : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 0 ? zero : n === 1 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var n = +s;\n  return n === 0 ? zero : (i === 0 || i === 1) && n !== 0 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var f = +(s + '.').split('.')[1];\n  var n = +s;\n  return n % 10 === 1 && (n % 100 < 11 || 19 < n % 100) ? one : 2 <= n % 10 && n % 10 <= 9 && (n % 100 < 11 || 19 < n % 100) ? few : f !== 0 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var v = (s + '.').split('.')[1].length;\n  var f = +(s + '.').split('.')[1];\n  var n = +s;\n  return n % 10 === 0 || 11 <= n % 100 && n % 100 <= 19 || v === 2 && 11 <= f % 100 && f % 100 <= 19 ? zero : n % 10 === 1 && n % 100 !== 11 || v === 2 && f % 10 === 1 && f % 100 !== 11 || v !== 2 && f % 10 === 1 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var v = (s + '.').split('.')[1].length;\n  var f = +(s + '.').split('.')[1];\n  return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var v = (s + '.').split('.')[1].length;\n  var n = +s;\n  return i === 1 && v === 0 ? one : v !== 0 || n === 0 || n !== 1 && 1 <= n % 100 && n % 100 <= 19 ? few : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 1 ? one : n === 0 || 2 <= n % 100 && n % 100 <= 10 ? few : 11 <= n % 100 && n % 100 <= 19 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var v = (s + '.').split('.')[1].length;\n  return i === 1 && v === 0 ? one : v === 0 && 2 <= i % 10 && i % 10 <= 4 && (i % 100 < 12 || 14 < i % 100) ? few : v === 0 && i !== 1 && 0 <= i % 10 && i % 10 <= 1 || v === 0 && 5 <= i % 10 && i % 10 <= 9 || v === 0 && 12 <= i % 100 && i % 100 <= 14 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  return 0 <= i && i <= 1 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var v = (s + '.').split('.')[1].length;\n  return v === 0 && i % 10 === 1 && i % 100 !== 11 ? one : v === 0 && 2 <= i % 10 && i % 10 <= 4 && (i % 100 < 12 || 14 < i % 100) ? few : v === 0 && i % 10 === 0 || v === 0 && 5 <= i % 10 && i % 10 <= 9 || v === 0 && 11 <= i % 100 && i % 100 <= 14 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var n = +s;\n  return i === 0 || n === 1 ? one : 2 <= n && n <= 10 ? few : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var f = +(s + '.').split('.')[1];\n  var n = +s;\n  return n === 0 || n === 1 || i === 0 && f === 1 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  var v = (s + '.').split('.')[1].length;\n  return v === 0 && i % 100 === 1 ? one : v === 0 && i % 100 === 2 ? two : v === 0 && 3 <= i % 100 && i % 100 <= 4 || v !== 0 ? few : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return 0 <= n && n <= 1 || 11 <= n && n <= 99 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 1 || n === 5 || n === 7 || n === 8 || n === 9 || n === 10 ? one : n === 2 || n === 3 ? two : n === 4 ? few : n === 6 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  return i % 10 === 1 || i % 10 === 2 || i % 10 === 5 || i % 10 === 7 || i % 10 === 8 || i % 100 === 20 || i % 100 === 50 || i % 100 === 70 || i % 100 === 80 ? one : i % 10 === 3 || i % 10 === 4 || i % 1000 === 100 || i % 1000 === 200 || i % 1000 === 300 || i % 1000 === 400 || i % 1000 === 500 || i % 1000 === 600 || i % 1000 === 700 || i % 1000 === 800 || i % 1000 === 900 ? few : i === 0 || i % 10 === 6 || i % 100 === 40 || i % 100 === 60 || i % 100 === 90 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return (n % 10 === 2 || n % 10 === 3) && n % 100 !== 12 && n % 100 !== 13 ? few : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 1 || n === 3 ? one : n === 2 ? two : n === 4 ? few : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 0 || n === 7 || n === 8 || n === 9 ? zero : n === 1 ? one : n === 2 ? two : n === 3 || n === 4 ? few : n === 5 || n === 6 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n % 10 === 1 && n % 100 !== 11 ? one : n % 10 === 2 && n % 100 !== 12 ? two : n % 10 === 3 && n % 100 !== 13 ? few : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 1 || n === 11 ? one : n === 2 || n === 12 ? two : n === 3 || n === 13 ? few : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 1 ? one : n === 2 || n === 3 ? two : n === 4 ? few : n === 6 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 1 || n === 5 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 11 || n === 8 || n === 80 || n === 800 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  return i === 1 ? one : i === 0 || 2 <= i % 100 && i % 100 <= 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n % 10 === 6 || n % 10 === 9 || n % 10 === 0 && n !== 0 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var i = Math.floor(Math.abs(+s));\n  return i % 10 === 1 && i % 100 !== 11 ? one : i % 10 === 2 && i % 100 !== 12 ? two : (i % 10 === 7 || i % 10 === 8) && i % 100 !== 17 && i % 100 !== 18 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 1 ? one : n === 2 || n === 3 ? two : n === 4 ? few : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return 1 <= n && n <= 4 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 1 || n === 5 || 7 <= n && n <= 9 ? one : n === 2 || n === 3 ? two : n === 4 ? few : n === 6 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n === 1 ? one : n % 10 === 4 && n % 100 !== 14 ? many : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return (n % 10 === 1 || n % 10 === 2) && n % 100 !== 11 && n % 100 !== 12 ? one : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n % 10 === 6 || n % 10 === 9 || n === 10 ? few : other;\n}, function (s /*: string | number */) /*: Rule */{\n  var n = +s;\n  return n % 10 === 3 && n % 100 !== 13 ? few : other;\n}];\nmodule.exports = {\n  af: {\n    cardinal: f[0]\n  },\n  ak: {\n    cardinal: f[1]\n  },\n  am: {\n    cardinal: f[2]\n  },\n  ar: {\n    cardinal: f[3]\n  },\n  ars: {\n    cardinal: f[3]\n  },\n  as: {\n    cardinal: f[2],\n    ordinal: f[34]\n  },\n  asa: {\n    cardinal: f[0]\n  },\n  ast: {\n    cardinal: f[4]\n  },\n  az: {\n    cardinal: f[0],\n    ordinal: f[35]\n  },\n  be: {\n    cardinal: f[5],\n    ordinal: f[36]\n  },\n  bem: {\n    cardinal: f[0]\n  },\n  bez: {\n    cardinal: f[0]\n  },\n  bg: {\n    cardinal: f[0]\n  },\n  bh: {\n    cardinal: f[1]\n  },\n  bn: {\n    cardinal: f[2],\n    ordinal: f[34]\n  },\n  br: {\n    cardinal: f[6]\n  },\n  brx: {\n    cardinal: f[0]\n  },\n  bs: {\n    cardinal: f[7]\n  },\n  ca: {\n    cardinal: f[4],\n    ordinal: f[37]\n  },\n  ce: {\n    cardinal: f[0]\n  },\n  cgg: {\n    cardinal: f[0]\n  },\n  chr: {\n    cardinal: f[0]\n  },\n  ckb: {\n    cardinal: f[0]\n  },\n  cs: {\n    cardinal: f[8]\n  },\n  cy: {\n    cardinal: f[9],\n    ordinal: f[38]\n  },\n  da: {\n    cardinal: f[10]\n  },\n  de: {\n    cardinal: f[4]\n  },\n  dsb: {\n    cardinal: f[11]\n  },\n  dv: {\n    cardinal: f[0]\n  },\n  ee: {\n    cardinal: f[0]\n  },\n  el: {\n    cardinal: f[0]\n  },\n  en: {\n    cardinal: f[4],\n    ordinal: f[39]\n  },\n  eo: {\n    cardinal: f[0]\n  },\n  es: {\n    cardinal: f[0]\n  },\n  et: {\n    cardinal: f[4]\n  },\n  eu: {\n    cardinal: f[0]\n  },\n  fa: {\n    cardinal: f[2]\n  },\n  ff: {\n    cardinal: f[12]\n  },\n  fi: {\n    cardinal: f[4]\n  },\n  fil: {\n    cardinal: f[13],\n    ordinal: f[0]\n  },\n  fo: {\n    cardinal: f[0]\n  },\n  fr: {\n    cardinal: f[12],\n    ordinal: f[0]\n  },\n  fur: {\n    cardinal: f[0]\n  },\n  fy: {\n    cardinal: f[4]\n  },\n  ga: {\n    cardinal: f[14],\n    ordinal: f[0]\n  },\n  gd: {\n    cardinal: f[15],\n    ordinal: f[40]\n  },\n  gl: {\n    cardinal: f[4]\n  },\n  gsw: {\n    cardinal: f[0]\n  },\n  gu: {\n    cardinal: f[2],\n    ordinal: f[41]\n  },\n  guw: {\n    cardinal: f[1]\n  },\n  gv: {\n    cardinal: f[16]\n  },\n  ha: {\n    cardinal: f[0]\n  },\n  haw: {\n    cardinal: f[0]\n  },\n  he: {\n    cardinal: f[17]\n  },\n  hi: {\n    cardinal: f[2],\n    ordinal: f[41]\n  },\n  hr: {\n    cardinal: f[7]\n  },\n  hsb: {\n    cardinal: f[11]\n  },\n  hu: {\n    cardinal: f[0],\n    ordinal: f[42]\n  },\n  hy: {\n    cardinal: f[12],\n    ordinal: f[0]\n  },\n  ia: {\n    cardinal: f[4]\n  },\n  io: {\n    cardinal: f[4]\n  },\n  is: {\n    cardinal: f[18]\n  },\n  it: {\n    cardinal: f[4],\n    ordinal: f[43]\n  },\n  iu: {\n    cardinal: f[19]\n  },\n  iw: {\n    cardinal: f[17]\n  },\n  jgo: {\n    cardinal: f[0]\n  },\n  ji: {\n    cardinal: f[4]\n  },\n  jmc: {\n    cardinal: f[0]\n  },\n  ka: {\n    cardinal: f[0],\n    ordinal: f[44]\n  },\n  kab: {\n    cardinal: f[12]\n  },\n  kaj: {\n    cardinal: f[0]\n  },\n  kcg: {\n    cardinal: f[0]\n  },\n  kk: {\n    cardinal: f[0],\n    ordinal: f[45]\n  },\n  kkj: {\n    cardinal: f[0]\n  },\n  kl: {\n    cardinal: f[0]\n  },\n  kn: {\n    cardinal: f[2]\n  },\n  ks: {\n    cardinal: f[0]\n  },\n  ksb: {\n    cardinal: f[0]\n  },\n  ksh: {\n    cardinal: f[20]\n  },\n  ku: {\n    cardinal: f[0]\n  },\n  kw: {\n    cardinal: f[19]\n  },\n  ky: {\n    cardinal: f[0]\n  },\n  lag: {\n    cardinal: f[21]\n  },\n  lb: {\n    cardinal: f[0]\n  },\n  lg: {\n    cardinal: f[0]\n  },\n  ln: {\n    cardinal: f[1]\n  },\n  lt: {\n    cardinal: f[22]\n  },\n  lv: {\n    cardinal: f[23]\n  },\n  mas: {\n    cardinal: f[0]\n  },\n  mg: {\n    cardinal: f[1]\n  },\n  mgo: {\n    cardinal: f[0]\n  },\n  mk: {\n    cardinal: f[24],\n    ordinal: f[46]\n  },\n  ml: {\n    cardinal: f[0]\n  },\n  mn: {\n    cardinal: f[0]\n  },\n  mo: {\n    cardinal: f[25],\n    ordinal: f[0]\n  },\n  mr: {\n    cardinal: f[2],\n    ordinal: f[47]\n  },\n  mt: {\n    cardinal: f[26]\n  },\n  nah: {\n    cardinal: f[0]\n  },\n  naq: {\n    cardinal: f[19]\n  },\n  nb: {\n    cardinal: f[0]\n  },\n  nd: {\n    cardinal: f[0]\n  },\n  ne: {\n    cardinal: f[0],\n    ordinal: f[48]\n  },\n  nl: {\n    cardinal: f[4]\n  },\n  nn: {\n    cardinal: f[0]\n  },\n  nnh: {\n    cardinal: f[0]\n  },\n  no: {\n    cardinal: f[0]\n  },\n  nr: {\n    cardinal: f[0]\n  },\n  nso: {\n    cardinal: f[1]\n  },\n  ny: {\n    cardinal: f[0]\n  },\n  nyn: {\n    cardinal: f[0]\n  },\n  om: {\n    cardinal: f[0]\n  },\n  or: {\n    cardinal: f[0],\n    ordinal: f[49]\n  },\n  os: {\n    cardinal: f[0]\n  },\n  pa: {\n    cardinal: f[1]\n  },\n  pap: {\n    cardinal: f[0]\n  },\n  pl: {\n    cardinal: f[27]\n  },\n  prg: {\n    cardinal: f[23]\n  },\n  ps: {\n    cardinal: f[0]\n  },\n  pt: {\n    cardinal: f[28]\n  },\n  'pt-PT': {\n    cardinal: f[4]\n  },\n  rm: {\n    cardinal: f[0]\n  },\n  ro: {\n    cardinal: f[25],\n    ordinal: f[0]\n  },\n  rof: {\n    cardinal: f[0]\n  },\n  ru: {\n    cardinal: f[29]\n  },\n  rwk: {\n    cardinal: f[0]\n  },\n  saq: {\n    cardinal: f[0]\n  },\n  sc: {\n    cardinal: f[4],\n    ordinal: f[43]\n  },\n  scn: {\n    cardinal: f[4],\n    ordinal: f[43]\n  },\n  sd: {\n    cardinal: f[0]\n  },\n  sdh: {\n    cardinal: f[0]\n  },\n  se: {\n    cardinal: f[19]\n  },\n  seh: {\n    cardinal: f[0]\n  },\n  sh: {\n    cardinal: f[7]\n  },\n  shi: {\n    cardinal: f[30]\n  },\n  si: {\n    cardinal: f[31]\n  },\n  sk: {\n    cardinal: f[8]\n  },\n  sl: {\n    cardinal: f[32]\n  },\n  sma: {\n    cardinal: f[19]\n  },\n  smi: {\n    cardinal: f[19]\n  },\n  smj: {\n    cardinal: f[19]\n  },\n  smn: {\n    cardinal: f[19]\n  },\n  sms: {\n    cardinal: f[19]\n  },\n  sn: {\n    cardinal: f[0]\n  },\n  so: {\n    cardinal: f[0]\n  },\n  sq: {\n    cardinal: f[0],\n    ordinal: f[50]\n  },\n  sr: {\n    cardinal: f[7]\n  },\n  ss: {\n    cardinal: f[0]\n  },\n  ssy: {\n    cardinal: f[0]\n  },\n  st: {\n    cardinal: f[0]\n  },\n  sv: {\n    cardinal: f[4],\n    ordinal: f[51]\n  },\n  sw: {\n    cardinal: f[4]\n  },\n  syr: {\n    cardinal: f[0]\n  },\n  ta: {\n    cardinal: f[0]\n  },\n  te: {\n    cardinal: f[0]\n  },\n  teo: {\n    cardinal: f[0]\n  },\n  ti: {\n    cardinal: f[1]\n  },\n  tig: {\n    cardinal: f[0]\n  },\n  tk: {\n    cardinal: f[0],\n    ordinal: f[52]\n  },\n  tl: {\n    cardinal: f[13],\n    ordinal: f[0]\n  },\n  tn: {\n    cardinal: f[0]\n  },\n  tr: {\n    cardinal: f[0]\n  },\n  ts: {\n    cardinal: f[0]\n  },\n  tzm: {\n    cardinal: f[33]\n  },\n  ug: {\n    cardinal: f[0]\n  },\n  uk: {\n    cardinal: f[29],\n    ordinal: f[53]\n  },\n  ur: {\n    cardinal: f[4]\n  },\n  uz: {\n    cardinal: f[0]\n  },\n  ve: {\n    cardinal: f[0]\n  },\n  vo: {\n    cardinal: f[0]\n  },\n  vun: {\n    cardinal: f[0]\n  },\n  wa: {\n    cardinal: f[1]\n  },\n  wae: {\n    cardinal: f[0]\n  },\n  xh: {\n    cardinal: f[0]\n  },\n  xog: {\n    cardinal: f[0]\n  },\n  yi: {\n    cardinal: f[4]\n  },\n  zu: {\n    cardinal: f[2]\n  },\n  lo: {\n    ordinal: f[0]\n  },\n  ms: {\n    ordinal: f[0]\n  },\n  vi: {\n    ordinal: f[0]\n  }\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/* eslint-env worker */\n\nconst ScratchCommon = __webpack_require__(9);\nconst createScratchX = __webpack_require__(13);\nconst dispatch = __webpack_require__(15);\nconst log = __webpack_require__(0);\nconst {\n  isWorker\n} = __webpack_require__(3);\nconst createTranslate = __webpack_require__(18);\nconst translate = createTranslate(null);\nconst loadScripts = url => {\n  if (isWorker) {\n    importScripts(url);\n  } else {\n    return new Promise((resolve, reject) => {\n      const script = document.createElement('script');\n      script.onload = () => resolve();\n      script.onerror = () => {\n        reject(new Error(\"Error in sandboxed script: \".concat(url, \". Check the console for more information.\")));\n      };\n      script.src = url;\n      document.body.appendChild(script);\n    });\n  }\n};\nclass ExtensionWorker {\n  constructor() {\n    this.nextExtensionId = 0;\n    this.initialRegistrations = [];\n    this.firstRegistrationPromise = new Promise(resolve => {\n      this.firstRegistrationCallback = resolve;\n    });\n    dispatch.waitForConnection.then(() => {\n      dispatch.call('extensions', 'allocateWorker').then(async x => {\n        const [id, extension] = x;\n        this.workerId = id;\n        try {\n          await loadScripts(extension);\n          await this.firstRegistrationPromise;\n          const initialRegistrations = this.initialRegistrations;\n          this.initialRegistrations = null;\n          Promise.all(initialRegistrations).then(() => dispatch.call('extensions', 'onWorkerInit', id));\n        } catch (e) {\n          log.error(e);\n          dispatch.call('extensions', 'onWorkerInit', id, \"\".concat(e));\n        }\n      });\n    });\n    this.extensions = [];\n  }\n  register(extensionObject) {\n    const extensionId = this.nextExtensionId++;\n    this.extensions.push(extensionObject);\n    const serviceName = \"extension.\".concat(this.workerId, \".\").concat(extensionId);\n    const promise = dispatch.setService(serviceName, extensionObject).then(() => dispatch.call('extensions', 'registerExtensionService', serviceName));\n    if (this.initialRegistrations) {\n      this.firstRegistrationCallback();\n      this.initialRegistrations.push(promise);\n    }\n    return promise;\n  }\n}\nglobal.Scratch = global.Scratch || {};\nObject.assign(global.Scratch, ScratchCommon, {\n  canFetch: () => Promise.resolve(true),\n  fetch: function (_fetch) {\n    function fetch(_x, _x2) {\n      return _fetch.apply(this, arguments);\n    }\n    fetch.toString = function () {\n      return _fetch.toString();\n    };\n    return fetch;\n  }((url, options) => fetch(url, options)),\n  canOpenWindow: () => Promise.resolve(false),\n  openWindow: () => Promise.reject(new Error('Scratch.openWindow not supported in sandboxed extensions')),\n  canRedirect: () => Promise.resolve(false),\n  redirect: () => Promise.reject(new Error('Scratch.redirect not supported in sandboxed extensions')),\n  canRecordAudio: () => Promise.resolve(false),\n  canRecordVideo: () => Promise.resolve(false),\n  canReadClipboard: () => Promise.resolve(false),\n  canNotify: () => Promise.resolve(false),\n  canGeolocate: () => Promise.resolve(false),\n  canEmbed: () => Promise.resolve(false),\n  translate\n});\n\n/**\n * Expose only specific parts of the worker to extensions.\n */\nconst extensionWorker = new ExtensionWorker();\nglobal.Scratch.extensions = {\n  register: extensionWorker.register.bind(extensionWorker)\n};\nglobal.ScratchExtensions = createScratchX(global.Scratch);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(8)))\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n  return this;\n}();\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function(\"return this\")();\n} catch (e) {\n  // This works if the window reference is available\n  if (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\nconst ArgumentType = __webpack_require__(1);\nconst BlockType = __webpack_require__(2);\nconst TargetType = __webpack_require__(10);\nconst Cast = __webpack_require__(11);\nconst Scratch = {\n  ArgumentType,\n  BlockType,\n  TargetType,\n  Cast\n};\nmodule.exports = Scratch;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n/**\n * Default types of Target supported by the VM\n * @enum {string}\n */\nconst TargetType = {\n  /**\n   * Rendered target which can move, change costumes, etc.\n   */\n  SPRITE: 'sprite',\n  /**\n   * Rendered target which cannot move but can change backdrops\n   */\n  STAGE: 'stage'\n};\nmodule.exports = TargetType;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\nconst Color = __webpack_require__(12);\n\n/**\n * @fileoverview\n * Utilities for casting and comparing Scratch data-types.\n * Scratch behaves slightly differently from JavaScript in many respects,\n * and these differences should be encapsulated below.\n * For example, in Scratch, add(1, join(\"hello\", world\")) -> 1.\n * This is because \"hello world\" is cast to 0.\n * In JavaScript, 1 + Number(\"hello\" + \"world\") would give you NaN.\n * Use when coercing a value before computation.\n */\n\n/**\n * Used internally by compare()\n * @param {*} val A value that evaluates to 0 in JS string-to-number conversation such as empty string, 0, or tab.\n * @returns {boolean} True if the value should not be treated as the number zero.\n */\nconst isNotActuallyZero = val => {\n  if (typeof val !== 'string') return false;\n  for (let i = 0; i < val.length; i++) {\n    const code = val.charCodeAt(i);\n    // '0'.charCodeAt(0) === 48\n    // '\\t'.charCodeAt(0) === 9\n    // We include tab for compatibility with scratch-www's broken trim() polyfill.\n    // https://github.com/TurboWarp/scratch-vm/issues/115\n    // https://scratch.mit.edu/projects/788261699/\n    if (code === 48 || code === 9) {\n      return false;\n    }\n  }\n  return true;\n};\nclass Cast {\n  /**\n   * Scratch cast to number.\n   * Treats NaN as 0.\n   * In Scratch 2.0, this is captured by `interp.numArg.`\n   * @param {*} value Value to cast to number.\n   * @return {number} The Scratch-casted number value.\n   */\n  static toNumber(value) {\n    // If value is already a number we don't need to coerce it with\n    // Number().\n    if (typeof value === 'number') {\n      // Scratch treats NaN as 0, when needed as a number.\n      // E.g., 0 + NaN -> 0.\n      if (Number.isNaN(value)) {\n        return 0;\n      }\n      return value;\n    }\n    const n = Number(value);\n    if (Number.isNaN(n)) {\n      // Scratch treats NaN as 0, when needed as a number.\n      // E.g., 0 + NaN -> 0.\n      return 0;\n    }\n    return n;\n  }\n\n  /**\n   * Scratch cast to boolean.\n   * In Scratch 2.0, this is captured by `interp.boolArg.`\n   * Treats some string values differently from JavaScript.\n   * @param {*} value Value to cast to boolean.\n   * @return {boolean} The Scratch-casted boolean value.\n   */\n  static toBoolean(value) {\n    // Already a boolean?\n    if (typeof value === 'boolean') {\n      return value;\n    }\n    if (typeof value === 'string') {\n      // These specific strings are treated as false in Scratch.\n      if (value === '' || value === '0' || value.toLowerCase() === 'false') {\n        return false;\n      }\n      // All other strings treated as true.\n      return true;\n    }\n    // Coerce other values and numbers.\n    return Boolean(value);\n  }\n\n  /**\n   * Scratch cast to string.\n   * @param {*} value Value to cast to string.\n   * @return {string} The Scratch-casted string value.\n   */\n  static toString(value) {\n    return String(value);\n  }\n\n  /**\n   * Cast any Scratch argument to an RGB color array to be used for the renderer.\n   * @param {*} value Value to convert to RGB color array.\n   * @return {Array.<number>} [r,g,b], values between 0-255.\n   */\n  static toRgbColorList(value) {\n    const color = Cast.toRgbColorObject(value);\n    return [color.r, color.g, color.b];\n  }\n\n  /**\n   * Cast any Scratch argument to an RGB color object to be used for the renderer.\n   * @param {*} value Value to convert to RGB color object.\n   * @return {RGBOject} [r,g,b], values between 0-255.\n   */\n  static toRgbColorObject(value) {\n    let color;\n    if (typeof value === 'string' && value.substring(0, 1) === '#') {\n      color = Color.hexToRgb(value);\n\n      // If the color wasn't *actually* a hex color, cast to black\n      if (!color) color = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 255\n      };\n    } else {\n      color = Color.decimalToRgb(Cast.toNumber(value));\n    }\n    return color;\n  }\n\n  /**\n   * Determine if a Scratch argument is a white space string (or null / empty).\n   * @param {*} val value to check.\n   * @return {boolean} True if the argument is all white spaces or null / empty.\n   */\n  static isWhiteSpace(val) {\n    return val === null || typeof val === 'string' && val.trim().length === 0;\n  }\n\n  /**\n   * Compare two values, using Scratch cast, case-insensitive string compare, etc.\n   * In Scratch 2.0, this is captured by `interp.compare.`\n   * @param {*} v1 First value to compare.\n   * @param {*} v2 Second value to compare.\n   * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.\n   */\n  static compare(v1, v2) {\n    let n1 = Number(v1);\n    let n2 = Number(v2);\n    if (n1 === 0 && isNotActuallyZero(v1)) {\n      n1 = NaN;\n    } else if (n2 === 0 && isNotActuallyZero(v2)) {\n      n2 = NaN;\n    }\n    if (isNaN(n1) || isNaN(n2)) {\n      // At least one argument can't be converted to a number.\n      // Scratch compares strings as case insensitive.\n      const s1 = String(v1).toLowerCase();\n      const s2 = String(v2).toLowerCase();\n      if (s1 < s2) {\n        return -1;\n      } else if (s1 > s2) {\n        return 1;\n      }\n      return 0;\n    }\n    // Handle the special case of Infinity\n    if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {\n      return 0;\n    }\n    // Compare as numbers.\n    return n1 - n2;\n  }\n\n  /**\n   * Determine if a Scratch argument number represents a round integer.\n   * @param {*} val Value to check.\n   * @return {boolean} True if number looks like an integer.\n   */\n  static isInt(val) {\n    // Values that are already numbers.\n    if (typeof val === 'number') {\n      if (isNaN(val)) {\n        // NaN is considered an integer.\n        return true;\n      }\n      // True if it's \"round\" (e.g., 2.0 and 2).\n      return val === Math.floor(val);\n    } else if (typeof val === 'boolean') {\n      // `True` and `false` always represent integer after Scratch cast.\n      return true;\n    } else if (typeof val === 'string') {\n      // If it contains a decimal point, don't consider it an int.\n      return val.indexOf('.') < 0;\n    }\n    return false;\n  }\n  static get LIST_INVALID() {\n    return 'INVALID';\n  }\n  static get LIST_ALL() {\n    return 'ALL';\n  }\n\n  /**\n   * Compute a 1-based index into a list, based on a Scratch argument.\n   * Two special cases may be returned:\n   * LIST_ALL: if the block is referring to all of the items in the list.\n   * LIST_INVALID: if the index was invalid in any way.\n   * @param {*} index Scratch arg, including 1-based numbers or special cases.\n   * @param {number} length Length of the list.\n   * @param {boolean} acceptAll Whether it should accept \"all\" or not.\n   * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.\n   */\n  static toListIndex(index, length, acceptAll) {\n    if (typeof index !== 'number') {\n      if (index === 'all') {\n        return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;\n      }\n      if (index === 'last') {\n        if (length > 0) {\n          return length;\n        }\n        return Cast.LIST_INVALID;\n      } else if (index === 'random' || index === 'any') {\n        if (length > 0) {\n          return 1 + Math.floor(Math.random() * length);\n        }\n        return Cast.LIST_INVALID;\n      }\n    }\n    index = Math.floor(Cast.toNumber(index));\n    if (index < 1 || index > length) {\n      return Cast.LIST_INVALID;\n    }\n    return index;\n  }\n}\nmodule.exports = Cast;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\nclass Color {\n  /**\n   * @typedef {object} RGBObject - An object representing a color in RGB format.\n   * @property {number} r - the red component, in the range [0, 255].\n   * @property {number} g - the green component, in the range [0, 255].\n   * @property {number} b - the blue component, in the range [0, 255].\n   */\n\n  /**\n   * @typedef {object} HSVObject - An object representing a color in HSV format.\n   * @property {number} h - hue, in the range [0-359).\n   * @property {number} s - saturation, in the range [0,1].\n   * @property {number} v - value, in the range [0,1].\n   */\n\n  /** @type {RGBObject} */\n  static get RGB_BLACK() {\n    return {\n      r: 0,\n      g: 0,\n      b: 0\n    };\n  }\n\n  /** @type {RGBObject} */\n  static get RGB_WHITE() {\n    return {\n      r: 255,\n      g: 255,\n      b: 255\n    };\n  }\n\n  /**\n   * Convert a Scratch decimal color to a hex string, #RRGGBB.\n   * @param {number} decimal RGB color as a decimal.\n   * @return {string} RGB color as #RRGGBB hex string.\n   */\n  static decimalToHex(decimal) {\n    if (decimal < 0) {\n      decimal += 0xFFFFFF + 1;\n    }\n    let hex = Number(decimal).toString(16);\n    hex = \"#\".concat('000000'.substr(0, 6 - hex.length)).concat(hex);\n    return hex;\n  }\n\n  /**\n   * Convert a Scratch decimal color to an RGB color object.\n   * @param {number} decimal RGB color as decimal.\n   * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n   */\n  static decimalToRgb(decimal) {\n    const a = decimal >> 24 & 0xFF;\n    const r = decimal >> 16 & 0xFF;\n    const g = decimal >> 8 & 0xFF;\n    const b = decimal & 0xFF;\n    return {\n      r: r,\n      g: g,\n      b: b,\n      a: a > 0 ? a : 255\n    };\n  }\n\n  /**\n   * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.\n   * @param {!string} hex Hex representation of the color.\n   * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n   */\n  static hexToRgb(hex) {\n    if (hex.startsWith('#')) {\n      hex = hex.substring(1);\n    }\n    const parsed = parseInt(hex, 16);\n    if (isNaN(parsed)) {\n      return null;\n    }\n    if (hex.length === 6) {\n      return {\n        r: parsed >> 16 & 0xff,\n        g: parsed >> 8 & 0xff,\n        b: parsed & 0xff\n      };\n    } else if (hex.length === 3) {\n      const r = parsed >> 8 & 0xf;\n      const g = parsed >> 4 & 0xf;\n      const b = parsed & 0xf;\n      return {\n        r: r << 4 | r,\n        g: g << 4 | g,\n        b: b << 4 | b\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Convert an RGB color object to a hex color.\n   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n   * @return {!string} Hex representation of the color.\n   */\n  static rgbToHex(rgb) {\n    return Color.decimalToHex(Color.rgbToDecimal(rgb));\n  }\n\n  /**\n   * Convert an RGB color object to a Scratch decimal color.\n   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n   * @return {!number} Number representing the color.\n   */\n  static rgbToDecimal(rgb) {\n    return (rgb.r << 16) + (rgb.g << 8) + rgb.b;\n  }\n\n  /**\n  * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.\n  * @param {!string} hex Hex representation of the color.\n  * @return {!number} Number representing the color.\n  */\n  static hexToDecimal(hex) {\n    return Color.rgbToDecimal(Color.hexToRgb(hex));\n  }\n\n  /**\n   * Convert an HSV color to RGB format.\n   * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n   * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n   */\n  static hsvToRgb(hsv) {\n    let h = hsv.h % 360;\n    if (h < 0) h += 360;\n    const s = Math.max(0, Math.min(hsv.s, 1));\n    const v = Math.max(0, Math.min(hsv.v, 1));\n    const i = Math.floor(h / 60);\n    const f = h / 60 - i;\n    const p = v * (1 - s);\n    const q = v * (1 - s * f);\n    const t = v * (1 - s * (1 - f));\n    let r;\n    let g;\n    let b;\n    switch (i) {\n      default:\n      case 0:\n        r = v;\n        g = t;\n        b = p;\n        break;\n      case 1:\n        r = q;\n        g = v;\n        b = p;\n        break;\n      case 2:\n        r = p;\n        g = v;\n        b = t;\n        break;\n      case 3:\n        r = p;\n        g = q;\n        b = v;\n        break;\n      case 4:\n        r = t;\n        g = p;\n        b = v;\n        break;\n      case 5:\n        r = v;\n        g = p;\n        b = q;\n        break;\n    }\n    return {\n      r: Math.floor(r * 255),\n      g: Math.floor(g * 255),\n      b: Math.floor(b * 255)\n    };\n  }\n\n  /**\n   * Convert an RGB color to HSV format.\n   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n   * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n   */\n  static rgbToHsv(rgb) {\n    const r = rgb.r / 255;\n    const g = rgb.g / 255;\n    const b = rgb.b / 255;\n    const x = Math.min(Math.min(r, g), b);\n    const v = Math.max(Math.max(r, g), b);\n\n    // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate\n    let h = 0;\n    let s = 0;\n    if (x !== v) {\n      const f = r === x ? g - b : g === x ? b - r : r - g;\n      const i = r === x ? 3 : g === x ? 5 : 1;\n      h = (i - f / (v - x)) * 60 % 360;\n      s = (v - x) / v;\n    }\n    return {\n      h: h,\n      s: s,\n      v: v\n    };\n  }\n\n  /**\n   * Linear interpolation between rgb0 and rgb1.\n   * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.\n   * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.\n   * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.\n   * @return {RGBObject} the interpolated color.\n   */\n  static mixRgb(rgb0, rgb1, fraction1) {\n    if (fraction1 <= 0) return rgb0;\n    if (fraction1 >= 1) return rgb1;\n    const fraction0 = 1 - fraction1;\n    return {\n      r: fraction0 * rgb0.r + fraction1 * rgb1.r,\n      g: fraction0 * rgb0.g + fraction1 * rgb1.g,\n      b: fraction0 * rgb0.b + fraction1 * rgb1.b\n    };\n  }\n}\nmodule.exports = Color;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// ScratchX API Documentation: https://github.com/LLK/scratchx/wiki/\n\nconst ArgumentType = __webpack_require__(1);\nconst BlockType = __webpack_require__(2);\nconst {\n  argumentIndexToId,\n  generateExtensionId\n} = __webpack_require__(14);\n\n/**\n * @typedef ScratchXDescriptor\n * @property {unknown[][]} blocks\n * @property {Record<string, unknown[]>} [menus]\n * @property {string} [url]\n * @property {string} [displayName]\n */\n\n/**\n * @typedef ScratchXStatus\n * @property {0|1|2} status 0 is red/error, 1 is yellow/not ready, 2 is green/ready\n * @property {string} msg\n */\n\nconst parseScratchXBlockType = type => {\n  if (type === '' || type === ' ' || type === 'w') {\n    return {\n      type: BlockType.COMMAND,\n      async: type === 'w'\n    };\n  }\n  if (type === 'r' || type === 'R') {\n    return {\n      type: BlockType.REPORTER,\n      async: type === 'R'\n    };\n  }\n  if (type === 'b') {\n    return {\n      type: BlockType.BOOLEAN,\n      // ScratchX docs don't seem to mention boolean reporters that wait\n      async: false\n    };\n  }\n  if (type === 'h') {\n    return {\n      type: BlockType.HAT,\n      async: false\n    };\n  }\n  throw new Error(\"Unknown ScratchX block type: \".concat(type));\n};\nconst isScratchCompatibleValue = v => typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean';\n\n/**\n * @param {string} argument ScratchX argument with leading % removed.\n * @param {unknown} defaultValue Default value, if any\n */\nconst parseScratchXArgument = (argument, defaultValue) => {\n  const result = {};\n  const hasDefaultValue = isScratchCompatibleValue(defaultValue);\n\n  // defaultValue is ignored for booleans in Scratch 3\n  if (hasDefaultValue && argument !== 'b') {\n    result.defaultValue = defaultValue;\n  }\n  if (argument === 's') {\n    result.type = ArgumentType.STRING;\n    if (!hasDefaultValue) {\n      result.defaultValue = '';\n    }\n  } else if (argument === 'n') {\n    result.type = ArgumentType.NUMBER;\n    if (!hasDefaultValue) {\n      result.defaultValue = 0;\n    }\n  } else if (argument[0] === 'm') {\n    result.type = ArgumentType.STRING;\n    const split = argument.split(/\\.|:/);\n    const menuName = split[1];\n    result.menu = menuName;\n  } else if (argument === 'b') {\n    result.type = ArgumentType.BOOLEAN;\n  } else {\n    throw new Error(\"Unknown ScratchX argument type: \".concat(argument));\n  }\n  return result;\n};\nconst wrapScratchXFunction = (originalFunction, argumentCount, async) => args => {\n  // Convert Scratch 3's argument object to an argument list expected by ScratchX\n  const argumentList = [];\n  for (let i = 0; i < argumentCount; i++) {\n    argumentList.push(args[argumentIndexToId(i)]);\n  }\n  if (async) {\n    return new Promise(resolve => {\n      originalFunction(...argumentList, resolve);\n    });\n  }\n  return originalFunction(...argumentList);\n};\n\n/**\n * @param {string} name\n * @param {ScratchXDescriptor} descriptor\n * @param {Record<string, () => unknown>} functions\n */\nconst convert = (name, descriptor, functions) => {\n  const extensionId = generateExtensionId(name);\n  const info = {\n    id: extensionId,\n    name: descriptor.displayName || name,\n    blocks: [],\n    color1: '#4a4a5e',\n    color2: '#31323f',\n    color3: '#191a21'\n  };\n  const scratch3Extension = {\n    getInfo: () => info,\n    _getStatus: functions._getStatus\n  };\n  if (descriptor.url) {\n    info.docsURI = descriptor.url;\n  }\n  for (const blockDescriptor of descriptor.blocks) {\n    if (blockDescriptor.length === 1) {\n      // Separator\n      info.blocks.push('---');\n      continue;\n    }\n    const scratchXBlockType = blockDescriptor[0];\n    const blockText = blockDescriptor[1];\n    const functionName = blockDescriptor[2];\n    const defaultArgumentValues = blockDescriptor.slice(3);\n    let scratchText = '';\n    const argumentInfo = [];\n    const blockTextParts = blockText.split(/%([\\w.:]+)/g);\n    for (let i = 0; i < blockTextParts.length; i++) {\n      const part = blockTextParts[i];\n      const isArgument = i % 2 === 1;\n      if (isArgument) {\n        parseScratchXArgument(part);\n        const argumentIndex = Math.floor(i / 2).toString();\n        const argumentDefaultValue = defaultArgumentValues[argumentIndex];\n        const argumentId = argumentIndexToId(argumentIndex);\n        argumentInfo[argumentId] = parseScratchXArgument(part, argumentDefaultValue);\n        scratchText += \"[\".concat(argumentId, \"]\");\n      } else {\n        scratchText += part;\n      }\n    }\n    const scratch3BlockType = parseScratchXBlockType(scratchXBlockType);\n    const blockInfo = {\n      opcode: functionName,\n      blockType: scratch3BlockType.type,\n      text: scratchText,\n      arguments: argumentInfo\n    };\n    info.blocks.push(blockInfo);\n    const originalFunction = functions[functionName];\n    const argumentCount = argumentInfo.length;\n    scratch3Extension[functionName] = wrapScratchXFunction(originalFunction, argumentCount, scratch3BlockType.async);\n  }\n  const menus = descriptor.menus;\n  if (menus) {\n    const scratch3Menus = {};\n    for (const menuName of Object.keys(menus) || {}) {\n      const menuItems = menus[menuName];\n      const menuInfo = {\n        items: menuItems\n      };\n      scratch3Menus[menuName] = menuInfo;\n    }\n    info.menus = scratch3Menus;\n  }\n  return scratch3Extension;\n};\nconst extensionNameToExtension = new Map();\n\n/**\n * @param {*} Scratch Scratch 3.0 extension API object\n * @returns {*} ScratchX-compatible API object\n */\nconst createScratchX = Scratch => {\n  const register = (name, descriptor, functions) => {\n    const scratch3Extension = convert(name, descriptor, functions);\n    extensionNameToExtension.set(name, scratch3Extension);\n    Scratch.extensions.register(scratch3Extension);\n  };\n\n  /**\n   * @param {string} extensionName\n   * @returns {ScratchXStatus}\n   */\n  const getStatus = extensionName => {\n    const extension = extensionNameToExtension.get(extensionName);\n    if (extension) {\n      return extension._getStatus();\n    }\n    return {\n      status: 0,\n      msg: 'does not exist'\n    };\n  };\n  return {\n    register,\n    getStatus\n  };\n};\nmodule.exports = createScratchX;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n/**\n * @fileoverview\n * General ScratchX-related utilities used in multiple places.\n * Changing these functions may break projects.\n */\n\n/**\n * @param {string} scratchXName\n * @returns {string}\n */\nconst generateExtensionId = scratchXName => {\n  const sanitizedName = scratchXName.replace(/[^a-z0-9]/gi, '').toLowerCase();\n  return \"sbx\".concat(sanitizedName);\n};\n\n/**\n * @param {number} i 0-indexed index of argument in list\n * @returns {string} Scratch 3 argument name\n */\nconst argumentIndexToId = i => i.toString();\nmodule.exports = {\n  generateExtensionId,\n  argumentIndexToId\n};\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\nconst SharedDispatch = __webpack_require__(16);\nconst log = __webpack_require__(0);\nconst {\n  centralDispatchService\n} = __webpack_require__(3);\n\n/**\n * This class provides a Worker with the means to participate in the message dispatch system managed by CentralDispatch.\n * From any context in the messaging system, the dispatcher's \"call\" method can call any method on any \"service\"\n * provided in any participating context. The dispatch system will forward function arguments and return values across\n * worker boundaries as needed.\n * @see {CentralDispatch}\n */\nclass WorkerDispatch extends SharedDispatch {\n  constructor() {\n    super();\n\n    /**\n     * This promise will be resolved when we have successfully connected to central dispatch.\n     * @type {Promise}\n     * @see {waitForConnection}\n     * @private\n     */\n    this._connectionPromise = new Promise(resolve => {\n      this._onConnect = resolve;\n    });\n\n    /**\n     * Map of service name to local service provider.\n     * If a service is not listed here, it is assumed to be provided by another context (another Worker or the main\n     * thread).\n     * @see {setService}\n     * @type {object}\n     */\n    this.services = {};\n    this._onMessage = this._onMessage.bind(this, centralDispatchService);\n    if (typeof self !== 'undefined') {\n      self.onmessage = this._onMessage;\n    }\n  }\n\n  /**\n   * @returns {Promise} a promise which will resolve upon connection to central dispatch. If you need to make a call\n   * immediately on \"startup\" you can attach a 'then' to this promise.\n   * @example\n   *      dispatch.waitForConnection.then(() => {\n   *          dispatch.call('myService', 'hello');\n   *      })\n   */\n  get waitForConnection() {\n    return this._connectionPromise;\n  }\n\n  /**\n   * Set a local object as the global provider of the specified service.\n   * WARNING: Any method on the provider can be called from any worker within the dispatch system.\n   * @param {string} service - a globally unique string identifying this service. Examples: 'vm', 'gui', 'extension9'.\n   * @param {object} provider - a local object which provides this service.\n   * @returns {Promise} - a promise which will resolve once the service is registered.\n   */\n  setService(service, provider) {\n    if (Object.prototype.hasOwnProperty.call(this.services, service)) {\n      log.warn(\"Worker dispatch replacing existing service provider for \".concat(service));\n    }\n    this.services[service] = provider;\n    return this.waitForConnection.then(() => this._remoteCall(centralDispatchService, 'dispatch', 'setService', service));\n  }\n\n  /**\n   * Fetch the service provider object for a particular service name.\n   * @override\n   * @param {string} service - the name of the service to look up\n   * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found\n   * @protected\n   */\n  _getServiceProvider(service) {\n    // if we don't have a local service by this name, contact central dispatch by calling `postMessage` on self\n    const provider = this.services[service];\n    return {\n      provider: provider || centralDispatchService,\n      isRemote: !provider\n    };\n  }\n\n  /**\n   * Handle a call message sent to the dispatch service itself\n   * @override\n   * @param {Worker} worker - the worker which sent the message.\n   * @param {DispatchCallMessage} message - the message to be handled.\n   * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate\n   * @protected\n   */\n  _onDispatchMessage(worker, message) {\n    let promise;\n    switch (message.method) {\n      case 'handshake':\n        promise = this._onConnect();\n        break;\n      case 'terminate':\n        // Don't close until next tick, after sending confirmation back\n        setTimeout(() => self.close(), 0);\n        promise = Promise.resolve();\n        break;\n      default:\n        log.error(\"Worker dispatch received message for unknown method: \".concat(message.method));\n    }\n    return promise;\n  }\n}\nmodule.exports = new WorkerDispatch();\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\nconst log = __webpack_require__(0);\n\n/**\n * @typedef {object} DispatchCallMessage - a message to the dispatch system representing a service method call\n * @property {*} responseId - send a response message with this response ID. See {@link DispatchResponseMessage}\n * @property {string} service - the name of the service to be called\n * @property {string} method - the name of the method to be called\n * @property {Array|undefined} args - the arguments to be passed to the method\n */\n\n/**\n * @typedef {object} DispatchResponseMessage - a message to the dispatch system representing the results of a call\n * @property {*} responseId - a copy of the response ID from the call which generated this response\n * @property {*|undefined} error - if this is truthy, then it contains results from a failed call (such as an exception)\n * @property {*|undefined} result - if error is not truthy, then this contains the return value of the call (if any)\n */\n\n/**\n * @typedef {DispatchCallMessage|DispatchResponseMessage} DispatchMessage\n * Any message to the dispatch system.\n */\n\n/**\n * The SharedDispatch class is responsible for dispatch features shared by\n * {@link CentralDispatch} and {@link WorkerDispatch}.\n */\nclass SharedDispatch {\n  constructor() {\n    /**\n     * List of callback registrations for promises waiting for a response from a call to a service on another\n     * worker. A callback registration is an array of [resolve,reject] Promise functions.\n     * Calls to local services don't enter this list.\n     * @type {Array.<Function[]>}\n     */\n    this.callbacks = [];\n\n    /**\n     * The next response ID to be used.\n     * @type {int}\n     */\n    this.nextResponseId = 0;\n  }\n\n  /**\n   * Call a particular method on a particular service, regardless of whether that service is provided locally or on\n   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone\n   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be\n   * transferred to the worker, and they should not be used after this call.\n   * @example\n   *      dispatcher.call('vm', 'setData', 'cat', 42);\n   *      // this finds the worker for the 'vm' service, then on that worker calls:\n   *      vm.setData('cat', 42);\n   * @param {string} service - the name of the service.\n   * @param {string} method - the name of the method.\n   * @param {*} [args] - the arguments to be copied to the method, if any.\n   * @returns {Promise} - a promise for the return value of the service method.\n   */\n  call(service, method) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    return this.transferCall(service, method, null, ...args);\n  }\n\n  /**\n   * Call a particular method on a particular service, regardless of whether that service is provided locally or on\n   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone\n   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be\n   * transferred to the worker, and they should not be used after this call.\n   * @example\n   *      dispatcher.transferCall('vm', 'setData', [myArrayBuffer], 'cat', myArrayBuffer);\n   *      // this finds the worker for the 'vm' service, transfers `myArrayBuffer` to it, then on that worker calls:\n   *      vm.setData('cat', myArrayBuffer);\n   * @param {string} service - the name of the service.\n   * @param {string} method - the name of the method.\n   * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.\n   * @param {*} [args] - the arguments to be copied to the method, if any.\n   * @returns {Promise} - a promise for the return value of the service method.\n   */\n  transferCall(service, method, transfer) {\n    try {\n      const {\n        provider,\n        isRemote\n      } = this._getServiceProvider(service);\n      if (provider) {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          args[_key2 - 3] = arguments[_key2];\n        }\n        if (isRemote) {\n          return this._remoteTransferCall(provider, service, method, transfer, ...args);\n        }\n\n        // TODO: verify correct `this` after switching from apply to spread\n        // eslint-disable-next-line prefer-spread\n        const result = provider[method].apply(provider, args);\n        return Promise.resolve(result);\n      }\n      return Promise.reject(new Error(\"Service not found: \".concat(service)));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  /**\n   * Check if a particular service lives on another worker.\n   * @param {string} service - the service to check.\n   * @returns {boolean} - true if the service is remote (calls must cross a Worker boundary), false otherwise.\n   * @private\n   */\n  _isRemoteService(service) {\n    return this._getServiceProvider(service).isRemote;\n  }\n\n  /**\n   * Like {@link call}, but force the call to be posted through a particular communication channel.\n   * @param {object} provider - send the call through this object's `postMessage` function.\n   * @param {string} service - the name of the service.\n   * @param {string} method - the name of the method.\n   * @param {*} [args] - the arguments to be copied to the method, if any.\n   * @returns {Promise} - a promise for the return value of the service method.\n   */\n  _remoteCall(provider, service, method) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n      args[_key3 - 3] = arguments[_key3];\n    }\n    return this._remoteTransferCall(provider, service, method, null, ...args);\n  }\n\n  /**\n   * Like {@link transferCall}, but force the call to be posted through a particular communication channel.\n   * @param {object} provider - send the call through this object's `postMessage` function.\n   * @param {string} service - the name of the service.\n   * @param {string} method - the name of the method.\n   * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.\n   * @param {*} [args] - the arguments to be copied to the method, if any.\n   * @returns {Promise} - a promise for the return value of the service method.\n   */\n  _remoteTransferCall(provider, service, method, transfer) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 4 ? _len4 - 4 : 0), _key4 = 4; _key4 < _len4; _key4++) {\n      args[_key4 - 4] = arguments[_key4];\n    }\n    return new Promise((resolve, reject) => {\n      const responseId = this._storeCallbacks(resolve, reject);\n\n      /** @TODO: remove this hack! this is just here so we don't try to send `util` to a worker */\n      // tw: upstream's logic is broken\n      // Args is actually a 3 length list of [args, util, real block info]\n      // We only want to send args. The others will throw errors when they try to be cloned\n      if (args.length > 0 && typeof args[args.length - 1].func === 'function') {\n        args.pop();\n        args.pop();\n      }\n      if (transfer) {\n        provider.postMessage({\n          service,\n          method,\n          responseId,\n          args\n        }, transfer);\n      } else {\n        provider.postMessage({\n          service,\n          method,\n          responseId,\n          args\n        });\n      }\n    });\n  }\n\n  /**\n   * Store callback functions pending a response message.\n   * @param {Function} resolve - function to call if the service method returns.\n   * @param {Function} reject - function to call if the service method throws.\n   * @returns {*} - a unique response ID for this set of callbacks. See {@link _deliverResponse}.\n   * @protected\n   */\n  _storeCallbacks(resolve, reject) {\n    const responseId = this.nextResponseId++;\n    this.callbacks[responseId] = [resolve, reject];\n    return responseId;\n  }\n\n  /**\n   * Deliver call response from a worker. This should only be called as the result of a message from a worker.\n   * @param {int} responseId - the response ID of the callback set to call.\n   * @param {DispatchResponseMessage} message - the message containing the response value(s).\n   * @protected\n   */\n  _deliverResponse(responseId, message) {\n    try {\n      const [resolve, reject] = this.callbacks[responseId];\n      delete this.callbacks[responseId];\n      if (message.error) {\n        reject(message.error);\n      } else {\n        resolve(message.result);\n      }\n    } catch (e) {\n      log.error(\"Dispatch callback failed: \".concat(e));\n    }\n  }\n\n  /**\n   * Handle a message event received from a connected worker.\n   * @param {Worker} worker - the worker which sent the message, or the global object if running in a worker.\n   * @param {MessageEvent} event - the message event to be handled.\n   * @protected\n   */\n  _onMessage(worker, event) {\n    /** @type {DispatchMessage} */\n    const message = event.data;\n    message.args = message.args || [];\n    let promise;\n    if (message.service) {\n      if (message.service === 'dispatch') {\n        promise = this._onDispatchMessage(worker, message);\n      } else {\n        promise = this.call(message.service, message.method, ...message.args);\n      }\n    } else if (typeof message.responseId === 'undefined') {\n      log.error(\"Dispatch caught malformed message from a worker: \".concat(JSON.stringify(event)));\n    } else {\n      this._deliverResponse(message.responseId, message);\n    }\n    if (promise) {\n      if (typeof message.responseId === 'undefined') {\n        log.error(\"Dispatch message missing required response ID: \".concat(JSON.stringify(event)));\n      } else {\n        promise.then(result => worker.postMessage({\n          responseId: message.responseId,\n          result\n        }), error => worker.postMessage({\n          responseId: message.responseId,\n          error: \"\".concat(error)\n        }));\n      }\n    }\n  }\n\n  /**\n   * Fetch the service provider object for a particular service name.\n   * @abstract\n   * @param {string} service - the name of the service to look up\n   * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found\n   * @protected\n   */\n  _getServiceProvider(service) {\n    throw new Error(\"Could not get provider for \".concat(service, \": _getServiceProvider not implemented\"));\n  }\n\n  /**\n   * Handle a call message sent to the dispatch service itself\n   * @abstract\n   * @param {Worker} worker - the worker which sent the message.\n   * @param {DispatchCallMessage} message - the message to be handled.\n   * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate\n   * @private\n   */\n  _onDispatchMessage(worker, message) {\n    throw new Error(\"Unimplemented dispatch message handler cannot handle \".concat(message.method, \" method\"));\n  }\n}\nmodule.exports = SharedDispatch;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n// only use colors in non-browser environments\nconst addColors = typeof document === 'undefined';\nconst RESET = addColors ? '\\u001b[0m' : '';\nconst GRAY = addColors ? '\\u001b[90m' : '';\nconst BLUE = addColors ? '\\u001b[34m' : '';\nconst CYAN = addColors ? '\\u001b[36m' : '';\nconst YELLOW = addColors ? '\\u001b[33m' : '';\nconst RED = addColors ? '\\u001b[31m' : '';\nconst DEBUG = \"\".concat(BLUE, \"debug\").concat(RESET);\nconst INFO = \"\".concat(CYAN, \"info\").concat(RESET);\nconst WARN = \"\".concat(YELLOW, \"warn\").concat(RESET);\nconst ERROR = \"\".concat(RED, \"error\").concat(RESET);\nconst _createLog = function createLog() {\n  let namespace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  const log = childNamespace => _createLog(namespace ? \"\".concat(namespace, \" \").concat(childNamespace) : childNamespace);\n  const formattedNamespace = namespace ? [\"\".concat(GRAY).concat(namespace).concat(RESET)] : [];\n  log.debug = log.log = console.debug.bind(console, ...formattedNamespace, DEBUG);\n  log.info = console.log.bind(console, ...formattedNamespace, INFO);\n  log.warn = log.warning = console.warn.bind(console, ...formattedNamespace, WARN);\n  log.error = console.error.bind(console, ...formattedNamespace, ERROR);\n  return log;\n};\n\n/**\n * @deprecated does nothing\n */\n_createLog.enable = _createLog.disable = () => {};\nmodule.exports = _createLog;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\nconst formatMessage = __webpack_require__(19);\n\n/**\n * @param {VM|null} vm\n * @returns {object}\n */\nconst createTranslate = vm => {\n  const namespace = formatMessage.namespace();\n  const translate = (message, args) => {\n    if (message && typeof message === 'object') {\n      // already in the expected format\n    } else if (typeof message === 'string') {\n      message = {\n        default: message\n      };\n    } else {\n      throw new Error('unsupported data type in translate()');\n    }\n    return namespace(message, args);\n  };\n  const generateId = defaultMessage => \"_\".concat(defaultMessage);\n  const getLocale = () => {\n    if (vm) return vm.getLocale();\n    if (typeof navigator !== 'undefined') return navigator.language;\n    return 'en';\n  };\n  let storedTranslations = {};\n  translate.setup = newTranslations => {\n    if (newTranslations) {\n      storedTranslations = newTranslations;\n    }\n    namespace.setup({\n      locale: getLocale(),\n      missingTranslation: 'ignore',\n      generateId,\n      translations: storedTranslations\n    });\n  };\n  Object.defineProperty(translate, 'language', {\n    configurable: true,\n    enumerable: true,\n    get: () => getLocale()\n  });\n  translate.setup({});\n  if (vm) {\n    vm.on('LOCALE_CHANGED', () => {\n      translate.setup(null);\n    });\n  }\n  return translate;\n};\nmodule.exports = createTranslate;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// @flow\n\n\nvar parse = __webpack_require__(20);\nvar interpret = __webpack_require__(21);\nvar plurals = __webpack_require__(6);\nvar lookupClosestLocale = __webpack_require__(5);\nvar origFormats = __webpack_require__(4);\n\n/*::\nimport type { Types } from 'format-message-interpret'\ntype Locale = string\ntype Locales = Locale | Locale[]\ntype Message = string | {|\n  id?: string,\n  default: string,\n  description?: string\n|}\ntype Translations = { [string]: ?{ [string]: string | Translation } }\ntype Translation = {\n  message: string,\n  format?: (args?: Object) => string,\n  toParts?: (args?: Object) => any[],\n}\ntype Replacement = ?string | (string, string, locales?: Locales) => ?string\ntype GenerateId = (string) => string\ntype MissingTranslation = 'ignore' | 'warning' | 'error'\ntype FormatObject = { [string]: * }\ntype Options = {\n  locale?: Locales,\n  translations?: ?Translations,\n  generateId?: GenerateId,\n  missingReplacement?: Replacement,\n  missingTranslation?: MissingTranslation,\n  formats?: {\n    number?: FormatObject,\n    date?: FormatObject,\n    time?: FormatObject\n  },\n  types?: Types\n}\ntype Setup = {|\n  locale: Locales,\n  translations: Translations,\n  generateId: GenerateId,\n  missingReplacement: Replacement,\n  missingTranslation: MissingTranslation,\n  formats: {\n    number: FormatObject,\n    date: FormatObject,\n    time: FormatObject\n  },\n  types: Types\n|}\ntype FormatMessage = {\n  (msg: Message, args?: Object, locales?: Locales): string,\n  rich (msg: Message, args?: Object, locales?: Locales): any[],\n  setup (opt?: Options): Setup,\n  number (value: number, style?: string, locales?: Locales): string,\n  date (value: number | Date, style?: string, locales?: Locales): string,\n  time (value: number | Date, style?: string, locales?: Locales): string,\n  select (value: any, options: Object): any,\n  custom (placeholder: any[], locales: Locales, value: any, args: Object): any,\n  plural (value: number, offset: any, options: any, locale: any): any,\n  selectordinal (value: number, offset: any, options: any, locale: any): any,\n  namespace (): FormatMessage\n}\n*/\n\nfunction assign /*:: <T: Object> */(target /*: T */, source /*: Object */) {\n  Object.keys(source).forEach(function (key) {\n    target[key] = source[key];\n  });\n  return target;\n}\nfunction namespace() /*: FormatMessage */{\n  var formats = assign({}, origFormats);\n  var currentLocales /*: Locales */ = 'en';\n  var translations /*: Translations */ = {};\n  var generateId /*: GenerateId */ = function generateId(pattern) {\n    return pattern;\n  };\n  var missingReplacement /*: Replacement */ = null;\n  var missingTranslation /*: MissingTranslation */ = 'warning';\n  var types /*: Types */ = {};\n  function formatMessage(msg /*: Message */, args /*:: ?: Object */, locales /*:: ?: Locales */) {\n    var pattern = typeof msg === 'string' ? msg : msg.default;\n    var id = typeof msg === 'object' && msg.id || generateId(pattern);\n    var translated = translate(pattern, id, locales || currentLocales);\n    var format = translated.format || (translated.format = interpret(parse(translated.message), locales || currentLocales, types));\n    return format(args);\n  }\n  formatMessage.rich = function rich(msg /*: Message */, args /*:: ?: Object */, locales /*:: ?: Locales */) {\n    var pattern = typeof msg === 'string' ? msg : msg.default;\n    var id = typeof msg === 'object' && msg.id || generateId(pattern);\n    var translated = translate(pattern, id, locales || currentLocales);\n    var format = translated.toParts || (translated.toParts = interpret.toParts(parse(translated.message, {\n      tagsType: tagsType\n    }), locales || currentLocales, types));\n    return format(args);\n  };\n  var tagsType = '<>';\n  function richType(node /*: any[] */, locales /*: Locales */) {\n    var style = node[2];\n    return function (fn, args) {\n      var props = typeof style === 'object' ? mapObject(style, args) : style;\n      return typeof fn === 'function' ? fn(props) : fn;\n    };\n  }\n  types[tagsType] = richType;\n  function mapObject(object /* { [string]: (args?: Object) => any } */, args /*: ?Object */) {\n    return Object.keys(object).reduce(function (mapped, key) {\n      mapped[key] = object[key](args);\n      return mapped;\n    }, {});\n  }\n  function translate(pattern /*: string */, id /*: string */, locales /*: Locales */) /*: Translation */{\n    var locale = lookupClosestLocale(locales, translations) || 'en';\n    var messages = translations[locale] || (translations[locale] = {});\n    var translated = messages[id];\n    if (typeof translated === 'string') {\n      translated = messages[id] = {\n        message: translated\n      };\n    }\n    if (!translated) {\n      var message = 'Translation for \"' + id + '\" in \"' + locale + '\" is missing';\n      if (missingTranslation === 'warning') {\n        /* istanbul ignore else */\n        if (typeof console !== 'undefined') console.warn(message);\n      } else if (missingTranslation !== 'ignore') {\n        // 'error'\n        throw new Error(message);\n      }\n      var replacement = typeof missingReplacement === 'function' ? missingReplacement(pattern, id, locale) || pattern : missingReplacement || pattern;\n      translated = messages[id] = {\n        message: replacement\n      };\n    }\n    return translated;\n  }\n  formatMessage.setup = function setup(opt /*:: ?: Options */) {\n    opt = opt || {};\n    if (opt.locale) currentLocales = opt.locale;\n    if ('translations' in opt) translations = opt.translations || {};\n    if (opt.generateId) generateId = opt.generateId;\n    if ('missingReplacement' in opt) missingReplacement = opt.missingReplacement;\n    if (opt.missingTranslation) missingTranslation = opt.missingTranslation;\n    if (opt.formats) {\n      if (opt.formats.number) assign(formats.number, opt.formats.number);\n      if (opt.formats.date) assign(formats.date, opt.formats.date);\n      if (opt.formats.time) assign(formats.time, opt.formats.time);\n    }\n    if (opt.types) {\n      types = opt.types;\n      types[tagsType] = richType;\n    }\n    return {\n      locale: currentLocales,\n      translations: translations,\n      generateId: generateId,\n      missingReplacement: missingReplacement,\n      missingTranslation: missingTranslation,\n      formats: formats,\n      types: types\n    };\n  };\n  formatMessage.number = function (value /*: number */, style /*:: ?: string */, locales /*:: ?: Locales */) {\n    var options = style && formats.number[style] || formats.parseNumberPattern(style) || formats.number.default;\n    return new Intl.NumberFormat(locales || currentLocales, options).format(value);\n  };\n  formatMessage.date = function (value /*:: ?: number | Date */, style /*:: ?: string */, locales /*:: ?: Locales */) {\n    var options = style && formats.date[style] || formats.parseDatePattern(style) || formats.date.default;\n    return new Intl.DateTimeFormat(locales || currentLocales, options).format(value);\n  };\n  formatMessage.time = function (value /*:: ?: number | Date */, style /*:: ?: string */, locales /*:: ?: Locales */) {\n    var options = style && formats.time[style] || formats.parseDatePattern(style) || formats.time.default;\n    return new Intl.DateTimeFormat(locales || currentLocales, options).format(value);\n  };\n  formatMessage.select = function (value /*: any */, options /*: Object */) {\n    return options[value] || options.other;\n  };\n  formatMessage.custom = function (placeholder /*: any[] */, locales /*: Locales */, value /*: any */, args /*: Object */) {\n    if (!(placeholder[1] in types)) return value;\n    return types[placeholder[1]](placeholder, locales)(value, args);\n  };\n  formatMessage.plural = plural.bind(null, 'cardinal');\n  formatMessage.selectordinal = plural.bind(null, 'ordinal');\n  function plural(pluralType /*: 'cardinal' | 'ordinal' */, value /*: number */, offset /*: any */, options /*: any */, locale /*: any */) {\n    if (typeof offset === 'object' && typeof options !== 'object') {\n      // offset is optional\n      locale = options;\n      options = offset;\n      offset = 0;\n    }\n    var closest = lookupClosestLocale(locale || currentLocales, plurals);\n    var plural = closest && plurals[closest][pluralType] || returnOther;\n    return options['=' + +value] || options[plural(value - offset)] || options.other;\n  }\n  function returnOther( /*:: n:number */) {\n    return 'other';\n  }\n  formatMessage.namespace = namespace;\n  return formatMessage;\n}\nmodule.exports = exports = namespace();\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// @flow\n\n\n/*::\nexport type AST = Element[]\nexport type Element = string | Placeholder\nexport type Placeholder = Plural | Styled | Typed | Simple\nexport type Plural = [ string, 'plural' | 'selectordinal', number, SubMessages ]\nexport type Styled = [ string, string, string | SubMessages ]\nexport type Typed = [ string, string ]\nexport type Simple = [ string ]\nexport type SubMessages = { [string]: AST }\nexport type Token = [ TokenType, string ]\nexport type TokenType = 'text' | 'space' | 'id' | 'type' | 'style' | 'offset' | 'number' | 'selector' | 'syntax'\ntype Context = {|\n  pattern: string,\n  index: number,\n  tagsType: ?string,\n  tokens: ?Token[]\n|}\n*/\nvar ARG_OPN = '{';\nvar ARG_CLS = '}';\nvar ARG_SEP = ',';\nvar NUM_ARG = '#';\nvar TAG_OPN = '<';\nvar TAG_CLS = '>';\nvar TAG_END = '</';\nvar TAG_SELF_CLS = '/>';\nvar ESC = '\\'';\nvar OFFSET = 'offset:';\nvar simpleTypes = ['number', 'date', 'time', 'ordinal', 'duration', 'spellout'];\nvar submTypes = ['plural', 'select', 'selectordinal'];\n\n/**\n * parse\n *\n * Turns this:\n *  `You have { numBananas, plural,\n *       =0 {no bananas}\n *      one {a banana}\n *    other {# bananas}\n *  } for sale`\n *\n * into this:\n *  [ \"You have \", [ \"numBananas\", \"plural\", 0, {\n *       \"=0\": [ \"no bananas\" ],\n *      \"one\": [ \"a banana\" ],\n *    \"other\": [ [ '#' ], \" bananas\" ]\n *  } ], \" for sale.\" ]\n *\n * tokens:\n *  [\n *    [ \"text\", \"You have \" ],\n *    [ \"syntax\", \"{\" ],\n *    [ \"space\", \" \" ],\n *    [ \"id\", \"numBananas\" ],\n *    [ \"syntax\", \", \" ],\n *    [ \"space\", \" \" ],\n *    [ \"type\", \"plural\" ],\n *    [ \"syntax\", \",\" ],\n *    [ \"space\", \"\\n     \" ],\n *    [ \"selector\", \"=0\" ],\n *    [ \"space\", \" \" ],\n *    [ \"syntax\", \"{\" ],\n *    [ \"text\", \"no bananas\" ],\n *    [ \"syntax\", \"}\" ],\n *    [ \"space\", \"\\n    \" ],\n *    [ \"selector\", \"one\" ],\n *    [ \"space\", \" \" ],\n *    [ \"syntax\", \"{\" ],\n *    [ \"text\", \"a banana\" ],\n *    [ \"syntax\", \"}\" ],\n *    [ \"space\", \"\\n  \" ],\n *    [ \"selector\", \"other\" ],\n *    [ \"space\", \" \" ],\n *    [ \"syntax\", \"{\" ],\n *    [ \"syntax\", \"#\" ],\n *    [ \"text\", \" bananas\" ],\n *    [ \"syntax\", \"}\" ],\n *    [ \"space\", \"\\n\" ],\n *    [ \"syntax\", \"}\" ],\n *    [ \"text\", \" for sale.\" ]\n *  ]\n **/\nexports = module.exports = function parse(pattern /*: string */, options /*:: ?: { tagsType?: string, tokens?: Token[] } */) /*: AST */{\n  return parseAST({\n    pattern: String(pattern),\n    index: 0,\n    tagsType: options && options.tagsType || null,\n    tokens: options && options.tokens || null\n  }, '');\n};\nfunction parseAST(current /*: Context */, parentType /*: string */) /*: AST */{\n  var pattern = current.pattern;\n  var length = pattern.length;\n  var elements /*: AST */ = [];\n  var start = current.index;\n  var text = parseText(current, parentType);\n  if (text) elements.push(text);\n  if (text && current.tokens) current.tokens.push(['text', pattern.slice(start, current.index)]);\n  while (current.index < length) {\n    if (pattern[current.index] === ARG_CLS) {\n      if (!parentType) throw expected(current);\n      break;\n    }\n    if (parentType && current.tagsType && pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) break;\n    elements.push(parsePlaceholder(current));\n    start = current.index;\n    text = parseText(current, parentType);\n    if (text) elements.push(text);\n    if (text && current.tokens) current.tokens.push(['text', pattern.slice(start, current.index)]);\n  }\n  return elements;\n}\nfunction parseText(current /*: Context */, parentType /*: string */) /*: string */{\n  var pattern = current.pattern;\n  var length = pattern.length;\n  var isHashSpecial = parentType === 'plural' || parentType === 'selectordinal';\n  var isAngleSpecial = !!current.tagsType;\n  var isArgStyle = parentType === '{style}';\n  var text = '';\n  while (current.index < length) {\n    var char = pattern[current.index];\n    if (char === ARG_OPN || char === ARG_CLS || isHashSpecial && char === NUM_ARG || isAngleSpecial && char === TAG_OPN || isArgStyle && isWhitespace(char.charCodeAt(0))) {\n      break;\n    } else if (char === ESC) {\n      char = pattern[++current.index];\n      if (char === ESC) {\n        // double is always 1 '\n        text += char;\n        ++current.index;\n      } else if (\n      // only when necessary\n      char === ARG_OPN || char === ARG_CLS || isHashSpecial && char === NUM_ARG || isAngleSpecial && char === TAG_OPN || isArgStyle) {\n        text += char;\n        while (++current.index < length) {\n          char = pattern[current.index];\n          if (char === ESC && pattern[current.index + 1] === ESC) {\n            // double is always 1 '\n            text += ESC;\n            ++current.index;\n          } else if (char === ESC) {\n            // end of quoted\n            ++current.index;\n            break;\n          } else {\n            text += char;\n          }\n        }\n      } else {\n        // lone ' is just a '\n        text += ESC;\n        // already incremented\n      }\n    } else {\n      text += char;\n      ++current.index;\n    }\n  }\n  return text;\n}\nfunction isWhitespace(code /*: number */) /*: boolean */{\n  return code >= 0x09 && code <= 0x0D || code === 0x20 || code === 0x85 || code === 0xA0 || code === 0x180E || code >= 0x2000 && code <= 0x200D || code === 0x2028 || code === 0x2029 || code === 0x202F || code === 0x205F || code === 0x2060 || code === 0x3000 || code === 0xFEFF;\n}\nfunction skipWhitespace(current /*: Context */) /*: void */{\n  var pattern = current.pattern;\n  var length = pattern.length;\n  var start = current.index;\n  while (current.index < length && isWhitespace(pattern.charCodeAt(current.index))) {\n    ++current.index;\n  }\n  if (start < current.index && current.tokens) {\n    current.tokens.push(['space', current.pattern.slice(start, current.index)]);\n  }\n}\nfunction parsePlaceholder(current /*: Context */) /*: Placeholder */{\n  var pattern = current.pattern;\n  if (pattern[current.index] === NUM_ARG) {\n    if (current.tokens) current.tokens.push(['syntax', NUM_ARG]);\n    ++current.index; // move passed #\n    return [NUM_ARG];\n  }\n  var tag = parseTag(current);\n  if (tag) return tag;\n\n  /* istanbul ignore if should be unreachable if parseAST and parseText are right */\n  if (pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN);\n  if (current.tokens) current.tokens.push(['syntax', ARG_OPN]);\n  ++current.index; // move passed {\n  skipWhitespace(current);\n  var id = parseId(current);\n  if (!id) throw expected(current, 'placeholder id');\n  if (current.tokens) current.tokens.push(['id', id]);\n  skipWhitespace(current);\n  var char = pattern[current.index];\n  if (char === ARG_CLS) {\n    // end placeholder\n    if (current.tokens) current.tokens.push(['syntax', ARG_CLS]);\n    ++current.index; // move passed }\n    return [id];\n  }\n  if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS);\n  if (current.tokens) current.tokens.push(['syntax', ARG_SEP]);\n  ++current.index; // move passed ,\n  skipWhitespace(current);\n  var type = parseId(current);\n  if (!type) throw expected(current, 'placeholder type');\n  if (current.tokens) current.tokens.push(['type', type]);\n  skipWhitespace(current);\n  char = pattern[current.index];\n  if (char === ARG_CLS) {\n    // end placeholder\n    if (current.tokens) current.tokens.push(['syntax', ARG_CLS]);\n    if (type === 'plural' || type === 'selectordinal' || type === 'select') {\n      throw expected(current, type + ' sub-messages');\n    }\n    ++current.index; // move passed }\n    return [id, type];\n  }\n  if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS);\n  if (current.tokens) current.tokens.push(['syntax', ARG_SEP]);\n  ++current.index; // move passed ,\n  skipWhitespace(current);\n  var arg;\n  if (type === 'plural' || type === 'selectordinal') {\n    var offset = parsePluralOffset(current);\n    skipWhitespace(current);\n    arg = [id, type, offset, parseSubMessages(current, type)];\n  } else if (type === 'select') {\n    arg = [id, type, parseSubMessages(current, type)];\n  } else if (simpleTypes.indexOf(type) >= 0) {\n    arg = [id, type, parseSimpleFormat(current)];\n  } else {\n    // custom placeholder type\n    var index = current.index;\n    var format /*: string | SubMessages */ = parseSimpleFormat(current);\n    skipWhitespace(current);\n    if (pattern[current.index] === ARG_OPN) {\n      current.index = index; // rewind, since should have been submessages\n      format = parseSubMessages(current, type);\n    }\n    arg = [id, type, format];\n  }\n  skipWhitespace(current);\n  if (pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS);\n  if (current.tokens) current.tokens.push(['syntax', ARG_CLS]);\n  ++current.index; // move passed }\n  return arg;\n}\nfunction parseTag(current /*: Context */) /*: ?Placeholder */{\n  var tagsType = current.tagsType;\n  if (!tagsType || current.pattern[current.index] !== TAG_OPN) return;\n  if (current.pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) {\n    throw expected(current, null, 'closing tag without matching opening tag');\n  }\n  if (current.tokens) current.tokens.push(['syntax', TAG_OPN]);\n  ++current.index; // move passed <\n\n  var id = parseId(current, true);\n  if (!id) throw expected(current, 'placeholder id');\n  if (current.tokens) current.tokens.push(['id', id]);\n  skipWhitespace(current);\n  if (current.pattern.slice(current.index, current.index + TAG_SELF_CLS.length) === TAG_SELF_CLS) {\n    if (current.tokens) current.tokens.push(['syntax', TAG_SELF_CLS]);\n    current.index += TAG_SELF_CLS.length;\n    return [id, tagsType];\n  }\n  if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS);\n  if (current.tokens) current.tokens.push(['syntax', TAG_CLS]);\n  ++current.index; // move passed >\n\n  var children = parseAST(current, tagsType);\n  var end = current.index;\n  if (current.pattern.slice(current.index, current.index + TAG_END.length) !== TAG_END) throw expected(current, TAG_END + id + TAG_CLS);\n  if (current.tokens) current.tokens.push(['syntax', TAG_END]);\n  current.index += TAG_END.length;\n  var closeId = parseId(current, true);\n  if (closeId && current.tokens) current.tokens.push(['id', closeId]);\n  if (id !== closeId) {\n    current.index = end; // rewind for better error message\n    throw expected(current, TAG_END + id + TAG_CLS, TAG_END + closeId + TAG_CLS);\n  }\n  skipWhitespace(current);\n  if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS);\n  if (current.tokens) current.tokens.push(['syntax', TAG_CLS]);\n  ++current.index; // move passed >\n\n  return [id, tagsType, {\n    children: children\n  }];\n}\nfunction parseId(current /*: Context */, isTag /*:: ?: boolean */) /*: string */{\n  var pattern = current.pattern;\n  var length = pattern.length;\n  var id = '';\n  while (current.index < length) {\n    var char = pattern[current.index];\n    if (char === ARG_OPN || char === ARG_CLS || char === ARG_SEP || char === NUM_ARG || char === ESC || isWhitespace(char.charCodeAt(0)) || isTag && (char === TAG_OPN || char === TAG_CLS || char === '/')) break;\n    id += char;\n    ++current.index;\n  }\n  return id;\n}\nfunction parseSimpleFormat(current /*: Context */) /*: string */{\n  var start = current.index;\n  var style = parseText(current, '{style}');\n  if (!style) throw expected(current, 'placeholder style name');\n  if (current.tokens) current.tokens.push(['style', current.pattern.slice(start, current.index)]);\n  return style;\n}\nfunction parsePluralOffset(current /*: Context */) /*: number */{\n  var pattern = current.pattern;\n  var length = pattern.length;\n  var offset = 0;\n  if (pattern.slice(current.index, current.index + OFFSET.length) === OFFSET) {\n    if (current.tokens) current.tokens.push(['offset', 'offset'], ['syntax', ':']);\n    current.index += OFFSET.length; // move passed offset:\n    skipWhitespace(current);\n    var start = current.index;\n    while (current.index < length && isDigit(pattern.charCodeAt(current.index))) {\n      ++current.index;\n    }\n    if (start === current.index) throw expected(current, 'offset number');\n    if (current.tokens) current.tokens.push(['number', pattern.slice(start, current.index)]);\n    offset = +pattern.slice(start, current.index);\n  }\n  return offset;\n}\nfunction isDigit(code /*: number */) /*: boolean */{\n  return code >= 0x30 && code <= 0x39;\n}\nfunction parseSubMessages(current /*: Context */, parentType /*: string */) /*: SubMessages */{\n  var pattern = current.pattern;\n  var length = pattern.length;\n  var options /*: SubMessages */ = {};\n  while (current.index < length && pattern[current.index] !== ARG_CLS) {\n    var selector = parseId(current);\n    if (!selector) throw expected(current, 'sub-message selector');\n    if (current.tokens) current.tokens.push(['selector', selector]);\n    skipWhitespace(current);\n    options[selector] = parseSubMessage(current, parentType);\n    skipWhitespace(current);\n  }\n  if (!options.other && submTypes.indexOf(parentType) >= 0) {\n    throw expected(current, null, null, '\"other\" sub-message must be specified in ' + parentType);\n  }\n  return options;\n}\nfunction parseSubMessage(current /*: Context */, parentType /*: string */) /*: AST */{\n  if (current.pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN + ' to start sub-message');\n  if (current.tokens) current.tokens.push(['syntax', ARG_OPN]);\n  ++current.index; // move passed {\n  var message = parseAST(current, parentType);\n  if (current.pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS + ' to end sub-message');\n  if (current.tokens) current.tokens.push(['syntax', ARG_CLS]);\n  ++current.index; // move passed }\n  return message;\n}\nfunction expected(current /*: Context */, expected /*:: ?: ?string */, found /*:: ?: ?string */, message /*:: ?: string */) {\n  var pattern = current.pattern;\n  var lines = pattern.slice(0, current.index).split(/\\r?\\n/);\n  var offset = current.index;\n  var line = lines.length;\n  var column = lines.slice(-1)[0].length;\n  found = found || (current.index >= pattern.length ? 'end of message pattern' : parseId(current) || pattern[current.index]);\n  if (!message) message = errorMessage(expected, found);\n  message += ' in ' + pattern.replace(/\\r?\\n/g, '\\n');\n  return new SyntaxError(message, expected, found, offset, line, column);\n}\nfunction errorMessage(expected /*: ?string */, found /* string */) {\n  if (!expected) return 'Unexpected ' + found + ' found';\n  return 'Expected ' + expected + ' but found ' + found;\n}\n\n/**\n * SyntaxError\n *  Holds information about bad syntax found in a message pattern\n **/\nfunction SyntaxError(message /*: string */, expected /*: ?string */, found /*: ?string */, offset /*: number */, line /*: number */, column /*: number */) {\n  Error.call(this, message);\n  this.name = 'SyntaxError';\n  this.message = message;\n  this.expected = expected;\n  this.found = found;\n  this.offset = offset;\n  this.line = line;\n  this.column = column;\n}\nSyntaxError.prototype = Object.create(Error.prototype);\nexports.SyntaxError = SyntaxError;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// @flow\n\n\nvar formats = __webpack_require__(4);\nvar lookupClosestLocale = __webpack_require__(5);\nvar plurals = __webpack_require__(6);\n\n/*::\nimport type {\n  AST,\n  SubMessages\n} from '../format-message-parse'\ntype Locale = string\ntype Locales = Locale | Locale[]\ntype Placeholder = any[] // https://github.com/facebook/flow/issues/4050\nexport type Type = (Placeholder, Locales) => (any, ?Object) => any\nexport type Types = { [string]: Type }\n*/\n\nexports = module.exports = function interpret(ast /*: AST */, locale /*:: ?: Locales */, types /*:: ?: Types */) /*: (args?: Object) => string */{\n  return interpretAST(ast, null, locale || 'en', types || {}, true);\n};\nexports.toParts = function toParts(ast /*: AST */, locale /*:: ?: Locales */, types /*:: ?: Types */) /*: (args?: Object) => any[] */{\n  return interpretAST(ast, null, locale || 'en', types || {}, false);\n};\nfunction interpretAST(elements /*: any[] */, parent /*: ?Placeholder */, locale /*: Locales */, types /*: Types */, join /*: boolean */) /*: Function */{\n  var parts = elements.map(function (element) {\n    return interpretElement(element, parent, locale, types, join);\n  });\n  if (!join) {\n    return function format(args) {\n      return parts.reduce(function (parts, part) {\n        return parts.concat(part(args));\n      }, []);\n    };\n  }\n  if (parts.length === 1) return parts[0];\n  return function format(args) {\n    var message = '';\n    for (var e = 0; e < parts.length; ++e) {\n      message += parts[e](args);\n    }\n    return message;\n  };\n}\nfunction interpretElement(element /*: Placeholder */, parent /*: ?Placeholder */, locale /*: Locales */, types /*: Types */, join /*: boolean */) /*: Function */{\n  if (typeof element === 'string') {\n    var value /*: string */ = element;\n    return function format() {\n      return value;\n    };\n  }\n  var id = element[0];\n  var type = element[1];\n  if (parent && element[0] === '#') {\n    id = parent[0];\n    var offset = parent[2];\n    var formatter = (types.number || defaults.number)([id, 'number'], locale);\n    return function format(args) {\n      return formatter(getArg(id, args) - offset, args);\n    };\n  }\n\n  // pre-process children\n  var children;\n  if (type === 'plural' || type === 'selectordinal') {\n    children = {};\n    Object.keys(element[3]).forEach(function (key) {\n      children[key] = interpretAST(element[3][key], element, locale, types, join);\n    });\n    element = [element[0], element[1], element[2], children];\n  } else if (element[2] && typeof element[2] === 'object') {\n    children = {};\n    Object.keys(element[2]).forEach(function (key) {\n      children[key] = interpretAST(element[2][key], element, locale, types, join);\n    });\n    element = [element[0], element[1], children];\n  }\n  var getFrmt = type && (types[type] || defaults[type]);\n  if (getFrmt) {\n    var frmt = getFrmt(element, locale);\n    return function format(args) {\n      return frmt(getArg(id, args), args);\n    };\n  }\n  return join ? function format(args) {\n    return String(getArg(id, args));\n  } : function format(args) {\n    return getArg(id, args);\n  };\n}\nfunction getArg(id /*: string */, args /*: ?Object */) /*: any */{\n  if (args && id in args) return args[id];\n  var parts = id.split('.');\n  var a = args;\n  for (var i = 0, ii = parts.length; a && i < ii; ++i) {\n    a = a[parts[i]];\n  }\n  return a;\n}\nfunction interpretNumber(element /*: Placeholder */, locales /*: Locales */) {\n  var style = element[2];\n  var options = formats.number[style] || formats.parseNumberPattern(style) || formats.number.default;\n  return new Intl.NumberFormat(locales, options).format;\n}\nfunction interpretDuration(element /*: Placeholder */, locales /*: Locales */) {\n  var style = element[2];\n  var options = formats.duration[style] || formats.duration.default;\n  var fs = new Intl.NumberFormat(locales, options.seconds).format;\n  var fm = new Intl.NumberFormat(locales, options.minutes).format;\n  var fh = new Intl.NumberFormat(locales, options.hours).format;\n  var sep = /^fi$|^fi-|^da/.test(String(locales)) ? '.' : ':';\n  return function (s, args) {\n    s = +s;\n    if (!isFinite(s)) return fs(s);\n    var h = ~~(s / 60 / 60); // ~~ acts much like Math.trunc\n    var m = ~~(s / 60 % 60);\n    var dur = (h ? fh(Math.abs(h)) + sep : '') + fm(Math.abs(m)) + sep + fs(Math.abs(s % 60));\n    return s < 0 ? fh(-1).replace(fh(1), dur) : dur;\n  };\n}\nfunction interpretDateTime(element /*: Placeholder */, locales /*: Locales */) {\n  var type = element[1];\n  var style = element[2];\n  var options = formats[type][style] || formats.parseDatePattern(style) || formats[type].default;\n  return new Intl.DateTimeFormat(locales, options).format;\n}\nfunction interpretPlural(element /*: Placeholder */, locales /*: Locales */) {\n  var type = element[1];\n  var pluralType = type === 'selectordinal' ? 'ordinal' : 'cardinal';\n  var offset = element[2];\n  var children = element[3];\n  var pluralRules;\n  if (Intl.PluralRules && Intl.PluralRules.supportedLocalesOf(locales).length > 0) {\n    pluralRules = new Intl.PluralRules(locales, {\n      type: pluralType\n    });\n  } else {\n    var locale = lookupClosestLocale(locales, plurals);\n    var select = locale && plurals[locale][pluralType] || returnOther;\n    pluralRules = {\n      select: select\n    };\n  }\n  return function (value, args) {\n    var clause = children['=' + +value] || children[pluralRules.select(value - offset)] || children.other;\n    return clause(args);\n  };\n}\nfunction returnOther( /*:: n:number */) {\n  return 'other';\n}\nfunction interpretSelect(element /*: Placeholder */, locales /*: Locales */) {\n  var children = element[2];\n  return function (value, args) {\n    var clause = children[value] || children.other;\n    return clause(args);\n  };\n}\nvar defaults /*: Types */ = {\n  number: interpretNumber,\n  ordinal: interpretNumber,\n  // TODO: support rbnf\n  spellout: interpretNumber,\n  // TODO: support rbnf\n  duration: interpretDuration,\n  date: interpretDateTime,\n  time: interpretDateTime,\n  plural: interpretPlural,\n  selectordinal: interpretPlural,\n  select: interpretSelect\n};\nexports.types = defaults;\n\n/***/ })\n/******/ ]);","inputSourceMap":null}