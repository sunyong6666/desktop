{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{1454:function(e,t,r){(e.exports=r(10)(!1)).push([e.i,':root {\\n  --zebraStriping-percent: calc(var(--zebraStriping-shadeNumber) * var(--zebraStriping-intensity) / 100);\\n  --zebraStriping-bright: calc(1 + var(--zebraStriping-percent));\\n  --zebraStriping-saturate: calc(1 - var(--zebraStriping-percent));\\n  --zebraStriping-filter: brightness(var(--zebraStriping-bright)) saturate(var(--zebraStriping-saturate));\\n  /* \"Temporary\" value, gets replaced by userscript */\\n  --zebraStriping-replacementGlow: url(#blocklyReplacementGlowFilter);\\n}\\n\\n.sa-zebra-stripe {\\n  filter: var(--zebraStriping-filter);\\n}\\n\\n.sa-zebra-stripe[filter*=\"#blocklyReplacementGlowFilter\"] {\\n  filter: var(--zebraStriping-filter) var(--zebraStriping-replacementGlow);\\n}\\n\\n/* editor-stepping and debugger compatibility */\\n/* this is pretty horrible */\\n.sa-zebra-stripe[style*=\"#sa_glower_filter0\"] {\\n  /* !important because editor-stepping Highlighter uses inline styles */\\n  filter: var(--zebraStriping-filter) url(\"#sa_glower_filter0\") !important;\\n}\\n.sa-zebra-stripe[style*=\"#sa_glower_filter1\"] {\\n  filter: var(--zebraStriping-filter) url(\"#sa_glower_filter1\") !important;\\n}\\n',\"\"])},1540:function(e,t,r){\"use strict\";r.r(t),r.d(t,\"resources\",(function(){return n}));var i=r(1454);const n={\"userscript.js\":async function(e){let{addon:t,msg:r,console:i}=e;const n=t.tab.traps.vm,a=await t.tab.traps.getBlockly(),s=a.BlockSvg.prototype.render;for(a.BlockSvg.prototype.render=function(e){if(!this.isInFlyout&&!this.isShadow()&&null===this.getParent()){const e=new Map;for(const t of this.getDescendants()){const r=t.getSurroundParent();let i=!1;r&&(t.isShadow()?i=!!e.get(r):r.getColour()===t.getColour()&&(i=!e.get(r))),e.set(t,i);const n=[t.svgPath_];for(const e of t.inputList){e.outlinePath&&n.push(e.outlinePath);for(const t of e.fieldRow)t.fieldGroup_&&n.push(t.fieldGroup_)}for(const e of n)e.classList.toggle(\"sa-zebra-stripe\",i)}}return s.call(this,e)},n.editingTarget&&n.emitWorkspaceUpdate();;){const e=await t.tab.waitForElement('filter[id*=\"blocklyReplacementGlowFilter\"]',{markAsSeen:!0,reduxEvents:[\"scratch-gui/mode/SET_PLAYER\",\"fontsLoaded/SET_FONTS_LOADED\",\"scratch-gui/locales/SELECT_LOCALE\",\"scratch-gui/theme/SET_THEME\"],reduxCondition:e=>!e.scratchGui.mode.isPlayerOnly});document.documentElement.style.setProperty(\"--zebraStriping-replacementGlow\",\"url(#\".concat(e.id,\")\"))}},\"userstyle.css\":r.n(i).a}}}]);","name":"52.index.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[52],{\n\n/***/ 1454:\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(10)(false);\n// imports\n\n\n// module\nexports.push([module.i, \":root {\\n  --zebraStriping-percent: calc(var(--zebraStriping-shadeNumber) * var(--zebraStriping-intensity) / 100);\\n  --zebraStriping-bright: calc(1 + var(--zebraStriping-percent));\\n  --zebraStriping-saturate: calc(1 - var(--zebraStriping-percent));\\n  --zebraStriping-filter: brightness(var(--zebraStriping-bright)) saturate(var(--zebraStriping-saturate));\\n  /* \\\"Temporary\\\" value, gets replaced by userscript */\\n  --zebraStriping-replacementGlow: url(#blocklyReplacementGlowFilter);\\n}\\n\\n.sa-zebra-stripe {\\n  filter: var(--zebraStriping-filter);\\n}\\n\\n.sa-zebra-stripe[filter*=\\\"#blocklyReplacementGlowFilter\\\"] {\\n  filter: var(--zebraStriping-filter) var(--zebraStriping-replacementGlow);\\n}\\n\\n/* editor-stepping and debugger compatibility */\\n/* this is pretty horrible */\\n.sa-zebra-stripe[style*=\\\"#sa_glower_filter0\\\"] {\\n  /* !important because editor-stepping Highlighter uses inline styles */\\n  filter: var(--zebraStriping-filter) url(\\\"#sa_glower_filter0\\\") !important;\\n}\\n.sa-zebra-stripe[style*=\\\"#sa_glower_filter1\\\"] {\\n  filter: var(--zebraStriping-filter) url(\\\"#sa_glower_filter1\\\") !important;\\n}\\n\", \"\"]);\n\n// exports\n\n\n/***/ }),\n\n/***/ 1540:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"resources\", function() { return /* binding */ resources; });\n\n// CONCATENATED MODULE: ./node_modules/scratch-gui/src/addons/addons/zebra-striping/userscript.js\n/* harmony default export */ var userscript = (async function (_ref) {\n  let {\n    addon,\n    msg,\n    console\n  } = _ref;\n  const vm = addon.tab.traps.vm;\n  const ScratchBlocks = await addon.tab.traps.getBlockly();\n  const originalRender = ScratchBlocks.BlockSvg.prototype.render;\n  ScratchBlocks.BlockSvg.prototype.render = function (opt_bubble) {\n    // Any changes that affect block striping should bubble to the top block of the script.\n    // The top block of the script is responsible for striping all of its children.\n    // This way stripes are computed exactly once.\n    if (!this.isInFlyout && !this.isShadow() && this.getParent() === null) {\n      const stripeState = new Map();\n      // Conveniently getDescendants() returns blocks in an order such that each block's\n      // parent will always come before that block (except the first block which has no\n      // parent).\n      for (const block of this.getDescendants()) {\n        const parent = block.getSurroundParent();\n        let isStriped = false;\n        if (parent) {\n          if (block.isShadow()) {\n            isStriped = !!stripeState.get(parent);\n          } else if (parent.getColour() === block.getColour()) {\n            isStriped = !stripeState.get(parent);\n          }\n        }\n        stripeState.set(block, isStriped);\n        const elements = [block.svgPath_];\n        for (const input of block.inputList) {\n          if (input.outlinePath) {\n            elements.push(input.outlinePath);\n          }\n          for (const field of input.fieldRow) {\n            if (field.fieldGroup_) {\n              elements.push(field.fieldGroup_);\n            }\n          }\n        }\n        for (const el of elements) {\n          el.classList.toggle(\"sa-zebra-stripe\", isStriped);\n        }\n      }\n    }\n    return originalRender.call(this, opt_bubble);\n  };\n  if (vm.editingTarget) {\n    vm.emitWorkspaceUpdate();\n  }\n\n  // The replacement glow filter's ID is randomly generated and changes\n  // when the workspace is reloaded (which includes loading the page and\n  // seeing the project page then seeing inside).\n  // As we need to stack the filter with the striping filter in the\n  // userstyle, we need to use the userscript to get the filter's ID\n  // and set a CSS variable on the document's root.\n  while (true) {\n    const replacementGlowEl = await addon.tab.waitForElement('filter[id*=\"blocklyReplacementGlowFilter\"]', {\n      markAsSeen: true,\n      reduxEvents: [\"scratch-gui/mode/SET_PLAYER\", \"fontsLoaded/SET_FONTS_LOADED\", \"scratch-gui/locales/SELECT_LOCALE\", \"scratch-gui/theme/SET_THEME\"],\n      reduxCondition: state => !state.scratchGui.mode.isPlayerOnly\n    });\n    document.documentElement.style.setProperty(\"--zebraStriping-replacementGlow\", \"url(#\".concat(replacementGlowEl.id, \")\"));\n  }\n});\n// EXTERNAL MODULE: ./node_modules/css-loader!./node_modules/scratch-gui/src/addons/addons/zebra-striping/userstyle.css\nvar userstyle = __webpack_require__(1454);\nvar userstyle_default = /*#__PURE__*/__webpack_require__.n(userstyle);\n\n// CONCATENATED MODULE: ./node_modules/scratch-gui/src/addons/addons/zebra-striping/_runtime_entry.js\n/* generated by pull.js */\n\n\nconst resources = {\n  \"userscript.js\": userscript,\n  \"userstyle.css\": userstyle_default.a\n};\n\n/***/ })\n\n}]);","inputSourceMap":null}