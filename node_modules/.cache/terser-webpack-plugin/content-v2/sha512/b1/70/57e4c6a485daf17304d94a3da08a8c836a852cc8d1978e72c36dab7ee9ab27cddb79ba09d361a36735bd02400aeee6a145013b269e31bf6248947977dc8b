{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{1399:function(t,e,n){\"use strict\";n.d(e,\"a\",(function(){return i})),n.d(e,\"b\",(function(){return a}));let o=!1;const i={paintSkew:null,paintSnap:null};function a(t,e){if(o)return;o=!0;const n=e.prototype.onMouseDrag;e.prototype.onMouseDrag=function(t){if(!this.active)return;const e=()=>{i.paintSnap?i.paintSnap.call(this,t):n.call(this,t)};i.paintSkew?i.paintSkew.call(this,t,e):e()}}},1476:function(t,e,n){(t.exports=n(10)(!1)).push([t.i,'.sa-paint-snap-button {\\n  position: relative;\\n}\\n.sa-paint-snap-button:focus-within {\\n  background-color: var(--editorDarkMode-primary-transparent35, hsla(260, 60%, 60%, 0.35));\\n}\\n.sa-paint-snap-button[data-enabled=\"true\"] .sa-paint-snap-image {\\n  filter: brightness(0) invert(1);\\n}\\n.sa-paint-snap-button[data-enabled=\"true\"] {\\n  background-color: var(--looks-secondary);\\n}\\n\\n.sa-paint-snap-group {\\n  position: relative;\\n  flex-direction: row;\\n}\\n\\n.sa-paint-snap-settings-wrapper {\\n  position: absolute;\\n  justify-items: center;\\n  left: 50%;\\n  width: 1.95rem;\\n  height: 1.95rem;\\n  display: grid;\\n}\\n\\n.sa-paint-snap-settings {\\n  position: absolute;\\n  bottom: 100%;\\n  /* based on the styles for the color dropdown */\\n  padding: 4px;\\n  border-radius: 4px;\\n  border: 1px solid var(--ui-black-transparent);\\n  box-shadow: 0px 0px 8px 1px rgba(0, 0, 0, 0.3);\\n  transition-property: bottom, opacity;\\n  transition-duration: 500ms;\\n  transition-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\\n  opacity: 0;\\n  pointer-events: none;\\n  background: var(--ui-modal-background);\\n  color: var(--ui-text-primary);\\n  min-height: 100%;\\n  min-width: 100%;\\n  display: flex;\\n  flex-direction: column;\\n  gap: 0.25em;\\n}\\n.sa-paint-snap-settings[data-visible=\"true\"] {\\n  bottom: calc(100% + 22px);\\n  pointer-events: auto;\\n  opacity: 1;\\n  z-index: 200;\\n}\\n\\n.sa-paint-snap-settings-line {\\n  display: flex;\\n  justify-content: flex-end;\\n  align-items: baseline;\\n}\\n\\n.sa-paint-snap-settings-input {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  box-sizing: border-box;\\n  text-align: center;\\n  border: 0;\\n  background: transparent;\\n  -moz-appearance: textfield;\\n  border: 0;\\n  outline: 0;\\n}\\n\\n.sa-paint-snap-settings-input::-webkit-outer-spin-button,\\n.sa-paint-snap-settings-input::-webkit-inner-spin-button {\\n  -webkit-appearance: none;\\n  margin: 0;\\n}\\n\\n.sa-paint-snap-settings-tip {\\n  position: absolute;\\n  bottom: 0;\\n  transform: translateY(100%);\\n  right: calc(50% - 7px);\\n}\\n.sa-paint-snap-settings-polygon {\\n  fill: var(--ui-modal-background);\\n  stroke: var(--ui-black-transparent);\\n}\\n\\n.sa-paint-snap-settings-separator {\\n  flex-grow: 1;\\n  border-bottom: 1px solid currentColor;\\n  margin: 4px;\\n  opacity: 0.25;\\n}\\n\\n.sa-paint-snap-settings-section {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 0.25em;\\n  align-items: flex-end;\\n  width: 100%;\\n}\\n\\n.sa-paint-snap-settings-section-title {\\n  font-size: 1.2em;\\n  font-weight: 500;\\n  align-self: flex-start;\\n  margin-left: 4px;\\n}\\n\\n.sa-paint-snap-settings-label {\\n  white-space: nowrap;\\n}\\n\\n.sa-paint-snap-image[data-shrink=\"true\"] {\\n  height: 1em;\\n  width: 1em;\\n}\\n',\"\"])},1529:function(t,e,n){\"use strict\";n.r(e),n.d(e,\"resources\",(function(){return A}));let o=!0;const i={pageEdges:!0,pageCenter:!0,pageAxes:!0,pageCorners:!1,objectEdges:!0,objectCenters:!0,objectMidlines:!0,objectCorners:!1},a={boxCenter:!0,boxCorners:!1,boxEdgeMids:!1};let r,s=10;function l(t,e){i[t]=!!e}function c(t,e){a[t]=!!e}function d(t){s=t}function p(){o=!0}function u(){o=!1}function m(t){t?p():u()}function g(t){r=t}function b(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function h(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?b(Object(n),!0).forEach((function(e){v(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):b(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function v(t,e,n){return(e=function(t){var e=function(t,e){if(\"object\"!=typeof t||!t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var o=n.call(t,e||\"default\");if(\"object\"!=typeof o)return o;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return(\"string\"===e?String:Number)(t)}(t,\"string\");return\"symbol\"==typeof e?e:e+\"\"}(e))in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function y(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function f(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?y(Object(n),!0).forEach((function(e){w(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):y(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function w(t,e,n){return(e=function(t){var e=function(t,e){if(\"object\"!=typeof t||!t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var o=n.call(t,e||\"default\");if(\"object\"!=typeof o)return o;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return(\"string\"===e?String:Number)(t)}(t,\"string\");return\"symbol\"==typeof e?e:e+\"\"}(e))in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function M(t,e){const n=function(e){for(const n of t.project.layers)if(n.data&&n.data[e])return n};let o,i,a,r,s,l,c;const d=()=>{o=e.runtime.stageWidth,i=e.runtime.stageHeight,a=2*o,r=2*i,s=new t.Point(a/2,r/2),l=new t.Rectangle(0,0,a,r),c=new t.Rectangle(-a/4,-r/4,1.5*a,1.5*r)};e.on(\"STAGE_SIZE_CHANGED\",d),d();return{math:{checkPointsClose:function(t,e,n){const o=Math.abs(t.x-e.x),i=Math.abs(t.y-e.y);return o<n&&i<n},snapDeltaToAngle:function(e,n){let o=Math.atan2(e.y,e.x);o=Math.round(o/n)*n;const i=Math.cos(o),a=Math.sin(o),r=i*e.x+a*e.y;return new t.Point(i*r,a*r)}},layer:{CROSSHAIR_FULL_OPACITY:.75,getDragCrosshairLayer:function(){return n(\"isDragCrosshairLayer\")},getLayer:n},view:{get CENTER(){return s},get ART_BOARD_BOUNDS(){return l},get MAX_WORKSPACE_BOUNDS(){return c},getActionBounds:e=>e?l:t.view.bounds.unite(l)},guide:{hoverBounds:function(e,o){let i=e.internalBounds;o&&(i=i.expand(o));const a=new t.Path.Rectangle(i);return a.matrix=e.matrix,function(e){e.strokeWidth=1/t.view.zoom,e.opacity=1,e.blendMode=\"normal\",e.guide=!0}(a),a.parent=n(\"isGuideLayer\"),a.strokeColor=\"#009dec\",a.fillColor=null,a.data.isHelperItem=!0,a.data.origItem=e,a.bringToFront(),a}}}}const I=t=>Object.fromEntries(Object.entries(t).map((t=>{let[e]=t;return[e,e]}))),x={BRUSH:null,ERASER:null,LINE:null,FILL:null,SELECT:null,RESHAPE:null,OVAL:null,RECT:null,ROUNDED_RECT:null,TEXT:null},j={BIT_BRUSH:null,BIT_LINE:null,BIT_OVAL:null,BIT_RECT:null,BIT_TEXT:null,BIT_FILL:null,BIT_ERASER:null,BIT_SELECT:null},S=(I(x),I(j)),N=I(f(f({},x),j)),L=(I({FILL:null,SELECT:null,RESHAPE:null,OVAL:null,RECT:null,LINE:null,BIT_OVAL:null,BIT_RECT:null,BIT_SELECT:null,BIT_FILL:null}),(t,e,n)=>{const l=M(t,n),{math:{checkPointsClose:c,snapDeltaToAngle:d},view:{getActionBounds:p,CENTER:u},layer:{getDragCrosshairLayer:m,CROSSHAIR_FULL_OPACITY:g,getLayer:b},guide:{hoverBounds:v}}=l,y=(t=>t.boundingBoxTool._modeMap.MOVE)(e);let f=new t.Path.Line({from:[0,0],to:[0,0],strokeColor:new t.Color(r),strokeWidth:1/t.view.zoom,visible:!1,data:{isHelperItem:!0,noSelect:!0,noHover:!0,saPaintSnapGuide:!0},selected:!1});const w={shadow:null,circle:null},I=new t.Group({children:[],visible:!1});let x;f.remove(),I.remove();let j;function L(e){var n,o;const y=e.point,M=p(this.mode in S);y.x=Math.max(M.left,Math.min(y.x,M.right)),y.y=Math.max(M.top,Math.min(y.y,M.bottom));const L=y.subtract(e.downPoint),C=s/t.view.zoom;let P;if(0===this.selectedItems.length)return;const T=this.selectionCenter._owner,z=this.selectionCenter.add(L),D=null!==(n=null===(o=b(\"isGuideLayer\").children.find((t=>t.data.isSelectionBound)))||void 0===o?void 0:o.selectionAnchor)&&void 0!==n?n:{},O=()=>{D.strokeColor=new t.Color(.30196078431372547,.592156862745098,1),D.fillColor=null};if(j=()=>{var t;f.remove(),I.remove(),I.visible=!1,f.visible=!1,null===(t=x)||void 0===t||t.remove(),x&&(x.visible=!1),O()},j(),!e.modifiers.shift&&this.mode!==N.RESHAPE){const e=b(\"isPaintingLayer\"),n=function(t,e,n,o){const{view:{CENTER:r,ART_BOARD_BOUNDS:s}}=n;return{from:h(h(h({},a.boxCenter?{center:e.center}:{}),a.boxCorners?{topLeft:e.topLeft,topRight:e.topRight,bottomLeft:e.bottomLeft,bottomRight:e.bottomRight}:{}),a.boxEdgeMids?{left:new t.Point(e.left,e.center.y),right:new t.Point(e.right,e.center.y),top:new t.Point(e.center.x,e.top),bottom:new t.Point(e.center.x,e.bottom)}:{}),to:h(h(h(h(h(h(h(h({},i.pageCenter?{bounds_c:{type:\"point\",value:r}}:{}),i.pageAxes?{bounds_cx:{type:\"xcoord\",value:r.x},bounds_cy:{type:\"ycoord\",value:r.y}}:{}),i.pageEdges?{bounds_l:{type:\"xcoord\",value:s.left,clamp:{min:s.top,max:s.bottom}},bounds_r:{type:\"xcoord\",value:s.right,clamp:{min:s.top,max:s.bottom}},bounds_t:{type:\"ycoord\",value:s.top,clamp:{min:s.left,max:s.right}},bounds_b:{type:\"ycoord\",value:s.bottom,clamp:{min:s.left,max:s.right}},bounds_lc:{type:\"point\",value:new t.Point(s.left,r.y)},bounds_rc:{type:\"point\",value:new t.Point(s.right,r.y)},bounds_tc:{type:\"point\",value:new t.Point(r.x,s.top)},bounds_bc:{type:\"point\",value:new t.Point(r.x,s.bottom)}}:{}),i.pageCorners?{bounds_tl:{type:\"point\",value:s.topLeft},bounds_tr:{type:\"point\",value:s.topRight},bounds_bl:{type:\"point\",value:s.bottomLeft},bounds_br:{type:\"point\",value:s.bottomRight}}:{}),i.objectEdges?Object.fromEntries(o.filter((t=>!(t.selected||t.data.isHelperItem||t.locked||t.guide))).map((t=>[[\"item_\".concat(t.id,\"_r\"),{type:\"itemSideVert\",value:t.bounds.right,clamp:{min:t.bounds.top,max:t.bounds.bottom}}],[\"item_\".concat(t.id,\"_l\"),{type:\"itemSideVert\",value:t.bounds.left,clamp:{min:t.bounds.top,max:t.bounds.bottom}}],[\"item_\".concat(t.id,\"_t\"),{type:\"itemSideHoriz\",value:t.bounds.top,clamp:{min:t.bounds.left,max:t.bounds.right}}],[\"item_\".concat(t.id,\"_b\"),{type:\"itemSideHoriz\",value:t.bounds.bottom,clamp:{min:t.bounds.left,max:t.bounds.right}}]])).flat(1)):{}),i.objectCenters?Object.fromEntries(o.filter((t=>!(t.selected||t.data.isHelperItem||t.locked||t.guide))).map((t=>[[\"item_\".concat(t.id,\"_c\"),{type:\"point\",value:t.bounds.center}]])).flat(1)):{}),i.objectMidlines?Object.fromEntries(o.filter((t=>!(t.selected||t.data.isHelperItem||t.locked||t.guide))).map((t=>[[\"item_\".concat(t.id,\"_cx\"),{type:\"xcoord\",value:t.bounds.center.x}],[\"item_\".concat(t.id,\"_cy\"),{type:\"ycoord\",value:t.bounds.center.y}]])).flat(1)):{}),i.objectCorners?Object.fromEntries(o.filter((t=>!(t.selected||t.data.isHelperItem||t.locked||t.guide))).map((t=>[[\"item_\".concat(t.id,\"_tl\"),{type:\"point\",value:t.bounds.topLeft}],[\"item_\".concat(t.id,\"_tr\"),{type:\"point\",value:t.bounds.topRight}],[\"item_\".concat(t.id,\"_bl\"),{type:\"point\",value:t.bounds.bottomLeft}],[\"item_\".concat(t.id,\"_br\"),{type:\"point\",value:t.bounds.bottomRight}]])).flat(1)):{})}}(t,T,l,e.children),o=n.from,s=n.to,d=e=>(e.clamp||(e.clamp={min:-1/0,max:1/0}),\"point\"===e.type?()=>e.value:\"xcoord\"===e.type||\"itemSideVert\"===e.type?n=>new t.Point(e.value,Math.min(Math.max(n.y,e.clamp.min),e.clamp.max)):\"ycoord\"===e.type||\"itemSideHoriz\"===e.type?n=>new t.Point(Math.min(Math.max(n.x,e.clamp.min),e.clamp.max),e.value):\"generator\"===e.type?e.value:void 0),p=t=>Object.fromEntries(Object.entries(s).map((e=>{let[n,o]=e;return[n,{type:o.type,point:d(o)(t)}]}))),u=Object.entries(o).map((t=>{let[e,n]=t;return{pointPos:e,origPoint:n,point:n.add(L),snapPoints:p(n.add(L))}})),m=[\"point\",\"itemSideVert\",\"itemSideHoriz\",\"xcoord\",\"ycoord\",\"generated\",void 0],g=(t,e)=>{const n=m.indexOf(t.snapPointType)-m.indexOf(e.snapPointType);return n||t.distance-e.distance},y=u.map((t=>{var e,n;let{point:o,origPoint:i,snapPoints:a}=t;const r=Object.entries(a).filter((t=>{let[e,n]=t;return c(o,n.point,C)})).map((t=>{let[e,n]=t;return{pos:e,distance:(i=n.point,a=o,i.getDistance(a)),snapPointType:n.type};var i,a})).sort(g)[0]||{pos:\"\",distance:1/0};return{point:i,snapPoint:null===(e=a[r.pos])||void 0===e?void 0:e.point,snapPointType:null===(n=a[r.pos])||void 0===n?void 0:n.type,distance:r.distance,pos:r.pos}})).sort(g),S=y.sort(g)[0];if(j(),null!=S&&S.snapPoint){var E;w.shadow=new t.Path.Circle({center:new t.Point(0,0),radius:5.5/t.view.zoom,fillColor:\"black\",opacity:.12,data:{isHelperItem:!0,noSelect:!0,noHover:!0,saPaintSnapGuide:!0},visible:!0,guide:!0}),w.circle=new t.Path.Circle({center:new t.Point(0,0),radius:4/t.view.zoom,fillColor:new t.Color(r),data:{isScaleHandle:!1,isHelperItem:!0,noSelect:!0,noHover:!0,saPaintSnapGuide:!0},visible:!0,guide:!0}),I.removeChildren(),I.addChildren([w.shadow,w.circle]),f.strokeWidth=1/t.view.zoom,f.strokeColor=new t.Color(r),f.bringToFront(),I.bringToFront(),b(\"isGuideLayer\").addChildren([f,I]),P=S.snapPoint.subtract(S.point);const e=null===(E=S.pos.match(/item_(\\d+)_/))||void 0===E?void 0:E[1];if(e){const n=t.project.getItem({id:parseInt(e,10)});n&&(x=v(n))}if(S.point.equals(this.selectionCenter)&&\"point\"===S.snapPointType)D.fillColor=D.strokeColor=new t.Color(r);else switch(O(),S.snapPointType){case\"point\":I.visible=!0,I.position=S.snapPoint,I.bringToFront();break;case\"xcoord\":case\"itemSideVert\":f.firstSegment.point=new t.Point(S.snapPoint.x,M.top),f.lastSegment.point=new t.Point(S.snapPoint.x,M.bottom),f.visible=!0,f.bringToFront();break;case\"ycoord\":case\"itemSideHoriz\":f.firstSegment.point=new t.Point(M.left,S.snapPoint.y),f.lastSegment.point=new t.Point(M.right,S.snapPoint.y),f.visible=!0,f.bringToFront()}}}let A;for(const t of this.selectedItems)t.data.origPos||(t.data.origPos=t.position),P?t.position=t.data.origPos.add(P):e.modifiers.shift?t.position=t.data.origPos.add(d(L,Math.PI/4)):t.position=t.data.origPos.add(L),A=A?A.unite(t.bounds):t.bounds;this.firstDrag&&(m().visible=!0,this.firstDrag=!1);let k=1;if(u.y<A.top&&u.x<A.left||u.y>A.bottom&&u.x<A.left||u.y<A.top&&u.x>A.right||u.y>A.bottom&&u.x>A.right){const e=Math.max(u.x-A.right,A.left-u.x),n=Math.max(u.y-A.bottom,A.top-u.y),o=Math.sqrt(e*e+n*n);k=Math.max(0,1-o/(10/t.view.zoom))}else u.y<A.top||u.y>A.bottom?k=Math.max(0,1-(Math.abs(u.y-z.y)-A.height/2)/(10/t.view.zoom)):(u.x<A.left||u.x>A.right)&&(k=Math.max(0,1-(Math.abs(u.x-z.x)-A.width/2)/(10/t.view.zoom)));m().opacity=g*k}const C=y.constructor.prototype.onMouseDrag;y.constructor.prototype.onMouseDrag=L;const P=y.constructor.prototype.onMouseDown;y.constructor.prototype.onMouseDown=function(){y.constructor.prototype.onMouseDrag=o?L:C;for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];P.apply(this,e)};const T=y.constructor.prototype.onMouseUp;y.constructor.prototype.onMouseUp=function(){var t;null===(t=j)||void 0===t||t();for(var e=arguments.length,n=new Array(e),o=0;o<e;o++)n[o]=arguments[o];T.apply(this,n)}});function C(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function P(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?C(Object(n),!0).forEach((function(e){T(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):C(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function T(t,e,n){return(e=function(t){var e=function(t,e){if(\"object\"!=typeof t||!t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var o=n.call(t,e||\"default\");if(\"object\"!=typeof o)return o;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return(\"string\"===e?String:Number)(t)}(t,\"string\");return\"symbol\"==typeof e?e:e+\"\"}(e))in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function z(t,e,n,o,a){const{view:{CENTER:r,ART_BOARD_BOUNDS:s}}=e;return P(P(P(P({},i.pageAxes?P(P({},o?{bounds_cx:{type:\"xcoord\",value:r.x}}:{}),a?{bounds_cy:{type:\"ycoord\",value:r.y}}:{}):{}),i.pageEdges?P(P(P(P({},o?{bounds_l:{type:\"xcoord\",value:s.left,clamp:{min:s.top,max:s.bottom}},bounds_r:{type:\"xcoord\",value:s.right,clamp:{min:s.top,max:s.bottom}}}:{}),a?{bounds_t:{type:\"ycoord\",value:s.top,clamp:{min:s.left,max:s.right}},bounds_b:{type:\"ycoord\",value:s.bottom,clamp:{min:s.left,max:s.right}}}:{}),o?{bounds_w:{type:\"width\",value:r.y,clamp:{min:s.left,max:s.right}}}:{}),a?{bounds_h:{type:\"height\",value:r.x,clamp:{min:s.bottom,max:s.top}}}:{}):{}),i.objectEdges?Object.fromEntries(n.filter((t=>!(t.selected||t.data.isHelperItem||t.locked||t.guide))).map((t=>[o&&[\"item_\".concat(t.id,\"_r\"),{type:\"xcoord\",value:t.bounds.right}],o&&[\"item_\".concat(t.id,\"_l\"),{type:\"xcoord\",value:t.bounds.left}],a&&[\"item_\".concat(t.id,\"_t\"),{type:\"ycoord\",value:t.bounds.top}],a&&[\"item_\".concat(t.id,\"_b\"),{type:\"ycoord\",value:t.bounds.bottom}],o&&[\"item_\".concat(t.id,\"_w\"),{type:\"width\",value:t.bounds.bottom,clamp:{min:t.bounds.left,max:t.bounds.right}}],a&&[\"item_\".concat(t.id,\"_h\"),{type:\"height\",value:t.bounds.left,clamp:{min:t.bounds.bottom,max:t.bounds.top}}]].filter(Boolean))).flat(1)):{}),i.objectMidlines?Object.fromEntries(n.filter((t=>!(t.selected||t.data.isHelperItem||t.locked||t.guide))).map((t=>[o&&[\"item_\".concat(t.id,\"_cx\"),{type:\"xcoord\",value:t.bounds.center.x}],a&&[\"item_\".concat(t.id,\"_cy\"),{type:\"ycoord\",value:t.bounds.center.y}]].filter(Boolean))).flat(1)):{})}var D=n(1399);const O=(t,e,n)=>{const i=M(t,n),{view:{getActionBounds:a},layer:{getLayer:l}}=i,c=(t=>t.boundingBoxTool._modeMap.SCALE)(e),d=1e-4,p={endLeft:new t.Path.Line({from:[0,0],to:[0,0],strokeColor:new t.Color(r),strokeWidth:1/t.view.zoom,visible:!0,data:{isHelperItem:!0,noSelect:!0,noHover:!0,saPaintSnapGuide:!0},selected:!1}),endRight:new t.Path.Line({from:[0,0],to:[0,0],strokeColor:new t.Color(r),strokeWidth:1/t.view.zoom,visible:!0,data:{isHelperItem:!0,noSelect:!0,noHover:!0,saPaintSnapGuide:!0},selected:!1}),line:new t.Path.Line({from:[0,0],to:[0,0],strokeColor:new t.Color(r),strokeWidth:1/t.view.zoom,visible:!0,data:{isHelperItem:!0,noSelect:!0,noHover:!0,saPaintSnapGuide:!0},selected:!1}),group:new t.Group({children:[],visible:!1})},u={endLeft:new t.Path.Line({from:[0,0],to:[0,0],strokeColor:new t.Color(r),strokeWidth:1/t.view.zoom,visible:!0,data:{isHelperItem:!0,noSelect:!0,noHover:!0,saPaintSnapGuide:!0},selected:!1}),endRight:new t.Path.Line({from:[0,0],to:[0,0],strokeColor:new t.Color(r),strokeWidth:1/t.view.zoom,visible:!0,data:{isHelperItem:!0,noSelect:!0,noHover:!0,saPaintSnapGuide:!0},selected:!1}),line:new t.Path.Line({from:[0,0],to:[0,0],strokeColor:new t.Color(r),strokeWidth:1/t.view.zoom,visible:!0,data:{isHelperItem:!0,noSelect:!0,noHover:!0,saPaintSnapGuide:!0},selected:!1}),group:new t.Group({children:[],visible:!1})};p.endLeft.remove(),u.endLeft.remove(),p.endRight.remove(),u.endRight.remove(),p.line.remove(),u.line.remove(),p.group.remove(),u.group.remove(),p.group.addChildren([p.endLeft,p.line,p.endRight]),u.group.addChildren([u.endLeft,u.line,u.endRight]);let m=new t.Path.Line({from:[0,0],to:[0,0],strokeColor:new t.Color(r),strokeWidth:1/t.view.zoom,visible:!1,data:{isHelperItem:!0,noSelect:!0,noHover:!0,saPaintSnapGuide:!0,axis:\"x\"},selected:!1}),g=new t.Path.Line({from:[0,0],to:[0,0],strokeColor:new t.Color(r),strokeWidth:1/t.view.zoom,visible:!1,data:{isHelperItem:!0,noSelect:!0,noHover:!0,saPaintSnapGuide:!0,axis:\"y\"},selected:!1});m.remove(),g.remove();const b=[\"width\",\"height\",\"itemSideVert\",\"itemSideHoriz\",\"xcoord\",\"ycoord\",\"generated\",void 0],h=()=>{p.group.remove(),p.group.visible=!1,u.group.remove(),u.group.visible=!1,m.remove(),m.visible=!1,g.remove(),g.visible=!1};D.a.paintSnap=function(e){if(!this.active)return;const n=e.point,c=a(this.isBitmap);n.x=Math.max(c.left,Math.min(n.x,c.right)),n.y=Math.max(c.top,Math.min(n.y,c.bottom)),this.lastPoint||(this.lastPoint=e.lastPoint);const v=n.subtract(this.lastPoint);this.lastPoint=n,e.modifiers.alt?(this.centered=!0,this.itemGroup.position=this.origCenter,this.pivot=this.origCenter):(this.centered&&(this.centered=!1,this.itemGroup.scale(1/this.lastSx,1/this.lastSy,this.pivot),this.selectionAnchor&&this.selectionAnchor.scale(this.lastSx,this.lastSy),this.lastSx=1,this.lastSy=1),this.pivot=this.origPivot),this.corner=this.corner.add(v);let y=this.corner.subtract(this.pivot);e.modifiers.alt&&(y=y.multiply(2));let f=1,w=1;Math.abs(this.origSize.x)>1e-7&&(f=y.x/this.origSize.x),Math.abs(this.origSize.y)>1e-7&&(w=y.y/this.origSize.y);const M=(t,e)=>{const n=b.indexOf(t.type)-b.indexOf(e.type);return n||t.distance-e.distance},I=l(\"isPaintingLayer\"),x=o&&(this.isCorner&&!e.modifiers.shift||Math.abs(this.origSize.x)>1e-7),j=o&&(this.isCorner&&!e.modifiers.shift||Math.abs(this.origSize.y)>1e-7),S=s/t.view.zoom,N=t=>t.distance<S,L=t=>{let[e,n]=t;return{type:n.type,distance:(()=>{switch(n.type){case\"width\":return Math.abs(Math.abs(y.x)-Math.abs(n.clamp.max-n.clamp.min));case\"height\":return Math.abs(Math.abs(y.y)-Math.abs(n.clamp.max-n.clamp.min));case\"xcoord\":case\"itemSideVert\":return Math.abs(this.corner.x-n.value);case\"ycoord\":case\"itemSideHoriz\":return Math.abs(this.corner.y-n.value)}})(),name:e,coord:n}},C=z(0,i,I.children,x,!1),P=Object.entries(C).map(L).filter(N).sort(M),T=z(0,i,I.children,!1,j),D=Object.entries(T).map(L).filter(N).sort(M),O=P[0],E=D[0],A=f>0?1:-1,k=w>0?1:-1;if(O)switch(O.type){case\"width\":f=new t.Point(Math.abs(O.coord.clamp.max-O.coord.clamp.min),this.corner.y).x/this.origSize.x;break;case\"xcoord\":case\"itemSideVert\":f=new t.Point(O.coord.value,this.corner.y).subtract(this.pivot).x/this.origSize.x,e.modifiers.alt&&(f*=2);break}if(E)switch(E.type){case\"height\":w=new t.Point(this.corner.x,Math.abs(E.coord.clamp.max-E.coord.clamp.min)).y/this.origSize.y;break;case\"ycoord\":case\"itemSideHoriz\":w=new t.Point(this.corner.x,E.coord.value).subtract(this.pivot).y/this.origSize.y,e.modifiers.alt&&(w*=2);break}const _=f,H=w;if(this.isCorner&&!e.modifiers.shift&&(f=w=Math.max(Math.abs(f),Math.abs(w)),f*=A,w*=k),f=A*Math.max(Math.abs(f),d),w=k*Math.max(Math.abs(w),d),this.itemGroup.scale(f/this.lastSx,w/this.lastSy,this.pivot),this.selectionAnchor&&this.selectionAnchor.scale(this.lastSx/f,this.lastSy/w),h(),(Math.abs(_)===Math.abs(f)&&O||Math.abs(H)===Math.abs(w)&&E)&&(m.strokeWidth=1/t.view.zoom,g.strokeWidth=1/t.view.zoom,m.strokeColor=new t.Color(r),g.strokeColor=new t.Color(r),p.endLeft.strokeWidth=1/t.view.zoom,u.endLeft.strokeWidth=1/t.view.zoom,p.endRight.strokeWidth=1/t.view.zoom,u.endRight.strokeWidth=1/t.view.zoom,p.line.strokeWidth=1/t.view.zoom,u.line.strokeWidth=1/t.view.zoom,p.endLeft.strokeColor=new t.Color(r),u.endLeft.strokeColor=new t.Color(r),p.endRight.strokeColor=new t.Color(r),u.endRight.strokeColor=new t.Color(r),p.line.strokeColor=new t.Color(r),u.line.strokeColor=new t.Color(r),m.bringToFront(),g.bringToFront(),l(\"isGuideLayer\").addChildren([g,m,p.group,u.group])),Math.abs(_)===Math.abs(f)&&O)switch(O.type){case\"width\":{const e=O.coord.value,n=this.itemGroup.bounds.bottom;u.endLeft.firstSegment.point=new t.Point(O.coord.clamp.min,e),u.endLeft.lastSegment.point=new t.Point(O.coord.clamp.min,e+5/t.view.zoom),u.endRight.firstSegment.point=new t.Point(O.coord.clamp.max,e),u.endRight.lastSegment.point=new t.Point(O.coord.clamp.max,e+5/t.view.zoom),u.line.firstSegment.point=new t.Point(O.coord.clamp.min,e+3/t.view.zoom),u.line.lastSegment.point=new t.Point(O.coord.clamp.max,e+3/t.view.zoom),u.group.visible=!0,u.group.bringToFront(),p.endLeft.firstSegment.point=new t.Point(this.itemGroup.bounds.left,n+2/t.view.zoom),p.endLeft.lastSegment.point=new t.Point(this.itemGroup.bounds.left,n+7/t.view.zoom),p.endRight.firstSegment.point=new t.Point(this.itemGroup.bounds.right,n+2/t.view.zoom),p.endRight.lastSegment.point=new t.Point(this.itemGroup.bounds.right,n+7/t.view.zoom),p.line.firstSegment.point=new t.Point(this.itemGroup.bounds.left,n+4.5/t.view.zoom),p.line.lastSegment.point=new t.Point(this.itemGroup.bounds.right,n+4.5/t.view.zoom),p.group.visible=!0,p.group.bringToFront();break}case\"xcoord\":case\"itemSideVert\":m.firstSegment.point=new t.Point(O.coord.value,c.top),m.lastSegment.point=new t.Point(O.coord.value,c.bottom),m.visible=!0,m.bringToFront()}if(Math.abs(H)===Math.abs(w)&&E)switch(E.type){case\"height\":{const e=E.coord.value,n=this.itemGroup.bounds.left;u.endLeft.firstSegment.point=new t.Point(e,E.coord.clamp.min),u.endLeft.lastSegment.point=new t.Point(e-5/t.view.zoom,E.coord.clamp.min),u.endRight.firstSegment.point=new t.Point(e,E.coord.clamp.max),u.endRight.lastSegment.point=new t.Point(e-5/t.view.zoom,E.coord.clamp.max),u.line.firstSegment.point=new t.Point(e-3/t.view.zoom,E.coord.clamp.min),u.line.lastSegment.point=new t.Point(e-3/t.view.zoom,E.coord.clamp.max),u.group.visible=!0,u.group.bringToFront(),p.endLeft.firstSegment.point=new t.Point(n-2/t.view.zoom,this.itemGroup.bounds.top),p.endLeft.lastSegment.point=new t.Point(n-7/t.view.zoom,this.itemGroup.bounds.top),p.endRight.firstSegment.point=new t.Point(n-2/t.view.zoom,this.itemGroup.bounds.bottom),p.endRight.lastSegment.point=new t.Point(n-7/t.view.zoom,this.itemGroup.bounds.bottom),p.line.firstSegment.point=new t.Point(n-4.5/t.view.zoom,this.itemGroup.bounds.top),p.line.lastSegment.point=new t.Point(n-4.5/t.view.zoom,this.itemGroup.bounds.bottom),p.group.visible=!0,p.group.bringToFront();break}case\"ycoord\":case\"itemSideHoriz\":g.firstSegment.point=new t.Point(c.left,E.coord.value),g.lastSegment.point=new t.Point(c.right,E.coord.value),g.visible=!0,g.bringToFront()}this.lastSx=f,this.lastSy=w},Object(D.b)(t,c.constructor);const v=c.constructor.prototype.onMouseUp;c.constructor.prototype.onMouseUp=function(){h(),v.call(this)}};var E=n(1476);const A={\"userscript.js\":async function(t){const{addon:e}=t;e.self.addEventListener(\"disabled\",u),e.self.addEventListener(\"reenabled\",p),function(t){let{settings:e}=t;for(const t in i)Object.prototype.hasOwnProperty.call(i,t)&&l(t,e.get(t));for(const t in a)Object.prototype.hasOwnProperty.call(a,t)&&c(t,e.get(t));d(e.get(\"threshold\")),m(e.get(\"enable-default\"))}(e);const n=await e.tab.traps.getPaper(),[r]=n.tools;m(e.settings.get(\"enable-default\")),g(e.settings.get(\"guide-color\")),e.settings.addEventListener(\"change\",(()=>g(e.settings.get(\"guide-color\")))),(t=>\"selectionBoxTool\"in t&&\"boundingBoxTool\"in t)(r)&&(L(n,r,e.tab.traps.vm),O(n,r,e.tab.traps.vm)),function(t){let{addon:e,msg:n}=t;const r=()=>{const t=document.createElement(\"div\");return t.className=\"sa-paint-snap-group\",t},p=()=>{const t=document.createElement(\"div\");return t.className=\"sa-paint-snap-settings-separator\",t},u=function(){let{useButtonTag:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const e=document.createElement(t?\"button\":\"span\");return e.className=\"sa-paint-snap-button\",e.setAttribute(\"role\",\"button\"),e},g=t=>{const n=document.createElement(\"img\");return n.className=\"sa-paint-snap-image\",n.draggable=!1,n.src=e.self.getResource(\"/icons/\"+t+\".svg\"),n},b=r();e.tab.displayNoneWhileDisabled(b,{display:\"flex\"});const h=document.createElement(\"div\");h.className=\"sa-paint-snap-settings-wrapper\",b.appendChild(h);const v=document.createElement(\"div\");v.className=\"sa-paint-snap-settings\",h.appendChild(v);const y=\"http://www.w3.org/2000/svg\",f=document.createElementNS(y,\"svg\");f.setAttribute(\"class\",\"sa-paint-snap-settings-tip\"),f.setAttribute(\"width\",\"14\"),f.setAttribute(\"height\",\"7\");const w=document.createElementNS(y,\"polygon\");w.setAttribute(\"class\",\"sa-paint-snap-settings-polygon\"),w.setAttribute(\"points\",\"0,0 7,7, 14,0\"),f.appendChild(w),v.appendChild(f);const M=u();M.addEventListener(\"click\",(()=>{o||(Object.values(i).some((t=>t))||l(\"pageCenter\",!0),Object.values(a).some((t=>t))||c(\"boxCenter\",!0)),m(!o),M.dataset.enabled=o})),M.title=n(\"toggle\"),M.appendChild(g(\"snap\")),M.dataset.enabled=o,b.appendChild(M);const I=u();I.addEventListener(\"click\",(()=>j(!S()))),I.title=n(\"settings\"),I.appendChild(g(\"settings\")),b.appendChild(I),document.body.addEventListener(\"click\",(t=>{S()&&!t.target.matches(\".sa-paint-snap-group *\")&&j(!1)}));const x=[],j=t=>{I.dataset.enabled=t,v.dataset.visible=t,t?x.forEach((t=>{try{null==t||t()}catch(t){}})):(Object.values(a).every((t=>!t))||Object.values(i).every((t=>!t)))&&(m(!1),M.dataset.enabled=!1)},S=()=>\"true\"===v.dataset.visible,N=function(t,e,o){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:()=>{};const a=[t,e],s=r(),l=u({useButtonTag:!0}),c=u({useButtonTag:!0}),d=g(t),p=g(e);d.dataset.shrink=p.dataset.shrink=!0,l.appendChild(d),c.appendChild(p),l.setAttribute(\"aria-label\",l.title=n(t)),c.setAttribute(\"aria-label\",c.title=n(e));const m=function(t,e){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];l.dataset.enabled=!!t,c.dataset.enabled=!t,n||i(a[t])};return m(1-a.indexOf(o),null,!0),l.addEventListener(\"click\",m.bind(l,1)),c.addEventListener(\"click\",m.bind(c,0)),s.append(l,c),s},L=(t,e)=>{const o=document.createElement(\"label\");o.className=\"sa-paint-snap-settings-line\";const r=document.createElement(\"div\");return r.className=\"sa-paint-snap-settings-label\",r.textContent=n(t),o.append(r,e),x.push((()=>{const o=e.querySelector('[aria-label=\"'.concat(n(\"on\"),'\"]')),r=e.querySelector('[aria-label=\"'.concat(n(\"off\"),'\"]'));t in i&&(o.dataset.enabled=!!i[t],r.dataset.enabled=!i[t]),t in a&&(o.dataset.enabled=!!a[t],r.dataset.enabled=!a[t])})),o},C=function(t){const e=document.createElement(\"div\");e.className=\"sa-paint-snap-settings-section\";const n=document.createElement(\"span\");n.appendChild(document.createTextNode(t)),n.className=\"sa-paint-snap-settings-section-title\",e.appendChild(n);for(var o=arguments.length,i=new Array(o>1?o-1:0),a=1;a<o;a++)i[a-1]=arguments[a];return e.append(...i),e},P=L(\"threshold\",function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1/0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1;const a=r(),s=document.createElement(\"div\");s.style.width=\"20px\";const l=u();l.appendChild(s);const c=document.createElement(\"input\");c.className=\"sa-paint-snap-settings-input\",c.type=\"number\",c.step=i,c.min=n,c.max=o,c.value=t,c.addEventListener(\"change\",(()=>{c.value>o&&(c.value=o),c.value<n&&(c.value=n),e(c.value)})),c.addEventListener(\"blur\",(()=>{c.value||(c.value=\"0\")})),l.appendChild(c);const d=u();d.appendChild(g(\"decrement\")),d.addEventListener(\"click\",(()=>{c.value>n&&(c.value=Number(c.value)-1,e(Number(c.value)+1))}));const p=u();return p.appendChild(g(\"increment\")),p.addEventListener(\"click\",(()=>{c.value<o&&(c.value=Number(c.value)+1,e(Number(c.value)+1))})),a.append(d,l,p),a}(s,(t=>{d(t)}),4,50,1)),T=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>{};return[\"off\",\"on\",(n=t,n?\"on\":\"off\"),t=>e(!![\"on\",\"off\"].indexOf(t))];var n},z=t=>L(t,N(...T(i[t],(e=>{m(!0),M.dataset.enabled=!0,l(t,e)})))),D=C(n(\"snapTo\"),z(\"pageCenter\"),z(\"pageAxes\"),z(\"pageEdges\"),z(\"pageCorners\"),z(\"objectCenters\"),z(\"objectMidlines\"),z(\"objectEdges\"),z(\"objectCorners\")),O=t=>L(t,N(...T(a[t],(e=>{c(t,e)})))),E=C(n(\"snapFrom\"),O(\"boxCenter\"),O(\"boxCorners\"),O(\"boxEdgeMids\"));v.append(P,p(),D,p(),E),(async()=>{let t=!1;for(;;){const n=(await e.tab.waitForElement(\"[class^='paint-editor_canvas-controls']\",{markAsSeen:!0,reduxEvents:[\"scratch-gui/navigation/ACTIVATE_TAB\",\"scratch-gui/mode/SET_PLAYER\",\"fontsLoaded/SET_FONTS_LOADED\",\"scratch-gui/locales/SELECT_LOCALE\",\"scratch-gui/targets/UPDATE_TARGET_LIST\"],reduxCondition:t=>1===t.scratchGui.editorTab.activeTabIndex&&!t.scratchGui.mode.isPlayerOnly})).querySelector(\"[class^='paint-editor_zoom-controls']\");if(e.tab.appendToSharedSpace({space:\"paintEditorZoomControls\",element:b,order:2}),!t){t=!0;const e=n.firstChild.className,o=n.firstChild.firstChild.className,i=n.firstChild.firstChild.firstChild.className;for(const t of document.querySelectorAll(\".sa-paint-snap-group\"))t.className+=\" \"+e;for(const t of document.querySelectorAll(\".sa-paint-snap-button\"))t.className+=\" \"+o;for(const t of document.querySelectorAll(\".sa-paint-snap-image\"))t.className+=\" \"+i}}})()}(t)},\"userstyle.css\":n.n(E).a,\"icons/decrement.svg\":\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCI+PHBhdGggc3R5bGU9ImZpbGw6IzU3NWU3NTtzdHJva2Utd2lkdGg6LjczNDczNiIgZD0iTTMuMjUgMTEuMzU4aDE3LjUwMXYxLjI4NUgzLjI1eiIvPjwvc3ZnPg==\",\"icons/increment.svg\":\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHdpZHRoPSIyNCI+PHBhdGggc3R5bGU9ImZpbGw6IzU3NWU3NTtzdHJva2Utd2lkdGg6LjczNDczNiIgZD0iTTMuMjUgMTEuMzU4aDE3LjUwMXYxLjI4NUgzLjI1eiIvPjxwYXRoIHRyYW5zZm9ybT0icm90YXRlKDkwKSIgc3R5bGU9ImZpbGw6IzU3NWU3NTtzdHJva2Utd2lkdGg6LjczNDczNiIgZD0iTTMuMjUtMTIuNjQyaDE3LjUwMXYxLjI4NUgzLjI1eiIvPjwvc3ZnPg==\",\"icons/off.svg\":\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgMTYgMTYiPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzU3NWU3NSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEuNSIgZD0ibTExLjI1IDQuNzUtNi41IDYuNW0wLTYuNSA2LjUgNi41Ii8+PC9zdmc+\",\"icons/on.svg\":\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgMTYgMTYiPjxwYXRoIGZpbGw9IiM1NzVlNzUiIGQ9Ik0xMi43MzYgMy45N2EuNzMzLjczMyAwIDAgMSAxLjA0NyAwYy4yODYuMjg5LjI5Ljc1Ni4wMSAxLjA1TDcuODggMTIuMDFhLjczMy43MzMgMCAwIDEtMS4wNjUuMDJMMy4yMTcgOC4zODRhLjc1Ny43NTcgMCAwIDEgMC0xLjA2LjczMy43MzMgMCAwIDEgMS4wNDcgMGwzLjA1MiAzLjA5MyA1LjQtNi40MjVhLjI0Ny4yNDcgMCAwIDEgLjAyLS4wMjJaIi8+PC9zdmc+\",\"icons/settings.svg\":\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PGNpcmNsZSBjeD0iMTIuNTUiIGN5PSIxMi41NSIgcj0iOS4wNSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNTc1ZTc1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iNyIvPjxjaXJjbGUgY3g9IjYxLjk0MyIgY3k9IjYxLjQzNiIgcj0iNy41IiBmaWxsPSIjNTc1ZTc1Ii8+PHBhdGggZmlsbD0iIzU3NWU3NSIgZD0ibTUzLjExOSAyNy43NDMtOC4yNjcgOC4yNjZMMzEuNjkgMjIuODQ3bC04LjU3IDguNTczIDEzLjE2IDEzLjE2LTguMjY2IDguMjY2aDI1LjEwNXoiIGNvbG9yPSIjNTc1ZTc1Ii8+PHBhdGggZmlsbD0iIzU3NWU3NSIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNDYuMjI3IDEwMGMuNTMtMy4yMDUgMS4yMTktNi4zNzQgMi4xMTItOS40N2wtNC44MDQtMS4zODZjLS45NTQgMy4zMS0xLjY4MyA2LjY2OS0yLjI0IDEwLjA0em0zLjYwMy0xNC4wNjhhNjMuOTM1IDYzLjkzNSAwIDAgMSAzLjkzLTguNzc1bC00LjM5My0yLjM4NmE2OC45MTcgNjguOTE3IDAgMCAwLTQuMjQgOS40NnptNi4zODItMTIuOWMxLjc1My0yLjY5NCAzLjY5LTUuMjQ5IDUuODQtNy41NzhsLTMuNjczLTMuMzkyYy0yLjM3MiAyLjU2OS00LjQ3NCA1LjM1LTYuMzU3IDguMjQxem05LjIzNC0xMC45NDFhNTcuOTUgNTcuOTUgMCAwIDEgNy42MDktNS44MTNsLTIuNzAzLTQuMjA4YTYyLjk0NCA2Mi45NDQgMCAwIDAtOC4yNjYgNi4zMTd6bTExLjc1Mi04LjI2MmE3MS4yNjUgNzEuMjY1IDAgMCAxIDguNzg2LTRsLTEuNzY2LTQuNjc3YTc2LjI0MiA3Ni4yNDIgMCAwIDAtOS40MDEgNC4yODF6bTEzLjM3Mi01LjU3MkE4Ny45MjYgODcuOTI2IDAgMCAxIDEwMCA0NS45MUw5OS4wNTcgNDFhOTIuOTM4IDkyLjkzOCAwIDAgMC05Ljk2NyAyLjQ4eiIgY29sb3I9IiM1NzVlNzUiLz48L3N2Zz4=\",\"icons/snap.svg\":\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgNTEyIDUxMiI+PHBhdGggZmlsbD0iIzU3NWU3NSIgc3Ryb2tlPSIjNTc1ZTc1IiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHN0cm9rZS13aWR0aD0iMzIiIGQ9Ik0xOTEuOTggNDYzLjU4di00OE05MC4xNiA0MjEuNGwzMy45NC0zMy45NG0tNzYuMTItNjcuODhoNDgiLz48cGF0aCBmaWxsPSIjNTc1ZTc1IiBkPSJNNDIyLjIgODkuODJhMTQ0IDE0NCAwIDAgMC0yMDMuNzEtLjA3bC02Ny44OCA2Ny44OCA2Ny44OCA2Ny44OSA2Ny44OC02Ny44OWE0OCA0OCAwIDAgMSA2OC40Ni41OWMxOC4zIDE4LjkyIDE3LjQ4IDQ5LjI0LTEuMTQgNjcuODZsLTY3LjMyIDY3LjMyIDY3Ljg4IDY3Ljg4IDY2LjkxLTY2LjkxYzU2LjM3LTU2LjM3IDU3LjM3LTE0OC4xNSAxLjA0LTIwNC41NVpNODIuNzE5IDIyNS41MTdsNDUuMjU0LTQ1LjI1NCA2Ny44ODMgNjcuODgyTDE1MC42IDI5My40ek0yMTguNDkgMzYxLjI3bDQ1LjI1NC00NS4yNTQgNjcuODgyIDY3Ljg4Mi00NS4yNTUgNDUuMjU1eiIvPjwvc3ZnPg==\"}}}]);","name":"77.index.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[77],{\n\n/***/ 1399:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return addons; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return initialize; });\nlet overridden = false;\nconst addons = {\n  paintSkew: null,\n  paintSnap: null\n};\nfunction initialize(paper, ScaleTool) {\n  if (overridden) return;\n  overridden = true;\n  const ogMouseDrag = ScaleTool.prototype.onMouseDrag;\n  ScaleTool.prototype.onMouseDrag = function (event) {\n    if (!this.active) return;\n    const callSnap = () => {\n      if (addons.paintSnap) addons.paintSnap.call(this, event);else ogMouseDrag.call(this, event);\n    };\n    if (addons.paintSkew) {\n      addons.paintSkew.call(this, event, callSnap);\n    } else {\n      callSnap();\n    }\n  };\n}\n\n/***/ }),\n\n/***/ 1476:\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(10)(false);\n// imports\n\n\n// module\nexports.push([module.i, \".sa-paint-snap-button {\\n  position: relative;\\n}\\n.sa-paint-snap-button:focus-within {\\n  background-color: var(--editorDarkMode-primary-transparent35, hsla(260, 60%, 60%, 0.35));\\n}\\n.sa-paint-snap-button[data-enabled=\\\"true\\\"] .sa-paint-snap-image {\\n  filter: brightness(0) invert(1);\\n}\\n.sa-paint-snap-button[data-enabled=\\\"true\\\"] {\\n  background-color: var(--looks-secondary);\\n}\\n\\n.sa-paint-snap-group {\\n  position: relative;\\n  flex-direction: row;\\n}\\n\\n.sa-paint-snap-settings-wrapper {\\n  position: absolute;\\n  justify-items: center;\\n  left: 50%;\\n  width: 1.95rem;\\n  height: 1.95rem;\\n  display: grid;\\n}\\n\\n.sa-paint-snap-settings {\\n  position: absolute;\\n  bottom: 100%;\\n  /* based on the styles for the color dropdown */\\n  padding: 4px;\\n  border-radius: 4px;\\n  border: 1px solid var(--ui-black-transparent);\\n  box-shadow: 0px 0px 8px 1px rgba(0, 0, 0, 0.3);\\n  transition-property: bottom, opacity;\\n  transition-duration: 500ms;\\n  transition-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\\n  opacity: 0;\\n  pointer-events: none;\\n  background: var(--ui-modal-background);\\n  color: var(--ui-text-primary);\\n  min-height: 100%;\\n  min-width: 100%;\\n  display: flex;\\n  flex-direction: column;\\n  gap: 0.25em;\\n}\\n.sa-paint-snap-settings[data-visible=\\\"true\\\"] {\\n  bottom: calc(100% + 22px);\\n  pointer-events: auto;\\n  opacity: 1;\\n  z-index: 200;\\n}\\n\\n.sa-paint-snap-settings-line {\\n  display: flex;\\n  justify-content: flex-end;\\n  align-items: baseline;\\n}\\n\\n.sa-paint-snap-settings-input {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  box-sizing: border-box;\\n  text-align: center;\\n  border: 0;\\n  background: transparent;\\n  -moz-appearance: textfield;\\n  border: 0;\\n  outline: 0;\\n}\\n\\n.sa-paint-snap-settings-input::-webkit-outer-spin-button,\\n.sa-paint-snap-settings-input::-webkit-inner-spin-button {\\n  -webkit-appearance: none;\\n  margin: 0;\\n}\\n\\n.sa-paint-snap-settings-tip {\\n  position: absolute;\\n  bottom: 0;\\n  transform: translateY(100%);\\n  right: calc(50% - 7px);\\n}\\n.sa-paint-snap-settings-polygon {\\n  fill: var(--ui-modal-background);\\n  stroke: var(--ui-black-transparent);\\n}\\n\\n.sa-paint-snap-settings-separator {\\n  flex-grow: 1;\\n  border-bottom: 1px solid currentColor;\\n  margin: 4px;\\n  opacity: 0.25;\\n}\\n\\n.sa-paint-snap-settings-section {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 0.25em;\\n  align-items: flex-end;\\n  width: 100%;\\n}\\n\\n.sa-paint-snap-settings-section-title {\\n  font-size: 1.2em;\\n  font-weight: 500;\\n  align-self: flex-start;\\n  margin-left: 4px;\\n}\\n\\n.sa-paint-snap-settings-label {\\n  white-space: nowrap;\\n}\\n\\n.sa-paint-snap-image[data-shrink=\\\"true\\\"] {\\n  height: 1em;\\n  width: 1em;\\n}\\n\", \"\"]);\n\n// exports\n\n\n/***/ }),\n\n/***/ 1529:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"resources\", function() { return /* binding */ resources; });\n\n// CONCATENATED MODULE: ./node_modules/scratch-gui/src/addons/addons/paint-snap/state.js\nlet snapOn = true;\n\n//const ls = localStorage;\n\nconst snapTo = {\n  pageEdges: true,\n  pageCenter: true,\n  pageAxes: true,\n  pageCorners: false,\n  objectEdges: true,\n  objectCenters: true,\n  objectMidlines: true,\n  objectCorners: false\n};\nconst snapFrom = {\n  boxCenter: true,\n  boxCorners: false,\n  boxEdgeMids: false\n};\nlet threshold = 10;\nlet guideColor;\n\n/**\n *\n * @param {import(\"../../addon-api/content-script/typedef\").UserscriptAddon} addon\n */\nfunction loadSettings(_ref) {\n  let {\n    settings\n  } = _ref;\n  for (const point in snapTo) {\n    if (Object.prototype.hasOwnProperty.call(snapTo, point)) setSnapTo(point, settings.get(point));\n  }\n  for (const point in snapFrom) {\n    if (Object.prototype.hasOwnProperty.call(snapFrom, point)) setSnapFrom(point, settings.get(point));\n  }\n  setThreshold(settings.get(\"threshold\"));\n  toggle(settings.get(\"enable-default\"));\n}\n\n// Will update for addon storage api, but not yet.\n/*if (ls.getItem(\"sa-paint-snap-snapTo\")) {\n  const stored = JSON.parse(ls.getItem(\"sa-paint-snap-snapTo\"));\n  Object.assign(snapTo, stored);\n}\n\nif (ls.getItem(\"sa-paint-snap-snapFrom\")) {\n  const stored = JSON.parse(ls.getItem(\"sa-paint-snap-snapFrom\"));\n  Object.assign(snapFrom, stored);\n}\n\nif (ls.getItem(\"sa-paint-snap-threshold\")) {\n  const stored = JSON.parse(ls.getItem(\"sa-paint-snap-threshold\"));\n  threshold = stored;\n}*/\n\nfunction setSnapTo(point, to) {\n  snapTo[point] = !!to;\n  //ls.setItem(\"sa-paint-snap-snapTo\", JSON.stringify(snapTo));\n}\nfunction setSnapFrom(point, to) {\n  snapFrom[point] = !!to;\n  //ls.setItem(\"sa-paint-snap-snapFrom\", JSON.stringify(snapFrom));\n}\nfunction setThreshold(thresh) {\n  threshold = thresh;\n  //ls.setItem(\"sa-paint-snap-threshold\", JSON.stringify(threshold));\n}\nfunction enable() {\n  snapOn = true;\n}\nfunction disable() {\n  snapOn = false;\n}\nfunction toggle(enabled) {\n  if (enabled) enable();else disable();\n}\nfunction setGuideColor(hex) {\n  guideColor = hex;\n}\n// CONCATENATED MODULE: ./node_modules/scratch-gui/src/addons/addons/paint-snap/genSnapPoints.js\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nfunction createSnapPoints(paper, selectionBounds, lib, objects) {\n  const {\n    view: {\n      CENTER,\n      ART_BOARD_BOUNDS\n    }\n  } = lib;\n  const fromPoints = _objectSpread(_objectSpread(_objectSpread({}, snapFrom.boxCenter ? {\n    center: selectionBounds.center\n  } : {}), snapFrom.boxCorners ? {\n    topLeft: selectionBounds.topLeft,\n    topRight: selectionBounds.topRight,\n    bottomLeft: selectionBounds.bottomLeft,\n    bottomRight: selectionBounds.bottomRight\n  } : {}), snapFrom.boxEdgeMids ? {\n    left: new paper.Point(selectionBounds.left, selectionBounds.center.y),\n    right: new paper.Point(selectionBounds.right, selectionBounds.center.y),\n    top: new paper.Point(selectionBounds.center.x, selectionBounds.top),\n    bottom: new paper.Point(selectionBounds.center.x, selectionBounds.bottom)\n  } : {});\n  const toPoints = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, snapTo.pageCenter ? {\n    bounds_c: {\n      type: \"point\",\n      value: CENTER\n    }\n  } : {}), snapTo.pageAxes ? {\n    bounds_cx: {\n      type: \"xcoord\",\n      value: CENTER.x\n    },\n    bounds_cy: {\n      type: \"ycoord\",\n      value: CENTER.y\n    }\n  } : {}), snapTo.pageEdges ? {\n    bounds_l: {\n      type: \"xcoord\",\n      value: ART_BOARD_BOUNDS.left,\n      clamp: {\n        min: ART_BOARD_BOUNDS.top,\n        max: ART_BOARD_BOUNDS.bottom\n      }\n    },\n    bounds_r: {\n      type: \"xcoord\",\n      value: ART_BOARD_BOUNDS.right,\n      clamp: {\n        min: ART_BOARD_BOUNDS.top,\n        max: ART_BOARD_BOUNDS.bottom\n      }\n    },\n    bounds_t: {\n      type: \"ycoord\",\n      value: ART_BOARD_BOUNDS.top,\n      clamp: {\n        min: ART_BOARD_BOUNDS.left,\n        max: ART_BOARD_BOUNDS.right\n      }\n    },\n    bounds_b: {\n      type: \"ycoord\",\n      value: ART_BOARD_BOUNDS.bottom,\n      clamp: {\n        min: ART_BOARD_BOUNDS.left,\n        max: ART_BOARD_BOUNDS.right\n      }\n    },\n    bounds_lc: {\n      type: \"point\",\n      value: new paper.Point(ART_BOARD_BOUNDS.left, CENTER.y)\n    },\n    bounds_rc: {\n      type: \"point\",\n      value: new paper.Point(ART_BOARD_BOUNDS.right, CENTER.y)\n    },\n    bounds_tc: {\n      type: \"point\",\n      value: new paper.Point(CENTER.x, ART_BOARD_BOUNDS.top)\n    },\n    bounds_bc: {\n      type: \"point\",\n      value: new paper.Point(CENTER.x, ART_BOARD_BOUNDS.bottom)\n    }\n  } : {}), snapTo.pageCorners ? {\n    bounds_tl: {\n      type: \"point\",\n      value: ART_BOARD_BOUNDS.topLeft\n    },\n    bounds_tr: {\n      type: \"point\",\n      value: ART_BOARD_BOUNDS.topRight\n    },\n    bounds_bl: {\n      type: \"point\",\n      value: ART_BOARD_BOUNDS.bottomLeft\n    },\n    bounds_br: {\n      type: \"point\",\n      value: ART_BOARD_BOUNDS.bottomRight\n    }\n  } : {}), snapTo.objectEdges ? Object.fromEntries(objects.filter(item => !(item.selected || item.data.isHelperItem || item.locked || item.guide)).map(item => [[\"item_\".concat(item.id, \"_r\"), {\n    type: \"itemSideVert\",\n    value: item.bounds.right,\n    clamp: {\n      min: item.bounds.top,\n      max: item.bounds.bottom\n    }\n  }], [\"item_\".concat(item.id, \"_l\"), {\n    type: \"itemSideVert\",\n    value: item.bounds.left,\n    clamp: {\n      min: item.bounds.top,\n      max: item.bounds.bottom\n    }\n  }], [\"item_\".concat(item.id, \"_t\"), {\n    type: \"itemSideHoriz\",\n    value: item.bounds.top,\n    clamp: {\n      min: item.bounds.left,\n      max: item.bounds.right\n    }\n  }], [\"item_\".concat(item.id, \"_b\"), {\n    type: \"itemSideHoriz\",\n    value: item.bounds.bottom,\n    clamp: {\n      min: item.bounds.left,\n      max: item.bounds.right\n    }\n  }]]).flat(1)) : {}), snapTo.objectCenters ? Object.fromEntries(objects.filter(item => !(item.selected || item.data.isHelperItem || item.locked || item.guide)).map(item => [[\"item_\".concat(item.id, \"_c\"), {\n    type: \"point\",\n    value: item.bounds.center\n  }]]).flat(1)) : {}), snapTo.objectMidlines ? Object.fromEntries(objects.filter(item => !(item.selected || item.data.isHelperItem || item.locked || item.guide)).map(item => [[\"item_\".concat(item.id, \"_cx\"), {\n    type: \"xcoord\",\n    value: item.bounds.center.x\n  }], [\"item_\".concat(item.id, \"_cy\"), {\n    type: \"ycoord\",\n    value: item.bounds.center.y\n  }]]).flat(1)) : {}), snapTo.objectCorners ? Object.fromEntries(objects.filter(item => !(item.selected || item.data.isHelperItem || item.locked || item.guide)).map(item => [[\"item_\".concat(item.id, \"_tl\"), {\n    type: \"point\",\n    value: item.bounds.topLeft\n  }], [\"item_\".concat(item.id, \"_tr\"), {\n    type: \"point\",\n    value: item.bounds.topRight\n  }], [\"item_\".concat(item.id, \"_bl\"), {\n    type: \"point\",\n    value: item.bounds.bottomLeft\n  }], [\"item_\".concat(item.id, \"_br\"), {\n    type: \"point\",\n    value: item.bounds.bottomRight\n  }]]).flat(1)) : {});\n  return {\n    from: fromPoints,\n    to: toPoints\n  };\n}\n// CONCATENATED MODULE: ./node_modules/scratch-gui/src/addons/addons/paint-snap/helpers.js\nfunction helpers_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction helpers_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? helpers_ownKeys(Object(t), !0).forEach(function (r) { helpers_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : helpers_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction helpers_defineProperty(e, r, t) { return (r = helpers_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction helpers_toPropertyKey(t) { var i = helpers_toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction helpers_toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction loadModules(paper, vm) {\n  // https://github.com/scratchfoundation/scratch-paint/blob/2a9fb2356d961200dc849b5b0a090d33f473c0b5/src/helper/math.js\n\n  const checkPointsClose = function checkPointsClose(startPos, eventPoint, threshold) {\n    const xOff = Math.abs(startPos.x - eventPoint.x);\n    const yOff = Math.abs(startPos.y - eventPoint.y);\n    if (xOff < threshold && yOff < threshold) {\n      return true;\n    }\n    return false;\n  };\n\n  // Thanks Mikko Mononen! https://github.com/memononen/stylii\n  const snapDeltaToAngle = function snapDeltaToAngle(delta, snapAngle) {\n    let angle = Math.atan2(delta.y, delta.x);\n    angle = Math.round(angle / snapAngle) * snapAngle;\n    const dirx = Math.cos(angle);\n    const diry = Math.sin(angle);\n    const d = dirx * delta.x + diry * delta.y;\n    return new paper.Point(dirx * d, diry * d);\n  };\n\n  // https://github.com/scratchfoundation/scratch-paint/blob/2a9fb2356d961200dc849b5b0a090d33f473c0b5/src/helper/layer.js\n  const CROSSHAIR_FULL_OPACITY = 0.75;\n  const _getLayer = function _getLayer(layerString) {\n    for (const layer of paper.project.layers) {\n      if (layer.data && layer.data[layerString]) {\n        return layer;\n      }\n    }\n  };\n  const getDragCrosshairLayer = function getDragCrosshairLayer() {\n    return _getLayer(\"isDragCrosshairLayer\");\n  };\n  const getGuideLayer = function getGuideLayer() {\n    return _getLayer(\"isGuideLayer\");\n  };\n\n  // https://github.com/scratchfoundation/scratch-paint/blob/2a9fb2356d961200dc849b5b0a090d33f473c0b5/src/helper/view.js\n\n  // Vectors are imported and exported at SVG_ART_BOARD size.\n  // Once they are imported however, both SVGs and bitmaps are on\n  // canvases of ART_BOARD size.\n  let SVG_ART_BOARD_WIDTH;\n  let SVG_ART_BOARD_HEIGHT;\n  let ART_BOARD_WIDTH;\n  let ART_BOARD_HEIGHT;\n  let CENTER;\n  let ART_BOARD_BOUNDS;\n  let MAX_WORKSPACE_BOUNDS;\n  const updateStageSize = () => {\n    SVG_ART_BOARD_WIDTH = vm.runtime.stageWidth;\n    SVG_ART_BOARD_HEIGHT = vm.runtime.stageHeight;\n    ART_BOARD_WIDTH = SVG_ART_BOARD_WIDTH * 2;\n    ART_BOARD_HEIGHT = SVG_ART_BOARD_HEIGHT * 2;\n    CENTER = new paper.Point(ART_BOARD_WIDTH / 2, ART_BOARD_HEIGHT / 2);\n    ART_BOARD_BOUNDS = new paper.Rectangle(0, 0, ART_BOARD_WIDTH, ART_BOARD_HEIGHT);\n    MAX_WORKSPACE_BOUNDS = new paper.Rectangle(-ART_BOARD_WIDTH / 4, -ART_BOARD_HEIGHT / 4, ART_BOARD_WIDTH * 1.5, ART_BOARD_HEIGHT * 1.5);\n  };\n  vm.on(\"STAGE_SIZE_CHANGED\", updateStageSize);\n  updateStageSize();\n\n  /**\n   * Mouse actions are clamped to action bounds\n   * @param {boolean} isBitmap True if the editor is in bitmap mode, false if it is in vector mode\n   * @returns {paper.Rectangle} the bounds within which mouse events should work in the paint editor\n   */\n  const getActionBounds = isBitmap => {\n    if (isBitmap) {\n      return ART_BOARD_BOUNDS;\n    }\n    return paper.view.bounds.unite(ART_BOARD_BOUNDS);\n  };\n  const setDefaultGuideStyle = function setDefaultGuideStyle(item) {\n    item.strokeWidth = 1 / paper.view.zoom;\n    item.opacity = 1;\n    item.blendMode = \"normal\";\n    item.guide = true;\n  };\n  const GUIDE_BLUE = \"#009dec\";\n  const hoverBounds = function hoverBounds(item, expandBy) {\n    let bounds = item.internalBounds;\n    if (expandBy) {\n      bounds = bounds.expand(expandBy);\n    }\n    const rect = new paper.Path.Rectangle(bounds);\n    rect.matrix = item.matrix;\n    setDefaultGuideStyle(rect);\n    rect.parent = getGuideLayer();\n    rect.strokeColor = GUIDE_BLUE;\n    rect.fillColor = null;\n    rect.data.isHelperItem = true;\n    rect.data.origItem = item;\n    rect.bringToFront();\n    return rect;\n  };\n  return {\n    math: {\n      checkPointsClose,\n      snapDeltaToAngle\n    },\n    layer: {\n      CROSSHAIR_FULL_OPACITY,\n      getDragCrosshairLayer,\n      getLayer: _getLayer\n    },\n    view: {\n      get CENTER() {\n        return CENTER;\n      },\n      get ART_BOARD_BOUNDS() {\n        return ART_BOARD_BOUNDS;\n      },\n      get MAX_WORKSPACE_BOUNDS() {\n        return MAX_WORKSPACE_BOUNDS;\n      },\n      getActionBounds\n    },\n    guide: {\n      hoverBounds\n    }\n  };\n}\nconst keyMirror = obj => Object.fromEntries(Object.entries(obj).map(_ref => {\n  let [k] = _ref;\n  return [k, k];\n}));\n\n// https://github.com/scratchfoundation/scratch-paint/blob/2a9fb2356d961200dc849b5b0a090d33f473c0b5/src/lib/modes.js\n\nconst vectorModesObj = {\n  BRUSH: null,\n  ERASER: null,\n  LINE: null,\n  FILL: null,\n  SELECT: null,\n  RESHAPE: null,\n  OVAL: null,\n  RECT: null,\n  ROUNDED_RECT: null,\n  TEXT: null\n};\nconst bitmapModesObj = {\n  BIT_BRUSH: null,\n  BIT_LINE: null,\n  BIT_OVAL: null,\n  BIT_RECT: null,\n  BIT_TEXT: null,\n  BIT_FILL: null,\n  BIT_ERASER: null,\n  BIT_SELECT: null\n};\nconst VectorModes = keyMirror(vectorModesObj);\nconst BitmapModes = keyMirror(bitmapModesObj);\nconst Modes = keyMirror(helpers_objectSpread(helpers_objectSpread({}, vectorModesObj), bitmapModesObj));\nconst GradientToolsModes = keyMirror({\n  FILL: null,\n  SELECT: null,\n  RESHAPE: null,\n  OVAL: null,\n  RECT: null,\n  LINE: null,\n  BIT_OVAL: null,\n  BIT_RECT: null,\n  BIT_SELECT: null,\n  BIT_FILL: null\n});\n\n// CONCATENATED MODULE: ./node_modules/scratch-gui/src/addons/addons/paint-snap/updateSelectTool.js\n\n\n\nconst getMoveTool = tool => {\n  return tool.boundingBoxTool._modeMap.MOVE;\n};\nconst updateSelectTool = (paper, tool, vm) => {\n  const lib = loadModules(paper, vm);\n  const {\n    math: {\n      checkPointsClose,\n      snapDeltaToAngle\n    },\n    view: {\n      getActionBounds,\n      CENTER\n    },\n    layer: {\n      getDragCrosshairLayer,\n      CROSSHAIR_FULL_OPACITY,\n      getLayer\n    },\n    guide: {\n      hoverBounds\n    }\n  } = lib;\n  const moveTool = getMoveTool(tool);\n\n  // https://github.com/scratchfoundation/scratch-paint/blob/2a9fb2356d961200dc849b5b0a090d33f473c0b5/src/helper/selection-tools/move-tool.js\n\n  const FADE_DISTANCE = 10;\n  let guideLine = new paper.Path.Line({\n    from: [0, 0],\n    to: [0, 0],\n    strokeColor: new paper.Color(guideColor),\n    strokeWidth: 1 / paper.view.zoom,\n    visible: false,\n    data: {\n      isHelperItem: true,\n      noSelect: true,\n      noHover: true,\n      saPaintSnapGuide: true\n    },\n    selected: false\n  });\n  const guidePointParts = {\n    shadow: null,\n    circle: null\n  };\n  const guidePoint = new paper.Group({\n    children: [],\n    visible: false\n  });\n\n  // Paper adds them by default, and we don't want them in the canvas yet.\n  guideLine.remove();\n  guidePoint.remove();\n  let itemIndicator;\n  const fixGuideSizes = () => {\n    guidePointParts.shadow = new paper.Path.Circle({\n      center: new paper.Point(0, 0),\n      radius: 5.5 / paper.view.zoom,\n      fillColor: \"black\",\n      opacity: 0.12,\n      data: {\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true\n      },\n      visible: true,\n      guide: true\n    });\n    guidePointParts.circle = new paper.Path.Circle({\n      center: new paper.Point(0, 0),\n      radius: 4 / paper.view.zoom,\n      fillColor: new paper.Color(guideColor),\n      data: {\n        isScaleHandle: false,\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true\n      },\n      visible: true,\n      guide: true\n    });\n    guidePoint.removeChildren();\n    guidePoint.addChildren([guidePointParts.shadow, guidePointParts.circle]);\n    guideLine.strokeWidth = 1 / paper.view.zoom;\n    guideLine.strokeColor = new paper.Color(guideColor);\n    guideLine.bringToFront();\n    guidePoint.bringToFront();\n    getLayer(\"isGuideLayer\").addChildren([guideLine, guidePoint]);\n  };\n  let removeGuides;\n  function onMouseDrag(event) {\n    var _getLayer$children$fi, _getLayer$children$fi2;\n    const point = event.point;\n    const actionBounds = getActionBounds(this.mode in BitmapModes);\n    point.x = Math.max(actionBounds.left, Math.min(point.x, actionBounds.right));\n    point.y = Math.max(actionBounds.top, Math.min(point.y, actionBounds.bottom));\n    const dragVector = point.subtract(event.downPoint);\n    const scaledThreshold = threshold / paper.view.zoom;\n    let snapVector;\n    if (this.selectedItems.length === 0) {\n      return;\n    }\n    const selectionBounds = this.selectionCenter._owner;\n    const newCenter = this.selectionCenter.add(dragVector);\n    const getDist = (p1, p2) => {\n      return p1.getDistance(p2);\n    };\n    const selectionAnchor = (_getLayer$children$fi = (_getLayer$children$fi2 = getLayer(\"isGuideLayer\").children.find(c => c.data.isSelectionBound)) === null || _getLayer$children$fi2 === void 0 ? void 0 : _getLayer$children$fi2.selectionAnchor) !== null && _getLayer$children$fi !== void 0 ? _getLayer$children$fi : {};\n    const resetAnchorColor = () => {\n      selectionAnchor.strokeColor = new paper.Color(0.30196078431372547, 0.592156862745098, 1);\n      selectionAnchor.fillColor = null;\n    };\n    removeGuides = () => {\n      var _itemIndicator;\n      guideLine.remove();\n      guidePoint.remove();\n      guidePoint.visible = false;\n      guideLine.visible = false;\n      (_itemIndicator = itemIndicator) === null || _itemIndicator === void 0 || _itemIndicator.remove();\n      if (itemIndicator) itemIndicator.visible = false;\n      resetAnchorColor();\n    };\n    removeGuides();\n    if (!event.modifiers.shift && this.mode !== Modes.RESHAPE) {\n      const paintLayer = getLayer(\"isPaintingLayer\");\n      const snapPoints = createSnapPoints(paper, selectionBounds, lib, paintLayer.children);\n      const fromPoints = snapPoints.from;\n      const toPoints = snapPoints.to;\n      const configDefFn = pointDef => {\n        if (!pointDef.clamp) pointDef.clamp = {\n          min: -Infinity,\n          max: Infinity\n        };\n        if (pointDef.type === \"point\") return () => pointDef.value;\n        if (pointDef.type === \"xcoord\" || pointDef.type === \"itemSideVert\") return point => new paper.Point(pointDef.value, Math.min(Math.max(point.y, pointDef.clamp.min), pointDef.clamp.max));\n        if (pointDef.type === \"ycoord\" || pointDef.type === \"itemSideHoriz\") return point => new paper.Point(Math.min(Math.max(point.x, pointDef.clamp.min), pointDef.clamp.max), pointDef.value);\n        if (pointDef.type === \"generator\") return pointDef.value;\n      };\n      const generateSnapPointsFor = point => Object.fromEntries(Object.entries(toPoints).map(_ref => {\n        let [k, v] = _ref;\n        return [k, {\n          type: v.type,\n          point: configDefFn(v)(point)\n        }];\n      }));\n      const generatedSnapPoints = Object.entries(fromPoints).map(_ref2 => {\n        let [pointPos, point] = _ref2;\n        return {\n          pointPos,\n          origPoint: point,\n          point: point.add(dragVector),\n          snapPoints: generateSnapPointsFor(point.add(dragVector))\n        };\n      });\n      const priority = [\"point\", \"itemSideVert\", \"itemSideHoriz\", \"xcoord\", \"ycoord\", \"generated\", undefined];\n      const sortByPrioOrDist = (a, b) => {\n        const prioDiff = priority.indexOf(a.snapPointType) - priority.indexOf(b.snapPointType);\n        if (prioDiff) return prioDiff;\n        return a.distance - b.distance;\n      };\n      const closestSnapForEachPoint = generatedSnapPoints.map(_ref3 => {\n        var _snapPoints$closestSn, _snapPoints$closestSn2;\n        let {\n          point,\n          origPoint,\n          snapPoints\n        } = _ref3;\n        const snappablePoints = Object.entries(snapPoints).filter(_ref4 => {\n          let [pos, snapPoint] = _ref4;\n          return checkPointsClose(point, snapPoint.point, scaledThreshold);\n        }).map(_ref5 => {\n          let [pos, snapPoint] = _ref5;\n          return {\n            pos,\n            distance: getDist(snapPoint.point, point),\n            snapPointType: snapPoint.type\n          };\n        });\n        const closestSnapPoint = snappablePoints.sort(sortByPrioOrDist)[0] || {\n          pos: \"\",\n          distance: Infinity\n        };\n        return {\n          point: origPoint,\n          snapPoint: (_snapPoints$closestSn = snapPoints[closestSnapPoint.pos]) === null || _snapPoints$closestSn === void 0 ? void 0 : _snapPoints$closestSn.point,\n          snapPointType: (_snapPoints$closestSn2 = snapPoints[closestSnapPoint.pos]) === null || _snapPoints$closestSn2 === void 0 ? void 0 : _snapPoints$closestSn2.type,\n          distance: closestSnapPoint.distance,\n          pos: closestSnapPoint.pos\n        };\n      }).sort(sortByPrioOrDist);\n      const closestSnapPoint = closestSnapForEachPoint.sort(sortByPrioOrDist)[0];\n      removeGuides();\n      if (closestSnapPoint !== null && closestSnapPoint !== void 0 && closestSnapPoint.snapPoint) {\n        var _closestSnapPoint$pos;\n        fixGuideSizes();\n        snapVector = closestSnapPoint.snapPoint.subtract(closestSnapPoint.point);\n        const itemID = (_closestSnapPoint$pos = closestSnapPoint.pos.match(/item_(\\d+)_/)) === null || _closestSnapPoint$pos === void 0 ? void 0 : _closestSnapPoint$pos[1];\n        if (itemID) {\n          const item = paper.project.getItem({\n            id: parseInt(itemID, 10)\n          });\n          if (item) {\n            itemIndicator = hoverBounds(item);\n          }\n        }\n        if (closestSnapPoint.point.equals(this.selectionCenter) && closestSnapPoint.snapPointType === \"point\") {\n          selectionAnchor.fillColor = selectionAnchor.strokeColor = new paper.Color(guideColor);\n        } else {\n          resetAnchorColor();\n          switch (closestSnapPoint.snapPointType) {\n            case \"point\":\n              {\n                guidePoint.visible = true;\n                guidePoint.position = closestSnapPoint.snapPoint;\n                guidePoint.bringToFront();\n                break;\n              }\n            case \"xcoord\":\n            case \"itemSideVert\":\n              {\n                guideLine.firstSegment.point = new paper.Point(closestSnapPoint.snapPoint.x, actionBounds.top);\n                guideLine.lastSegment.point = new paper.Point(closestSnapPoint.snapPoint.x, actionBounds.bottom);\n                guideLine.visible = true;\n                guideLine.bringToFront();\n                break;\n              }\n            case \"ycoord\":\n            case \"itemSideHoriz\":\n              {\n                guideLine.firstSegment.point = new paper.Point(actionBounds.left, closestSnapPoint.snapPoint.y);\n                guideLine.lastSegment.point = new paper.Point(actionBounds.right, closestSnapPoint.snapPoint.y);\n                guideLine.visible = true;\n                guideLine.bringToFront();\n                break;\n              }\n          }\n        }\n      }\n    }\n    let bounds;\n    for (const item of this.selectedItems) {\n      // add the position of the item before the drag started\n      // for later use in the snap calculation\n      if (!item.data.origPos) {\n        item.data.origPos = item.position;\n      }\n      if (snapVector) {\n        item.position = item.data.origPos.add(snapVector);\n      } else if (event.modifiers.shift) {\n        item.position = item.data.origPos.add(snapDeltaToAngle(dragVector, Math.PI / 4));\n      } else {\n        item.position = item.data.origPos.add(dragVector);\n      }\n      if (bounds) {\n        bounds = bounds.unite(item.bounds);\n      } else {\n        bounds = item.bounds;\n      }\n    }\n    if (this.firstDrag) {\n      // Show the center crosshair above the selected item while dragging.\n      getDragCrosshairLayer().visible = true;\n      this.firstDrag = false;\n    }\n\n    // The rotation center crosshair should be opaque over the entire selection bounding box, and fade out to\n    // totally transparent outside the selection bounding box.\n    let opacityMultiplier = 1;\n    if (CENTER.y < bounds.top && CENTER.x < bounds.left || CENTER.y > bounds.bottom && CENTER.x < bounds.left || CENTER.y < bounds.top && CENTER.x > bounds.right || CENTER.y > bounds.bottom && CENTER.x > bounds.right) {\n      // rotation center is to one of the 4 corners of the selection bounding box\n      const distX = Math.max(CENTER.x - bounds.right, bounds.left - CENTER.x);\n      const distY = Math.max(CENTER.y - bounds.bottom, bounds.top - CENTER.y);\n      const dist = Math.sqrt(distX * distX + distY * distY);\n      opacityMultiplier = Math.max(0, 1 - dist / (FADE_DISTANCE / paper.view.zoom));\n    } else if (CENTER.y < bounds.top || CENTER.y > bounds.bottom) {\n      // rotation center is above or below the selection bounding box\n      opacityMultiplier = Math.max(0, 1 - (Math.abs(CENTER.y - newCenter.y) - bounds.height / 2) / (FADE_DISTANCE / paper.view.zoom));\n    } else if (CENTER.x < bounds.left || CENTER.x > bounds.right) {\n      // rotation center is left or right of the selection bounding box\n      opacityMultiplier = Math.max(0, 1 - (Math.abs(CENTER.x - newCenter.x) - bounds.width / 2) / (FADE_DISTANCE / paper.view.zoom));\n    } // else the rotation center is within selection bounds, always show drag crosshair at full opacity\n    getDragCrosshairLayer().opacity = CROSSHAIR_FULL_OPACITY * opacityMultiplier;\n  }\n  const oldMouseDrag = moveTool.constructor.prototype.onMouseDrag;\n  moveTool.constructor.prototype.onMouseDrag = onMouseDrag;\n  const oldMouseDown = moveTool.constructor.prototype.onMouseDown;\n  moveTool.constructor.prototype.onMouseDown = function () {\n    if (snapOn) moveTool.constructor.prototype.onMouseDrag = onMouseDrag;else moveTool.constructor.prototype.onMouseDrag = oldMouseDrag;\n    for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {\n      a[_key] = arguments[_key];\n    }\n    oldMouseDown.apply(this, a);\n  };\n  const oldMouseUp = moveTool.constructor.prototype.onMouseUp;\n  moveTool.constructor.prototype.onMouseUp = function () {\n    var _removeGuides;\n    (_removeGuides = removeGuides) === null || _removeGuides === void 0 || _removeGuides();\n    for (var _len2 = arguments.length, a = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      a[_key2] = arguments[_key2];\n    }\n    oldMouseUp.apply(this, a);\n  };\n};\nconst isSelectTool = tool => {\n  return \"selectionBoxTool\" in tool && \"boundingBoxTool\" in tool;\n};\n// CONCATENATED MODULE: ./node_modules/scratch-gui/src/addons/addons/paint-snap/ui.js\n\n\n/** @type {import(\"../../addon-api/content-script/typedef\").UserscriptUtilities} */\nfunction initUI(_ref) {\n  let {\n    addon,\n    msg\n  } = _ref;\n  const createGroup = () => {\n    const el = document.createElement(\"div\");\n    el.className = \"sa-paint-snap-group\";\n    return el;\n  };\n  const createSeparator = () => {\n    const el = document.createElement(\"div\");\n    el.className = \"sa-paint-snap-settings-separator\";\n    return el;\n  };\n  const createButton = function createButton() {\n    let {\n      useButtonTag\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const el = document.createElement(useButtonTag ? \"button\" : \"span\");\n    el.className = \"sa-paint-snap-button\";\n    el.setAttribute(\"role\", \"button\");\n    return el;\n  };\n  const createButtonImage = name => {\n    const el = document.createElement(\"img\");\n    el.className = \"sa-paint-snap-image\";\n    el.draggable = false;\n    el.src = addon.self.getResource(\"/icons/\" + name + \".svg\") /* rewritten by pull.js */;\n    return el;\n  };\n  const controlsGroup = createGroup();\n  addon.tab.displayNoneWhileDisabled(controlsGroup, {\n    display: \"flex\"\n  });\n  const settingPageWrapper = document.createElement(\"div\");\n  settingPageWrapper.className = \"sa-paint-snap-settings-wrapper\";\n  controlsGroup.appendChild(settingPageWrapper);\n  const settingsPage = document.createElement(\"div\");\n  settingsPage.className = \"sa-paint-snap-settings\";\n  settingPageWrapper.appendChild(settingsPage);\n\n  //todo msg\n  const SVG_NS = \"http://www.w3.org/2000/svg\";\n  const settingsTip = document.createElementNS(SVG_NS, \"svg\");\n  settingsTip.setAttribute(\"class\", \"sa-paint-snap-settings-tip\");\n  settingsTip.setAttribute(\"width\", \"14\");\n  settingsTip.setAttribute(\"height\", \"7\");\n  const settingsTipShape = document.createElementNS(SVG_NS, \"polygon\");\n  settingsTipShape.setAttribute(\"class\", \"sa-paint-snap-settings-polygon\");\n  settingsTipShape.setAttribute(\"points\", \"0,0 7,7, 14,0\");\n  settingsTip.appendChild(settingsTipShape);\n  settingsPage.appendChild(settingsTip);\n  const toggleButton = createButton();\n  toggleButton.addEventListener(\"click\", () => {\n    if (!snapOn) {\n      if (!Object.values(snapTo).some(e => e)) {\n        setSnapTo(\"pageCenter\", true);\n      }\n      if (!Object.values(snapFrom).some(e => e)) {\n        setSnapFrom(\"boxCenter\", true);\n      }\n    }\n    toggle(!snapOn);\n    toggleButton.dataset.enabled = snapOn;\n  });\n  toggleButton.title = msg(\"toggle\");\n  toggleButton.appendChild(createButtonImage(\"snap\"));\n  toggleButton.dataset.enabled = snapOn;\n  controlsGroup.appendChild(toggleButton);\n  const settingButton = createButton();\n  settingButton.addEventListener(\"click\", () => setSettingsOpen(!areSettingsOpen()));\n  settingButton.title = msg(\"settings\");\n  settingButton.appendChild(createButtonImage(\"settings\"));\n  controlsGroup.appendChild(settingButton);\n  document.body.addEventListener(\"click\", e => {\n    if (areSettingsOpen() && !e.target.matches(\".sa-paint-snap-group *\")) setSettingsOpen(false);\n  });\n  const settingsOpenUpdaters = [];\n  const setSettingsOpen = open => {\n    settingButton.dataset.enabled = open;\n    settingsPage.dataset.visible = open;\n    if (open) settingsOpenUpdaters.forEach(f => {\n      try {\n        f === null || f === void 0 || f();\n      } catch (_unused) {}\n    });else if (Object.values(snapFrom).every(e => !e) || Object.values(snapTo).every(e => !e)) {\n      toggle(false);\n      toggleButton.dataset.enabled = false;\n    }\n  };\n  const areSettingsOpen = () => settingsPage.dataset.visible === \"true\";\n  const createToggle = function createToggle(button1Text, button2Text, defaultValue) {\n    let onChange = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => {};\n    const values = [button1Text, button2Text];\n    const group = createGroup();\n    const button1 = createButton({\n      useButtonTag: true\n    });\n    const button2 = createButton({\n      useButtonTag: true\n    });\n    const icon1 = createButtonImage(button1Text);\n    const icon2 = createButtonImage(button2Text);\n    icon1.dataset.shrink = icon2.dataset.shrink = true;\n    button1.appendChild(icon1);\n    button2.appendChild(icon2);\n    button1.setAttribute(\"aria-label\", button1.title = msg(button1Text));\n    button2.setAttribute(\"aria-label\", button2.title = msg(button2Text));\n    const setSelectedButton = function setSelectedButton(button, e) {\n      let suppress = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      button1.dataset.enabled = !!button;\n      button2.dataset.enabled = !button;\n      if (!suppress) onChange(values[button]);\n    };\n    setSelectedButton(1 - values.indexOf(defaultValue), null, true);\n    button1.addEventListener(\"click\", setSelectedButton.bind(button1, 1));\n    button2.addEventListener(\"click\", setSelectedButton.bind(button2, 0));\n    group.append(button1, button2);\n    return group;\n  };\n  const createNumberInput = function createNumberInput(defaultValue) {\n    let onChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n    let min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -Infinity;\n    let max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n    let step = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    const group = createGroup();\n    const filler = document.createElement(\"div\");\n    filler.style.width = \"20px\";\n    const valueButton = createButton();\n    valueButton.appendChild(filler);\n    const valueInput = document.createElement(\"input\");\n    valueInput.className = \"sa-paint-snap-settings-input\";\n    valueInput.type = \"number\";\n    valueInput.step = step;\n    valueInput.min = min;\n    valueInput.max = max;\n    valueInput.value = defaultValue;\n    valueInput.addEventListener(\"change\", () => {\n      if (valueInput.value > max) valueInput.value = max;\n      if (valueInput.value < min) valueInput.value = min;\n      onChange(valueInput.value);\n    });\n    valueInput.addEventListener(\"blur\", () => {\n      if (!valueInput.value) valueInput.value = \"0\";\n    });\n    valueButton.appendChild(valueInput);\n    const decrementButton = createButton();\n    decrementButton.appendChild(createButtonImage(\"decrement\"));\n    decrementButton.addEventListener(\"click\", () => {\n      if (valueInput.value > min) {\n        valueInput.value = Number(valueInput.value) - 1;\n        onChange(Number(valueInput.value) + 1);\n      }\n    });\n    const incrementButton = createButton();\n    incrementButton.appendChild(createButtonImage(\"increment\"));\n    incrementButton.addEventListener(\"click\", () => {\n      if (valueInput.value < max) {\n        valueInput.value = Number(valueInput.value) + 1;\n        onChange(Number(valueInput.value) + 1);\n      }\n    });\n    group.append(decrementButton, valueButton, incrementButton);\n    return group;\n  };\n  const createSettingWithLabel = (settingId, settingElem) => {\n    const container = document.createElement(\"label\");\n    container.className = \"sa-paint-snap-settings-line\";\n    const labelElem = document.createElement(\"div\");\n    labelElem.className = \"sa-paint-snap-settings-label\";\n    labelElem.textContent = msg(settingId);\n    container.append(labelElem, settingElem);\n    settingsOpenUpdaters.push(() => {\n      const onBtn = settingElem.querySelector(\"[aria-label=\\\"\".concat(msg(\"on\"), \"\\\"]\"));\n      const offBtn = settingElem.querySelector(\"[aria-label=\\\"\".concat(msg(\"off\"), \"\\\"]\"));\n      if (settingId in snapTo) {\n        onBtn.dataset.enabled = !!snapTo[settingId];\n        offBtn.dataset.enabled = !snapTo[settingId];\n      }\n      if (settingId in snapFrom) {\n        onBtn.dataset.enabled = !!snapFrom[settingId];\n        offBtn.dataset.enabled = !snapFrom[settingId];\n      }\n    });\n    return container;\n  };\n  const createSection = function createSection(title) {\n    const sectionContainer = document.createElement(\"div\");\n    sectionContainer.className = \"sa-paint-snap-settings-section\";\n    const titleElem = document.createElement(\"span\");\n    titleElem.appendChild(document.createTextNode(title));\n    titleElem.className = \"sa-paint-snap-settings-section-title\";\n    sectionContainer.appendChild(titleElem);\n    for (var _len = arguments.length, settingElems = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      settingElems[_key - 1] = arguments[_key];\n    }\n    sectionContainer.append(...settingElems);\n    return sectionContainer;\n  };\n  const threshSetting = createSettingWithLabel(\"threshold\", createNumberInput(threshold, value => {\n    setThreshold(value);\n  }, 4, 50, 1));\n  const toOnOff = bool => bool ? \"on\" : \"off\";\n  const toBool = onOff => !![\"on\", \"off\"].indexOf(onOff);\n  const toggleParams = function toggleParams(defaultValue) {\n    let onChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n    return [\"off\", \"on\", toOnOff(defaultValue), value => onChange(toBool(value))];\n  };\n  const createSnapToSetting = forPoint => createSettingWithLabel(forPoint, createToggle(...toggleParams(snapTo[forPoint], enabled => {\n    toggle(true);\n    toggleButton.dataset.enabled = true;\n    setSnapTo(forPoint, enabled);\n  })));\n  const snapToSection = createSection(msg(\"snapTo\"), createSnapToSetting(\"pageCenter\"), createSnapToSetting(\"pageAxes\"), createSnapToSetting(\"pageEdges\"), createSnapToSetting(\"pageCorners\"), createSnapToSetting(\"objectCenters\"), createSnapToSetting(\"objectMidlines\"), createSnapToSetting(\"objectEdges\"), createSnapToSetting(\"objectCorners\"));\n  const createSnapFromSetting = forPoint => createSettingWithLabel(forPoint, createToggle(...toggleParams(snapFrom[forPoint], enabled => {\n    setSnapFrom(forPoint, enabled);\n  })));\n  const snapFromSection = createSection(msg(\"snapFrom\"), createSnapFromSetting(\"boxCenter\"), createSnapFromSetting(\"boxCorners\"), createSnapFromSetting(\"boxEdgeMids\"));\n  settingsPage.append(threshSetting, createSeparator(), snapToSection, createSeparator(), snapFromSection);\n  const controlsLoop = async () => {\n    let hasRunOnce = false;\n    while (true) {\n      const canvasControls = await addon.tab.waitForElement(\"[class^='paint-editor_canvas-controls']\", {\n        markAsSeen: true,\n        reduxEvents: [\"scratch-gui/navigation/ACTIVATE_TAB\", \"scratch-gui/mode/SET_PLAYER\", \"fontsLoaded/SET_FONTS_LOADED\", \"scratch-gui/locales/SELECT_LOCALE\", \"scratch-gui/targets/UPDATE_TARGET_LIST\"],\n        reduxCondition: state => state.scratchGui.editorTab.activeTabIndex === 1 && !state.scratchGui.mode.isPlayerOnly\n      });\n      const zoomControlsContainer = canvasControls.querySelector(\"[class^='paint-editor_zoom-controls']\");\n      addon.tab.appendToSharedSpace({\n        space: \"paintEditorZoomControls\",\n        element: controlsGroup,\n        order: 2\n      });\n      if (!hasRunOnce) {\n        hasRunOnce = true;\n        const groupClass = zoomControlsContainer.firstChild.className;\n        const buttonClass = zoomControlsContainer.firstChild.firstChild.className;\n        const imageClass = zoomControlsContainer.firstChild.firstChild.firstChild.className;\n        for (const el of document.querySelectorAll(\".sa-paint-snap-group\")) {\n          el.className += \" \" + groupClass;\n        }\n        for (const el of document.querySelectorAll(\".sa-paint-snap-button\")) {\n          el.className += \" \" + buttonClass;\n        }\n        for (const el of document.querySelectorAll(\".sa-paint-snap-image\")) {\n          el.className += \" \" + imageClass;\n        }\n      }\n    }\n  };\n  controlsLoop();\n}\n// CONCATENATED MODULE: ./node_modules/scratch-gui/src/addons/addons/paint-snap/genScalePoints.js\nfunction genScalePoints_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction genScalePoints_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? genScalePoints_ownKeys(Object(t), !0).forEach(function (r) { genScalePoints_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : genScalePoints_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction genScalePoints_defineProperty(e, r, t) { return (r = genScalePoints_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction genScalePoints_toPropertyKey(t) { var i = genScalePoints_toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction genScalePoints_toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nfunction createScalePoints(paper, lib, objects, sx, sy) {\n  const {\n    view: {\n      CENTER,\n      ART_BOARD_BOUNDS\n    }\n  } = lib;\n  const toPoints = genScalePoints_objectSpread(genScalePoints_objectSpread(genScalePoints_objectSpread(genScalePoints_objectSpread({}, snapTo.pageAxes ? genScalePoints_objectSpread(genScalePoints_objectSpread({}, sx ? {\n    bounds_cx: {\n      type: \"xcoord\",\n      value: CENTER.x\n    }\n  } : {}), sy ? {\n    bounds_cy: {\n      type: \"ycoord\",\n      value: CENTER.y\n    }\n  } : {}) : {}), snapTo.pageEdges ? genScalePoints_objectSpread(genScalePoints_objectSpread(genScalePoints_objectSpread(genScalePoints_objectSpread({}, sx ? {\n    bounds_l: {\n      type: \"xcoord\",\n      value: ART_BOARD_BOUNDS.left,\n      clamp: {\n        min: ART_BOARD_BOUNDS.top,\n        max: ART_BOARD_BOUNDS.bottom\n      }\n    },\n    bounds_r: {\n      type: \"xcoord\",\n      value: ART_BOARD_BOUNDS.right,\n      clamp: {\n        min: ART_BOARD_BOUNDS.top,\n        max: ART_BOARD_BOUNDS.bottom\n      }\n    }\n  } : {}), sy ? {\n    bounds_t: {\n      type: \"ycoord\",\n      value: ART_BOARD_BOUNDS.top,\n      clamp: {\n        min: ART_BOARD_BOUNDS.left,\n        max: ART_BOARD_BOUNDS.right\n      }\n    },\n    bounds_b: {\n      type: \"ycoord\",\n      value: ART_BOARD_BOUNDS.bottom,\n      clamp: {\n        min: ART_BOARD_BOUNDS.left,\n        max: ART_BOARD_BOUNDS.right\n      }\n    }\n  } : {}), sx ? {\n    bounds_w: {\n      type: \"width\",\n      value: CENTER.y,\n      clamp: {\n        min: ART_BOARD_BOUNDS.left,\n        max: ART_BOARD_BOUNDS.right\n      }\n    }\n  } : {}), sy ? {\n    bounds_h: {\n      type: \"height\",\n      value: CENTER.x,\n      clamp: {\n        min: ART_BOARD_BOUNDS.bottom,\n        max: ART_BOARD_BOUNDS.top\n      }\n    }\n  } : {}) : {}), snapTo.objectEdges ? Object.fromEntries(objects.filter(item => !(item.selected || item.data.isHelperItem || item.locked || item.guide)).map(item => [sx && [\"item_\".concat(item.id, \"_r\"), {\n    type: \"xcoord\",\n    value: item.bounds.right\n  }], sx && [\"item_\".concat(item.id, \"_l\"), {\n    type: \"xcoord\",\n    value: item.bounds.left\n  }], sy && [\"item_\".concat(item.id, \"_t\"), {\n    type: \"ycoord\",\n    value: item.bounds.top\n  }], sy && [\"item_\".concat(item.id, \"_b\"), {\n    type: \"ycoord\",\n    value: item.bounds.bottom\n  }], sx && [\"item_\".concat(item.id, \"_w\"), {\n    type: \"width\",\n    value: item.bounds.bottom,\n    clamp: {\n      min: item.bounds.left,\n      max: item.bounds.right\n    }\n  }], sy && [\"item_\".concat(item.id, \"_h\"), {\n    type: \"height\",\n    value: item.bounds.left,\n    clamp: {\n      min: item.bounds.bottom,\n      max: item.bounds.top\n    }\n  }]].filter(Boolean)).flat(1)) : {}), snapTo.objectMidlines ? Object.fromEntries(objects.filter(item => !(item.selected || item.data.isHelperItem || item.locked || item.guide)).map(item => [sx && [\"item_\".concat(item.id, \"_cx\"), {\n    type: \"xcoord\",\n    value: item.bounds.center.x\n  }], sy && [\"item_\".concat(item.id, \"_cy\"), {\n    type: \"ycoord\",\n    value: item.bounds.center.y\n  }]].filter(Boolean)).flat(1)) : {});\n  return toPoints;\n}\n// EXTERNAL MODULE: ./node_modules/scratch-gui/src/addons/addons/paint-snap/compatibility.js\nvar compatibility = __webpack_require__(1399);\n\n// CONCATENATED MODULE: ./node_modules/scratch-gui/src/addons/addons/paint-snap/updateScaleTool.js\n\n\n\n\nconst getScaleTool = tool => {\n  return tool.boundingBoxTool._modeMap.SCALE;\n};\nconst updateScaleTool = (paper, tool, vm) => {\n  const lib = loadModules(paper, vm);\n  const {\n    view: {\n      getActionBounds\n    },\n    layer: {\n      getLayer\n    }\n  } = lib;\n  const scaleTool = getScaleTool(tool);\n\n  // https://github.com/scratchfoundation/scratch-paint/blob/develop/src/helper/selection-tools/scale-tool.js\n  const MIN_SCALE_FACTOR = 0.0001;\n  const selectionSizeGuide = {\n    endLeft: new paper.Path.Line({\n      from: [0, 0],\n      to: [0, 0],\n      strokeColor: new paper.Color(guideColor),\n      strokeWidth: 1 / paper.view.zoom,\n      visible: true,\n      data: {\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true\n      },\n      selected: false\n    }),\n    endRight: new paper.Path.Line({\n      from: [0, 0],\n      to: [0, 0],\n      strokeColor: new paper.Color(guideColor),\n      strokeWidth: 1 / paper.view.zoom,\n      visible: true,\n      data: {\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true\n      },\n      selected: false\n    }),\n    line: new paper.Path.Line({\n      from: [0, 0],\n      to: [0, 0],\n      strokeColor: new paper.Color(guideColor),\n      strokeWidth: 1 / paper.view.zoom,\n      visible: true,\n      data: {\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true\n      },\n      selected: false\n    }),\n    group: new paper.Group({\n      children: [],\n      visible: false\n    })\n  };\n  const matchingSizeGuide = {\n    endLeft: new paper.Path.Line({\n      from: [0, 0],\n      to: [0, 0],\n      strokeColor: new paper.Color(guideColor),\n      strokeWidth: 1 / paper.view.zoom,\n      visible: true,\n      data: {\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true\n      },\n      selected: false\n    }),\n    endRight: new paper.Path.Line({\n      from: [0, 0],\n      to: [0, 0],\n      strokeColor: new paper.Color(guideColor),\n      strokeWidth: 1 / paper.view.zoom,\n      visible: true,\n      data: {\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true\n      },\n      selected: false\n    }),\n    line: new paper.Path.Line({\n      from: [0, 0],\n      to: [0, 0],\n      strokeColor: new paper.Color(guideColor),\n      strokeWidth: 1 / paper.view.zoom,\n      visible: true,\n      data: {\n        isHelperItem: true,\n        noSelect: true,\n        noHover: true,\n        saPaintSnapGuide: true\n      },\n      selected: false\n    }),\n    group: new paper.Group({\n      children: [],\n      visible: false\n    })\n  };\n  selectionSizeGuide.endLeft.remove();\n  matchingSizeGuide.endLeft.remove();\n  selectionSizeGuide.endRight.remove();\n  matchingSizeGuide.endRight.remove();\n  selectionSizeGuide.line.remove();\n  matchingSizeGuide.line.remove();\n  selectionSizeGuide.group.remove();\n  matchingSizeGuide.group.remove();\n  selectionSizeGuide.group.addChildren([selectionSizeGuide.endLeft, selectionSizeGuide.line, selectionSizeGuide.endRight]);\n  matchingSizeGuide.group.addChildren([matchingSizeGuide.endLeft, matchingSizeGuide.line, matchingSizeGuide.endRight]);\n  let axisLineX = new paper.Path.Line({\n    from: [0, 0],\n    to: [0, 0],\n    strokeColor: new paper.Color(guideColor),\n    strokeWidth: 1 / paper.view.zoom,\n    visible: false,\n    data: {\n      isHelperItem: true,\n      noSelect: true,\n      noHover: true,\n      saPaintSnapGuide: true,\n      axis: \"x\"\n    },\n    selected: false\n  });\n  let axisLineY = new paper.Path.Line({\n    from: [0, 0],\n    to: [0, 0],\n    strokeColor: new paper.Color(guideColor),\n    strokeWidth: 1 / paper.view.zoom,\n    visible: false,\n    data: {\n      isHelperItem: true,\n      noSelect: true,\n      noHover: true,\n      saPaintSnapGuide: true,\n      axis: \"y\"\n    },\n    selected: false\n  });\n  axisLineX.remove();\n  axisLineY.remove();\n  const fixGuideSizes = () => {\n    axisLineX.strokeWidth = 1 / paper.view.zoom;\n    axisLineY.strokeWidth = 1 / paper.view.zoom;\n    axisLineX.strokeColor = new paper.Color(guideColor);\n    axisLineY.strokeColor = new paper.Color(guideColor);\n    selectionSizeGuide.endLeft.strokeWidth = 1 / paper.view.zoom;\n    matchingSizeGuide.endLeft.strokeWidth = 1 / paper.view.zoom;\n    selectionSizeGuide.endRight.strokeWidth = 1 / paper.view.zoom;\n    matchingSizeGuide.endRight.strokeWidth = 1 / paper.view.zoom;\n    selectionSizeGuide.line.strokeWidth = 1 / paper.view.zoom;\n    matchingSizeGuide.line.strokeWidth = 1 / paper.view.zoom;\n    selectionSizeGuide.endLeft.strokeColor = new paper.Color(guideColor);\n    matchingSizeGuide.endLeft.strokeColor = new paper.Color(guideColor);\n    selectionSizeGuide.endRight.strokeColor = new paper.Color(guideColor);\n    matchingSizeGuide.endRight.strokeColor = new paper.Color(guideColor);\n    selectionSizeGuide.line.strokeColor = new paper.Color(guideColor);\n    matchingSizeGuide.line.strokeColor = new paper.Color(guideColor);\n    axisLineX.bringToFront();\n    axisLineY.bringToFront();\n    getLayer(\"isGuideLayer\").addChildren([axisLineY, axisLineX, selectionSizeGuide.group, matchingSizeGuide.group]);\n  };\n  const priority = [\"width\", \"height\", \"itemSideVert\", \"itemSideHoriz\", \"xcoord\", \"ycoord\", \"generated\", undefined];\n  const removeGuides = () => {\n    selectionSizeGuide.group.remove();\n    selectionSizeGuide.group.visible = false;\n    matchingSizeGuide.group.remove();\n    matchingSizeGuide.group.visible = false;\n    axisLineX.remove();\n    axisLineX.visible = false;\n    axisLineY.remove();\n    axisLineY.visible = false;\n  };\n  compatibility[\"a\" /* addons */].paintSnap = function (event) {\n    if (!this.active) return;\n    const point = event.point;\n    const bounds = getActionBounds(this.isBitmap);\n    point.x = Math.max(bounds.left, Math.min(point.x, bounds.right));\n    point.y = Math.max(bounds.top, Math.min(point.y, bounds.bottom));\n    if (!this.lastPoint) this.lastPoint = event.lastPoint;\n    const delta = point.subtract(this.lastPoint);\n    this.lastPoint = point;\n    if (event.modifiers.alt) {\n      this.centered = true;\n      this.itemGroup.position = this.origCenter;\n      this.pivot = this.origCenter;\n    } else {\n      if (this.centered) {\n        // Reset position if we were just in alt\n        this.centered = false;\n        this.itemGroup.scale(1 / this.lastSx, 1 / this.lastSy, this.pivot);\n        if (this.selectionAnchor) {\n          this.selectionAnchor.scale(this.lastSx, this.lastSy);\n        }\n        this.lastSx = 1;\n        this.lastSy = 1;\n      }\n      this.pivot = this.origPivot;\n    }\n    this.corner = this.corner.add(delta);\n    let size = this.corner.subtract(this.pivot);\n    if (event.modifiers.alt) {\n      size = size.multiply(2);\n    }\n    let sx = 1.0;\n    let sy = 1.0;\n    if (Math.abs(this.origSize.x) > 0.0000001) {\n      sx = size.x / this.origSize.x;\n    }\n    if (Math.abs(this.origSize.y) > 0.0000001) {\n      sy = size.y / this.origSize.y;\n    }\n    const sortByPrioOrDist = (a, b) => {\n      const prioDiff = priority.indexOf(a.type) - priority.indexOf(b.type);\n      if (prioDiff) return prioDiff;\n      return a.distance - b.distance;\n    };\n    const paintLayer = getLayer(\"isPaintingLayer\");\n    const doesSx = snapOn && (this.isCorner && !event.modifiers.shift || Math.abs(this.origSize.x) > 0.0000001);\n    const doesSy = snapOn && (this.isCorner && !event.modifiers.shift || Math.abs(this.origSize.y) > 0.0000001);\n    const scaledThreshold = threshold / paper.view.zoom;\n    const canSnap = coord => coord.distance < scaledThreshold;\n    const format = _ref => {\n      let [coordName, coord] = _ref;\n      return {\n        type: coord.type,\n        distance: (() => {\n          switch (coord.type) {\n            case \"width\":\n              {\n                return Math.abs(Math.abs(size.x) - Math.abs(coord.clamp.max - coord.clamp.min));\n              }\n            case \"height\":\n              {\n                return Math.abs(Math.abs(size.y) - Math.abs(coord.clamp.max - coord.clamp.min));\n              }\n            case \"xcoord\":\n            case \"itemSideVert\":\n              {\n                return Math.abs(this.corner.x - coord.value);\n              }\n            case \"ycoord\":\n            case \"itemSideHoriz\":\n              {\n                return Math.abs(this.corner.y - coord.value);\n              }\n            default:\n              break;\n          }\n        })(),\n        name: coordName,\n        coord: coord\n      };\n    };\n    const snapXCoords = createScalePoints(paper, lib, paintLayer.children, doesSx, false);\n    const canSnapXCoords = Object.entries(snapXCoords).map(format).filter(canSnap).sort(sortByPrioOrDist);\n    const snapYCoords = createScalePoints(paper, lib, paintLayer.children, false, doesSy);\n    const canSnapYCoords = Object.entries(snapYCoords).map(format).filter(canSnap).sort(sortByPrioOrDist);\n    const closestSnapX = canSnapXCoords[0];\n    const closestSnapY = canSnapYCoords[0];\n    const signx = sx > 0 ? 1 : -1;\n    const signy = sy > 0 ? 1 : -1;\n    // TODO: show correct guides\n    if (closestSnapX) {\n      switch (closestSnapX.type) {\n        case \"width\":\n          {\n            const newSize = new paper.Point(Math.abs(closestSnapX.coord.clamp.max - closestSnapX.coord.clamp.min), this.corner.y);\n            sx = newSize.x / this.origSize.x;\n            break;\n          }\n        case \"xcoord\":\n        case \"itemSideVert\":\n          {\n            const newSize = new paper.Point(closestSnapX.coord.value, this.corner.y).subtract(this.pivot);\n            sx = newSize.x / this.origSize.x;\n            if (event.modifiers.alt) sx *= 2;\n            break;\n          }\n        default:\n          break;\n      }\n    }\n    if (closestSnapY) {\n      switch (closestSnapY.type) {\n        case \"height\":\n          {\n            const newSize = new paper.Point(this.corner.x, Math.abs(closestSnapY.coord.clamp.max - closestSnapY.coord.clamp.min));\n            sy = newSize.y / this.origSize.y;\n            break;\n          }\n        case \"ycoord\":\n        case \"itemSideHoriz\":\n          {\n            const newSize = new paper.Point(this.corner.x, closestSnapY.coord.value).subtract(this.pivot);\n            sy = newSize.y / this.origSize.y;\n            if (event.modifiers.alt) sy *= 2;\n            break;\n          }\n        default:\n          break;\n      }\n    }\n    const oldSX = sx;\n    const oldSY = sy;\n    if (this.isCorner && !event.modifiers.shift) {\n      sx = sy = Math.max(Math.abs(sx), Math.abs(sy));\n      sx *= signx;\n      sy *= signy;\n    }\n    sx = signx * Math.max(Math.abs(sx), MIN_SCALE_FACTOR);\n    sy = signy * Math.max(Math.abs(sy), MIN_SCALE_FACTOR);\n    this.itemGroup.scale(sx / this.lastSx, sy / this.lastSy, this.pivot);\n    if (this.selectionAnchor) {\n      this.selectionAnchor.scale(this.lastSx / sx, this.lastSy / sy);\n    }\n    removeGuides();\n    if (Math.abs(oldSX) === Math.abs(sx) && closestSnapX || Math.abs(oldSY) === Math.abs(sy) && closestSnapY) fixGuideSizes();\n    if (Math.abs(oldSX) === Math.abs(sx) && closestSnapX) {\n      switch (closestSnapX.type) {\n        case \"width\":\n          {\n            const matchy = closestSnapX.coord.value;\n            const selectiony = this.itemGroup.bounds.bottom;\n            matchingSizeGuide.endLeft.firstSegment.point = new paper.Point(closestSnapX.coord.clamp.min, matchy);\n            matchingSizeGuide.endLeft.lastSegment.point = new paper.Point(closestSnapX.coord.clamp.min, matchy + 5 / paper.view.zoom);\n            matchingSizeGuide.endRight.firstSegment.point = new paper.Point(closestSnapX.coord.clamp.max, matchy);\n            matchingSizeGuide.endRight.lastSegment.point = new paper.Point(closestSnapX.coord.clamp.max, matchy + 5 / paper.view.zoom);\n            matchingSizeGuide.line.firstSegment.point = new paper.Point(closestSnapX.coord.clamp.min, matchy + 3 / paper.view.zoom);\n            matchingSizeGuide.line.lastSegment.point = new paper.Point(closestSnapX.coord.clamp.max, matchy + 3 / paper.view.zoom);\n            matchingSizeGuide.group.visible = true;\n            matchingSizeGuide.group.bringToFront();\n            selectionSizeGuide.endLeft.firstSegment.point = new paper.Point(this.itemGroup.bounds.left, selectiony + 2 / paper.view.zoom);\n            selectionSizeGuide.endLeft.lastSegment.point = new paper.Point(this.itemGroup.bounds.left, selectiony + 7 / paper.view.zoom);\n            selectionSizeGuide.endRight.firstSegment.point = new paper.Point(this.itemGroup.bounds.right, selectiony + 2 / paper.view.zoom);\n            selectionSizeGuide.endRight.lastSegment.point = new paper.Point(this.itemGroup.bounds.right, selectiony + 7 / paper.view.zoom);\n            selectionSizeGuide.line.firstSegment.point = new paper.Point(this.itemGroup.bounds.left, selectiony + 4.5 / paper.view.zoom);\n            selectionSizeGuide.line.lastSegment.point = new paper.Point(this.itemGroup.bounds.right, selectiony + 4.5 / paper.view.zoom);\n            selectionSizeGuide.group.visible = true;\n            selectionSizeGuide.group.bringToFront();\n            break;\n          }\n        case \"xcoord\":\n        case \"itemSideVert\":\n          {\n            axisLineX.firstSegment.point = new paper.Point(closestSnapX.coord.value, bounds.top);\n            axisLineX.lastSegment.point = new paper.Point(closestSnapX.coord.value, bounds.bottom);\n            axisLineX.visible = true;\n            axisLineX.bringToFront();\n            break;\n          }\n        default:\n          break;\n      }\n    }\n    if (Math.abs(oldSY) === Math.abs(sy) && closestSnapY) {\n      switch (closestSnapY.type) {\n        case \"height\":\n          {\n            const matchx = closestSnapY.coord.value;\n            const selectionx = this.itemGroup.bounds.left;\n            matchingSizeGuide.endLeft.firstSegment.point = new paper.Point(matchx, closestSnapY.coord.clamp.min);\n            matchingSizeGuide.endLeft.lastSegment.point = new paper.Point(matchx - 5 / paper.view.zoom, closestSnapY.coord.clamp.min);\n            matchingSizeGuide.endRight.firstSegment.point = new paper.Point(matchx, closestSnapY.coord.clamp.max);\n            matchingSizeGuide.endRight.lastSegment.point = new paper.Point(matchx - 5 / paper.view.zoom, closestSnapY.coord.clamp.max);\n            matchingSizeGuide.line.firstSegment.point = new paper.Point(matchx - 3 / paper.view.zoom, closestSnapY.coord.clamp.min);\n            matchingSizeGuide.line.lastSegment.point = new paper.Point(matchx - 3 / paper.view.zoom, closestSnapY.coord.clamp.max);\n            matchingSizeGuide.group.visible = true;\n            matchingSizeGuide.group.bringToFront();\n            selectionSizeGuide.endLeft.firstSegment.point = new paper.Point(selectionx - 2 / paper.view.zoom, this.itemGroup.bounds.top);\n            selectionSizeGuide.endLeft.lastSegment.point = new paper.Point(selectionx - 7 / paper.view.zoom, this.itemGroup.bounds.top);\n            selectionSizeGuide.endRight.firstSegment.point = new paper.Point(selectionx - 2 / paper.view.zoom, this.itemGroup.bounds.bottom);\n            selectionSizeGuide.endRight.lastSegment.point = new paper.Point(selectionx - 7 / paper.view.zoom, this.itemGroup.bounds.bottom);\n            selectionSizeGuide.line.firstSegment.point = new paper.Point(selectionx - 4.5 / paper.view.zoom, this.itemGroup.bounds.top);\n            selectionSizeGuide.line.lastSegment.point = new paper.Point(selectionx - 4.5 / paper.view.zoom, this.itemGroup.bounds.bottom);\n            selectionSizeGuide.group.visible = true;\n            selectionSizeGuide.group.bringToFront();\n            break;\n          }\n        case \"ycoord\":\n        case \"itemSideHoriz\":\n          {\n            axisLineY.firstSegment.point = new paper.Point(bounds.left, closestSnapY.coord.value);\n            axisLineY.lastSegment.point = new paper.Point(bounds.right, closestSnapY.coord.value);\n            axisLineY.visible = true;\n            axisLineY.bringToFront();\n            break;\n          }\n        default:\n          break;\n      }\n    }\n    this.lastSx = sx;\n    this.lastSy = sy;\n  };\n  Object(compatibility[\"b\" /* initialize */])(paper, scaleTool.constructor);\n  const oldMouseUp = scaleTool.constructor.prototype.onMouseUp;\n  scaleTool.constructor.prototype.onMouseUp = function () {\n    removeGuides();\n    oldMouseUp.call(this);\n  };\n};\n// CONCATENATED MODULE: ./node_modules/scratch-gui/src/addons/addons/paint-snap/userscript.js\n\n\n\n\n\n/** @type {(api: import(\"../../addon-api/content-script/typedef\").UserscriptUtilities) => Promise<void>} */\n/* harmony default export */ var userscript = (async function (api) {\n  const {\n    addon\n  } = api;\n  addon.self.addEventListener(\"disabled\", disable);\n  addon.self.addEventListener(\"reenabled\", enable);\n  loadSettings(addon);\n  const paper = await addon.tab.traps.getPaper();\n  const [tool] = paper.tools;\n  toggle(addon.settings.get(\"enable-default\"));\n  setGuideColor(addon.settings.get(\"guide-color\"));\n  addon.settings.addEventListener(\"change\", () => setGuideColor(addon.settings.get(\"guide-color\")));\n  if (isSelectTool(tool)) {\n    updateSelectTool(paper, tool, addon.tab.traps.vm);\n    updateScaleTool(paper, tool, addon.tab.traps.vm);\n  }\n  initUI(api);\n});\n// EXTERNAL MODULE: ./node_modules/css-loader!./node_modules/scratch-gui/src/addons/addons/paint-snap/userstyle.css\nvar userstyle = __webpack_require__(1476);\nvar userstyle_default = /*#__PURE__*/__webpack_require__.n(userstyle);\n\n// CONCATENATED MODULE: ./node_modules/url-loader/dist/cjs.js!./node_modules/scratch-gui/src/addons/addons/paint-snap/icons/decrement.svg\n/* harmony default export */ var decrement = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCI+PHBhdGggc3R5bGU9ImZpbGw6IzU3NWU3NTtzdHJva2Utd2lkdGg6LjczNDczNiIgZD0iTTMuMjUgMTEuMzU4aDE3LjUwMXYxLjI4NUgzLjI1eiIvPjwvc3ZnPg==\");\n// CONCATENATED MODULE: ./node_modules/url-loader/dist/cjs.js!./node_modules/scratch-gui/src/addons/addons/paint-snap/icons/increment.svg\n/* harmony default export */ var increment = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHdpZHRoPSIyNCI+PHBhdGggc3R5bGU9ImZpbGw6IzU3NWU3NTtzdHJva2Utd2lkdGg6LjczNDczNiIgZD0iTTMuMjUgMTEuMzU4aDE3LjUwMXYxLjI4NUgzLjI1eiIvPjxwYXRoIHRyYW5zZm9ybT0icm90YXRlKDkwKSIgc3R5bGU9ImZpbGw6IzU3NWU3NTtzdHJva2Utd2lkdGg6LjczNDczNiIgZD0iTTMuMjUtMTIuNjQyaDE3LjUwMXYxLjI4NUgzLjI1eiIvPjwvc3ZnPg==\");\n// CONCATENATED MODULE: ./node_modules/url-loader/dist/cjs.js!./node_modules/scratch-gui/src/addons/addons/paint-snap/icons/off.svg\n/* harmony default export */ var off = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgMTYgMTYiPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzU3NWU3NSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEuNSIgZD0ibTExLjI1IDQuNzUtNi41IDYuNW0wLTYuNSA2LjUgNi41Ii8+PC9zdmc+\");\n// CONCATENATED MODULE: ./node_modules/url-loader/dist/cjs.js!./node_modules/scratch-gui/src/addons/addons/paint-snap/icons/on.svg\n/* harmony default export */ var on = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgMTYgMTYiPjxwYXRoIGZpbGw9IiM1NzVlNzUiIGQ9Ik0xMi43MzYgMy45N2EuNzMzLjczMyAwIDAgMSAxLjA0NyAwYy4yODYuMjg5LjI5Ljc1Ni4wMSAxLjA1TDcuODggMTIuMDFhLjczMy43MzMgMCAwIDEtMS4wNjUuMDJMMy4yMTcgOC4zODRhLjc1Ny43NTcgMCAwIDEgMC0xLjA2LjczMy43MzMgMCAwIDEgMS4wNDcgMGwzLjA1MiAzLjA5MyA1LjQtNi40MjVhLjI0Ny4yNDcgMCAwIDEgLjAyLS4wMjJaIi8+PC9zdmc+\");\n// CONCATENATED MODULE: ./node_modules/url-loader/dist/cjs.js!./node_modules/scratch-gui/src/addons/addons/paint-snap/icons/settings.svg\n/* harmony default export */ var settings = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PGNpcmNsZSBjeD0iMTIuNTUiIGN5PSIxMi41NSIgcj0iOS4wNSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNTc1ZTc1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iNyIvPjxjaXJjbGUgY3g9IjYxLjk0MyIgY3k9IjYxLjQzNiIgcj0iNy41IiBmaWxsPSIjNTc1ZTc1Ii8+PHBhdGggZmlsbD0iIzU3NWU3NSIgZD0ibTUzLjExOSAyNy43NDMtOC4yNjcgOC4yNjZMMzEuNjkgMjIuODQ3bC04LjU3IDguNTczIDEzLjE2IDEzLjE2LTguMjY2IDguMjY2aDI1LjEwNXoiIGNvbG9yPSIjNTc1ZTc1Ii8+PHBhdGggZmlsbD0iIzU3NWU3NSIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNDYuMjI3IDEwMGMuNTMtMy4yMDUgMS4yMTktNi4zNzQgMi4xMTItOS40N2wtNC44MDQtMS4zODZjLS45NTQgMy4zMS0xLjY4MyA2LjY2OS0yLjI0IDEwLjA0em0zLjYwMy0xNC4wNjhhNjMuOTM1IDYzLjkzNSAwIDAgMSAzLjkzLTguNzc1bC00LjM5My0yLjM4NmE2OC45MTcgNjguOTE3IDAgMCAwLTQuMjQgOS40NnptNi4zODItMTIuOWMxLjc1My0yLjY5NCAzLjY5LTUuMjQ5IDUuODQtNy41NzhsLTMuNjczLTMuMzkyYy0yLjM3MiAyLjU2OS00LjQ3NCA1LjM1LTYuMzU3IDguMjQxem05LjIzNC0xMC45NDFhNTcuOTUgNTcuOTUgMCAwIDEgNy42MDktNS44MTNsLTIuNzAzLTQuMjA4YTYyLjk0NCA2Mi45NDQgMCAwIDAtOC4yNjYgNi4zMTd6bTExLjc1Mi04LjI2MmE3MS4yNjUgNzEuMjY1IDAgMCAxIDguNzg2LTRsLTEuNzY2LTQuNjc3YTc2LjI0MiA3Ni4yNDIgMCAwIDAtOS40MDEgNC4yODF6bTEzLjM3Mi01LjU3MkE4Ny45MjYgODcuOTI2IDAgMCAxIDEwMCA0NS45MUw5OS4wNTcgNDFhOTIuOTM4IDkyLjkzOCAwIDAgMC05Ljk2NyAyLjQ4eiIgY29sb3I9IiM1NzVlNzUiLz48L3N2Zz4=\");\n// CONCATENATED MODULE: ./node_modules/url-loader/dist/cjs.js!./node_modules/scratch-gui/src/addons/addons/paint-snap/icons/snap.svg\n/* harmony default export */ var snap = (\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxZW0iIGhlaWdodD0iMWVtIiB2aWV3Qm94PSIwIDAgNTEyIDUxMiI+PHBhdGggZmlsbD0iIzU3NWU3NSIgc3Ryb2tlPSIjNTc1ZTc1IiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHN0cm9rZS13aWR0aD0iMzIiIGQ9Ik0xOTEuOTggNDYzLjU4di00OE05MC4xNiA0MjEuNGwzMy45NC0zMy45NG0tNzYuMTItNjcuODhoNDgiLz48cGF0aCBmaWxsPSIjNTc1ZTc1IiBkPSJNNDIyLjIgODkuODJhMTQ0IDE0NCAwIDAgMC0yMDMuNzEtLjA3bC02Ny44OCA2Ny44OCA2Ny44OCA2Ny44OSA2Ny44OC02Ny44OWE0OCA0OCAwIDAgMSA2OC40Ni41OWMxOC4zIDE4LjkyIDE3LjQ4IDQ5LjI0LTEuMTQgNjcuODZsLTY3LjMyIDY3LjMyIDY3Ljg4IDY3Ljg4IDY2LjkxLTY2LjkxYzU2LjM3LTU2LjM3IDU3LjM3LTE0OC4xNSAxLjA0LTIwNC41NVpNODIuNzE5IDIyNS41MTdsNDUuMjU0LTQ1LjI1NCA2Ny44ODMgNjcuODgyTDE1MC42IDI5My40ek0yMTguNDkgMzYxLjI3bDQ1LjI1NC00NS4yNTQgNjcuODgyIDY3Ljg4Mi00NS4yNTUgNDUuMjU1eiIvPjwvc3ZnPg==\");\n// CONCATENATED MODULE: ./node_modules/scratch-gui/src/addons/addons/paint-snap/_runtime_entry.js\n/* generated by pull.js */\n\n\n\n\n\n\n\n\nconst resources = {\n  \"userscript.js\": userscript,\n  \"userstyle.css\": userstyle_default.a,\n  \"icons/decrement.svg\": decrement,\n  \"icons/increment.svg\": increment,\n  \"icons/off.svg\": off,\n  \"icons/on.svg\": on,\n  \"icons/settings.svg\": settings,\n  \"icons/snap.svg\": snap\n};\n\n/***/ })\n\n}]);","inputSourceMap":null}