const BlockType = require('../../extension-support/block-type');
const ArgumentType = require('../../extension-support/argument-type')
const socket=require('../../util/socket-connect')

let newSocket;
let isConnectEventSource=false
let eventSource
let scratchGet=[]
let socketSound

class RobotSound {
    constructor(runtime){
        this.runtime=runtime


        this.flag='0'
        this.channel = new BroadcastChannel('flag_channel');
        this.channel.addEventListener('message', (event) => {
            console.log('Received flag data:', event.data);
            this.flag=event.data
            // if(event.data=='1'){
            //     eventSource = new EventSource('http://192.168.4.1:8083/stream');
            //     eventSource.onerror = function(error) {
            //         console.error('Error:', error);
            //         eventSource.close();
            //     };
            //     eventSource.onmessage = function(event) {
            //         // output.innerHTML = "Received from server: " + event.data;
            //         // console.log(event.data)
            //         // console.log(Date.now())

            //         scratchGet=JSON.parse(event.data)
                    
            //     };
            // }else if(event.data=='0'){
            //     try{
            //         eventSource.close();
            //     }catch(e){

            //     }
            // }
        });
        this.mode=true
        this.channelMode=new BroadcastChannel('mode')
        this.channelMode.addEventListener('message',(event)=>{
            this.mode=event.data
        })


        this.line;


        this.currentVol=0

        this.musicTime={
            'alarm.wav':1000,
            'ambulance.wav':2000,
            'background.wav':15000,
            'bicycle.wav':1000,
            'bird.wav':1000,
            'car.wav':1000,
            'cat.wav':1000,
            'cock.wav':1000,
            'cow.wav':1000,
            'dog.wav':1000,
            'failure.wav':1000,
            'fireEngine.wav':5000,
            'gunfire.wav':1000,
            'hit.wav':1000,
            'horse.wav':1000,
            'pig.wav':1000,
            'police.wav':1000,
            'sheep.wav':1000,
            'tiger.wav':1000,
            'train.wav':1000,
            'victory.wav':1000,
            'wowu_.wav':1000,

        }

        this.upLoadSound=[]
        this.isSendEnd=true
        this.shouldStopSending = false; // é»˜è®¤ä¸åœæ­¢

        this.whatSendFun='net'
        this.channelPort = new BroadcastChannel('channelPort')
        this.channelPort.addEventListener('message',(event)=>{
            console.log(event.data)
            if(event.data){
                this.whatSendFun='port'
            }else{
                this.whatSendFun='net'
            }
            
        })


    }
  getInfo() {

    return {
      id: 'robotsound',
      name: 'æ’­æ”¾',
      color1: '#6a5acd',
    //   color3: '#ff0000',
      blocks: [

        {
            func:'selectSound',
            blockType:BlockType.BUTTON,
            text:'é€‰æ‹©ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶'
        },

        {
            func:'downLoadSound',
            blockType:BlockType.BUTTON,
            text:'ä¸‹è½½éŸ³é¢‘æ–‡ä»¶è‡³æœºå™¨äºº'
        },

        {
            opcode: 'setVol',
            blockType: BlockType.COMMAND,
            text: 'éŸ³é‡è®¾ç½®ä¸º[ONE]',
            arguments:{
                ONE:{
                    type: ArgumentType.STRING,
                    defaultValue:7
                },
            },
        },

        {
            opcode: 'musicUntil',
            blockType: BlockType.COMMAND,
            text: 'æ’­æ”¾éŸ³ä¹[ONE] ç›´åˆ°æ’­æ”¾å®Œæ¯•',
            arguments:{
                ONE:{
                    type: ArgumentType.STRING,
                    menu:'MENU_MUSIC'
                },
            },
        },

        {
            opcode: 'music',
            blockType: BlockType.COMMAND,
            text: 'æ’­æ”¾éŸ³ä¹[ONE]',
            arguments:{
                ONE:{
                    type: ArgumentType.STRING,
                    menu:'MENU_MUSIC'
                },
            },
        },

        {
            opcode: 'musicStop',
            blockType: BlockType.COMMAND,
            text: 'åœæ­¢æ’­æ”¾',
            arguments:{
                
            },
        },

        {
            opcode: 'playLocalMusic',
            blockType: BlockType.COMMAND,
            text: '[TWO]æœ¬åœ°å£°éŸ³[ONE]',
            arguments:{
                ONE:{
                    type:ArgumentType.STRING,
                    menu:'MENU_SOUND'
                },
                TWO:{
                    type:ArgumentType.STRING,
                    menu:'MENU_LOCAL_STATE'
                }
            },
        },

        // {
        //     opcode: 'soundTurbo',
        //     blockType: BlockType.COMMAND,
        //     text: 'æœ¬åœ°å£°éŸ³[ONE]',
        //     arguments:{
        //         ONE:{
        //             type:ArgumentType.SOUND,
        //         },
        //     },
        // },

        // {
        //     opcode: 'sendMusic',
        //     blockType: BlockType.COMMAND,
        //     text: 'å¼€å§‹å‘é€å£°éŸ³',
        //     arguments:{
                
        //     },
        // },
        // {
        //     opcode: 'stopSendMusic',
        //     blockType: BlockType.COMMAND,
        //     text: 'ç»“æŸå‘é€å£°éŸ³',
        //     arguments:{
                
        //     },
        // },

        // {
        //     opcode: 'tts',
        //     blockType: BlockType.COMMAND,
        //     text: 'å°†[ONE]è½¬ä¸ºè¯­éŸ³å¹¶å‘é€',
        //     arguments:{
        //         ONE:{
        //             type: ArgumentType.STRING,
        //             defaultValue:'hello'
        //         },
        //     },
        // },


        // {
        //     opcode: 'addSound',
        //     blockType: BlockType.COMMAND,
        //     text: 'å°†éŸ³é‡å¢åŠ 1',
        //     arguments:{
                
        //     },
        // },

        // {
        //     opcode: 'subSound',
        //     blockType: BlockType.COMMAND,
        //     text: 'å°†éŸ³é‡å‡å°‘1',
        //     arguments:{
                
        //     },
        // },
        

      ],

      menus: {
       
        MENU_COMPARE: {
            acceptReporters: false,
            items: [
                {
                    text: '>',
                    value: '>'
                },
                {
                    text: '<',
                    value: '<'
                },
                {
                    text: '=',
                    value: '='
                }
                
            ]
        },

        MENU_SOUND:{
            acceptReporters: false,
            items:'getSoundList'
        },

        MENU_LOCAL_STATE:{
            acceptReporters: false,
            items: [
                {
                    text: 'æ’­æ”¾',
                    value: '0'
                },
                {
                    text: 'åœæ­¢æ’­æ”¾',
                    value: '1'
                },
            ]
        },

       
        MENU_MUSIC:{
            acceptReporters: false,
            items: [
                {
                    text: 'æ±½è½¦å£°',
                    value: 'car.wav'
                },
                {
                    text: 'å°çŒ«å«',
                    value: 'cat.wav'
                },
                {
                    text: 'å°ç‹—å«',
                    value: 'dog.wav'
                },

                {
                    text: 'é—¹é’Ÿå£°',
                    value: 'alarm.wav'
                },
                {
                    text: 'æ•‘æŠ¤è½¦',
                    value: 'ambulance.wav'
                },
                {
                    text: 'èƒŒæ™¯éŸ³ä¹',
                    value: 'background.wav'
                },


                {
                    text: 'è‡ªè¡Œè½¦',
                    value: 'bicycle.wav'
                },
                {
                    text: 'é¸Ÿå«å£°',
                    value: 'bird.wav'
                },
                {
                    text: 'é¸¡å«',
                    value: 'cock.wav'
                },


                {
                    text: 'ç‰›å«',
                    value: 'cow.wav'
                },
                {
                    text: 'å¤±è´¥',
                    value: 'failure.wav'
                },
                {
                    text: 'æ¶ˆé˜²è½¦',
                    value: 'fireEngine.wav'
                },

                {
                    text: 'å‘å°„',
                    value: 'gunfire.wav'
                },
                {
                    text: 'æ‰“å‡»',
                    value: 'hit.wav'
                },
                {
                    text: 'é©¬å«',
                    value: 'horse.wav'
                },

                {
                    text: 'çŒªå«',
                    value: 'pig.wav'
                },
                {
                    text: 'è­¦è½¦å£°',
                    value: 'police.wav'
                },
                {
                    text: 'ç¾Šå«',
                    value: 'sheep.wav'
                },

                {
                    text: 'ç«è½¦é¸£ç¬›',
                    value: 'train.wav'
                },
                {
                    text: 'æˆåŠŸ',
                    value: 'victory.wav'
                },
                {
                    text: 'æ¬¢å‘¼',
                    value: 'wowu_.wav'
                },
                {
                    text: 'è‡ªå®šä¹‰éŸ³é¢‘',
                    value: 'customize.wav'
                },


                
            ]
        },
    }
    };
  }

    async setVol(args){
        if(this.mode){
            this.currentVol=args.ONE

            let vol=Number(args.ONE)
            if(vol<0){
                vol=0
            }else if(vol>10){
                vol=10
            }
            let jsonData={
                "command":"speaker",
                "params":{
                    "mode":1,
                    "vol":vol,
                    "name":''
                }
            }
            // let str0=`${args.TWO.split('.')[0]} = robot.read_wav('/flash/${args.TWO}')\r`
            // let str = `robot.play_music(${args.ONE},${args.TWO.split('.')[0]})\r`;

            let str = JSON.stringify(jsonData)

            if(this.whatSendFun=='net'){
                if(socket.checkWebSocketStatus()==4 || socket.checkWebSocketStatus()==0){
                    console.log('æ–­å¼€è¿æ¥ï¼Œå°è¯•é‡è¿')
                    let context=[]
                    // context.push(str0)
                    context.push(str)
                    await socket.setSocket(context)
                }else if(socket.checkWebSocketStatus()==2){
                    // socket.getSocket().send(str0);
                    // await new Promise(resolve => setTimeout(resolve, 50));  // ç­‰å¾…1ç§’
                    socket.getSocket().send(str);
                    await new Promise(resolve => setTimeout(resolve, 50));  // ç­‰å¾…1ç§’
                }
                socket.setLastPostTime(Date.now())
            }else{
                this.channelPort.postMessage(str)
            }
           
        }
    }

    async musicUntil(args){
        if(this.mode){

            let jsonData={
                "command":"speaker",
                "params":{
                    "mode":2,
                    "vol":0,
                    "name":`/flash/${args.ONE}`
                }
            }
            // let str0=`${args.TWO.split('.')[0]} = robot.read_wav('/flash/${args.TWO}')\r`
            // let str = `robot.play_music(${args.ONE},${args.TWO.split('.')[0]})\r`;

            let str = JSON.stringify(jsonData)
            if(this.whatSendFun=='net'){
                if(socket.checkWebSocketStatus()==4 || socket.checkWebSocketStatus()==0){
                    console.log('æ–­å¼€è¿æ¥ï¼Œå°è¯•é‡è¿')
                    let context=[]
                    // context.push(str0)
                    context.push(str)
                    await socket.setSocket(context)
                }else if(socket.checkWebSocketStatus()==2){
                    // socket.getSocket().send(str0);
                    // await new Promise(resolve => setTimeout(resolve, 50));  // ç­‰å¾…1ç§’
                    socket.getSocket().send(str);
                    await new Promise(resolve => setTimeout(resolve, 50));  // ç­‰å¾…1ç§’
                }
                await new Promise(resolve => setTimeout(resolve, this.musicTime[args.ONE]));  // ç­‰å¾…1ç§’
                socket.setLastPostTime(Date.now())
            }else{
                this.channelPort.postMessage(str)
                await new Promise(resolve => setTimeout(resolve, this.musicTime[args.ONE]));  

            }
           
        }
    }

    async music(args){
        if(this.mode){

            let jsonData={
                "command":"speaker",
                "params":{
                    "mode":3,
                    "vol":0,
                    "name":`/flash/${args.ONE}`
                }
            }
            // let str0=`${args.TWO.split('.')[0]} = robot.read_wav('/flash/${args.TWO}')\r`
            // let str = `robot.play_music(${args.ONE},${args.TWO.split('.')[0]})\r`;

            let str = JSON.stringify(jsonData)

            if(this.whatSendFun=='net'){
                if(socket.checkWebSocketStatus()==4 || socket.checkWebSocketStatus()==0){
                    console.log('æ–­å¼€è¿æ¥ï¼Œå°è¯•é‡è¿')
                    let context=[]
                    // context.push(str0)
                    context.push(str)
                    await socket.setSocket(context)
                }else if(socket.checkWebSocketStatus()==2){
                    // socket.getSocket().send(str0);
                    // await new Promise(resolve => setTimeout(resolve, 50));  // ç­‰å¾…1ç§’
                    socket.getSocket().send(str);
                    await new Promise(resolve => setTimeout(resolve, 50));  // ç­‰å¾…1ç§’
                }
                // await new Promise(resolve => setTimeout(resolve, 1000));  // ç­‰å¾…1ç§’
                socket.setLastPostTime(Date.now())
            }else{
                this.channelPort.postMessage(str)
            }
            
        }
    }

    async musicStop(){
        if(this.mode){

            let jsonData={
                "command":"speaker",
                "params":{
                    "mode":4,
                    "vol":0,
                    "name":''
                }
            }
            // let str0=`${args.TWO.split('.')[0]} = robot.read_wav('/flash/${args.TWO}')\r`
            // let str = `robot.play_music(${args.ONE},${args.TWO.split('.')[0]})\r`;

            let str = JSON.stringify(jsonData)
            if(this.whatSendFun=='net'){
                if(socket.checkWebSocketStatus()==4 || socket.checkWebSocketStatus()==0){
                    console.log('æ–­å¼€è¿æ¥ï¼Œå°è¯•é‡è¿')
                    let context=[]
                    // context.push(str0)
                    context.push(str)
                    await socket.setSocket(context)
                }else if(socket.checkWebSocketStatus()==2){
                    // socket.getSocket().send(str0);
                    // await new Promise(resolve => setTimeout(resolve, 50));  // ç­‰å¾…1ç§’
                    socket.getSocket().send(str);
                    await new Promise(resolve => setTimeout(resolve, 50));  // ç­‰å¾…1ç§’
                }
                socket.setLastPostTime(Date.now())
            }else{
                this.channelPort.postMessage(str)
            }
           

            //  const Socket = new WebSocket(`ws://${socket.getIp()}:8084`);
                                
            // Socket.addEventListener('open', async (event) => {
            //     console.log('è¿æ¥æˆåŠŸ');
            //     Socket.send(str)
            //     await new Promise(resolve => setTimeout(resolve, 100));
            //     Socket.close()
    
                    
            // });
        }
    }


    async selectAndProcessAudio() {
        return new Promise((resolve, reject) => {
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = '.wav';
          input.style.display = 'none';
      
          input.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) {
              reject(new Error('æœªé€‰æ‹©æ–‡ä»¶'));
              input.remove();
              return;
            }
      
            try {
              const processed = await this.processAudioFile(file);
              resolve(processed);
            } catch (err) {
              reject(err);
            } finally {
              input.remove(); // æ¸…é™¤ input
            }
          });
      
          document.body.appendChild(input);
          input.click(); // è‡ªåŠ¨è§¦å‘æ–‡ä»¶é€‰æ‹©
        });
    }

    async processAudioFile(file) {
        const arrayBuffer = await file.arrayBuffer();
        const audioContext = new AudioContext();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
      
        const inputData = audioBuffer.getChannelData(0); // å•é€šé“
        const originalSampleRate = audioBuffer.sampleRate;
        const resampledData = this.resampleAudio(inputData, originalSampleRate, 8000);
        const pcm16 = this.floatTo16BitPCM(resampledData);
        return pcm16;
    }
      
    resampleAudio(inputData, srcRate, targetRate) {
        const ratio = srcRate / targetRate;
        const newLength = Math.floor(inputData.length / ratio);
        const output = new Float32Array(newLength);
        
        for (let i = 0; i < newLength; i++) {
            const idx = Math.floor(i * ratio);
            output[i] = inputData[idx];
        }
        
        return output;
    }
      
    floatTo16BitPCM(input) {
        const buffer = new ArrayBuffer(input.length * 2);
        const view = new DataView(buffer);
        
        for (let i = 0; i < input.length; i++) {
            const sample = Math.max(-1, Math.min(1, input[i]));
            view.setInt16(i * 2, sample * 0x7FFF, true);
        }
        
        return new Blob([view], { type: 'audio/wav' });
    }
      
      

    async selectSound(){
        try {
            const processedBlob = await this.selectAndProcessAudio();
            console.log('âœ… éŸ³é¢‘å¤„ç†å®Œæˆï¼ŒBlob:', processedBlob);

            const arrayBuffer = await processedBlob.arrayBuffer();
            console.log(arrayBuffer)

            let name = await new Promise(resolve => {
                resolve(prompt('è¯·è¾“å…¥éŸ³é¢‘åç§°'));  // åœ¨å¼‚æ­¥å‡½æ•°ä¸­åŒ…è£… prompt
            });

            this.upLoadSound.push({
                name:name,
                data:arrayBuffer
            })

            

        } catch (err) {
            console.error('âŒ å¤„ç†å¤±è´¥:', err.message);
            alert('éŸ³é¢‘ä¸Šä¼ å¤±è´¥ï¼Œè¯·é€‰æ‹©å…¶ä»–éŸ³é¢‘')
        }
    }
    async playLocalMusic(args){
        if(args.TWO=='0'){
            this.shouldStopSending = false;
            if(this.isSendEnd){
                try {
                    // const processedBlob = await this.selectAndProcessAudio();
                    // console.log('âœ… éŸ³é¢‘å¤„ç†å®Œæˆï¼ŒBlob:', processedBlob);
        
                    // const arrayBuffer = await processedBlob.arrayBuffer();
                    // console.log(arrayBuffer)
        
        
                    this.isSendEnd=false
                    console.log(this.upLoadSound[Number(args.ONE)].data)
                    let arrayBuffer=this.upLoadSound[Number(args.ONE)].data
        
                    socketSound = new WebSocket(`ws://${socket.getIp()}:8080`)
                    
                    socketSound.addEventListener('open',async()=>{
                        console.log('è¿æ¥æˆåŠŸ')
                        const chunkSize = 2048;
                        let offset = 44; // âœ… è·³è¿‡ WAV å¤´éƒ¨ 44 å­—èŠ‚
                      
                        const sendChunk = () => {

                            if (this.shouldStopSending) {
                                console.warn('â›”ï¸ å‘é€è¢«æ‰‹åŠ¨ä¸­æ–­');
                                socketSound.close();
                                this.isSendEnd = true;
                                return;
                            }


                          if (offset >= arrayBuffer.byteLength) {
                            console.log('ğŸ“¤ æ‰€æœ‰éŸ³é¢‘æ•°æ®å‘é€å®Œæ¯•');
                            socketSound.close()
                            this.isSendEnd=true
                            return;
                          }
                      
                          const end = Math.min(offset + chunkSize, arrayBuffer.byteLength);
                          const chunk = arrayBuffer.slice(offset, end);
                          socketSound.send(chunk);
                          offset = end;
                      
                          setTimeout(sendChunk, 125); // æ§åˆ¶å‘é€èŠ‚å¥
                          
                        };
                      
                        sendChunk();
                    })
        
                } catch (err) {
                    console.error('âŒ å¤„ç†å¤±è´¥:', err.message);
                }
            }
        }else if(args.TWO=='1'){
            this.shouldStopSending = true;
        }
       
        
    }

    getSoundList(){
        let item=[];
        if(this.upLoadSound && this.upLoadSound.length > 0){
            console.log('æ–°èœå•')
            for(let i=0;i<this.upLoadSound.length;i++){
                let content={
                    text:this.upLoadSound[i].name,
                    value:`${i}`
                }
                item.push(content)
            }
        }else{
            console.log('æ—§èœå•')
            item.push({
                text:' ',
                value:' '
            })
        }

        console.log(item)
        
        return item
    }

    async downLoadSound(){
        try {
            const processedBlob = await this.selectAndProcessAudio();
            console.log('âœ… éŸ³é¢‘å¤„ç†å®Œæˆï¼ŒBlob:', processedBlob);

            const arrayBuffer = await processedBlob.arrayBuffer();
            console.log(arrayBuffer)


            socketSound = new WebSocket(`ws://${socket.getIp()}:8084`)
            let reciveData=''
            socketSound.addEventListener('open',async()=>{
                console.log('è¿æ¥æˆåŠŸ')
                const waitForMessage = () => {
                    return new Promise(resolve => {
                        const listener = (event) => {
                            console.log('æ”¶åˆ°æ¶ˆæ¯:', event.data);
                            socketSound.removeEventListener('message', listener);
                            resolve(event.data);
                        };
                        socketSound.addEventListener('message', listener);
                    });
                };
            
                socketSound.send('music');
            
                let res = await waitForMessage();
                if (res === 'success') {
                    const chunkSize = 1024;
                    let offset = 44;
            
                    // while (offset < arrayBuffer.byteLength) {
                    //     const end = Math.min(offset + chunkSize, arrayBuffer.byteLength);
                    //     const chunk = arrayBuffer.slice(offset, end);
                    //     socketSound.send(chunk);
            
                    //     const result = await waitForMessage(); // ç­‰å¾…æœåŠ¡å™¨å›å¤
                    //     if (result !== 'success') {
                    //         alert('æŸæ®µå‘é€å¤±è´¥');
                    //         socketSound.close();
                    //         return;
                    //     }
            
                    //     offset = end;
                    // }

                    socketSound.send(arrayBuffer)
                    let result=await waitForMessage();
                    if(result=='success'){
                        console.log('ğŸ“¤ æ‰€æœ‰éŸ³é¢‘æ•°æ®å‘é€å®Œæ¯•');
                        socketSound.send('finished');
                
                        const finalRes = await waitForMessage();
                        if (finalRes === 'success') {
                            alert('ä¸‹è½½å®Œæˆ');
                        } else {
                            alert('ä¸‹è½½å¤±è´¥');
                        }
                        socketSound.close();
                    }else{
                        alert('æ•°æ®å‘é€å¤±è´¥')
                        socketSound.close();
                    }
            
                    
            
                    
                }
                
            })
    
            

            

        } catch (err) {
            console.error('âŒ å¤„ç†å¤±è´¥:', err.message);
            alert('éŸ³é¢‘ä¸Šä¼ å¤±è´¥ï¼Œè¯·é€‰æ‹©å…¶ä»–éŸ³é¢‘')
        }
    }

    async sendMusic(){

    }

    async stopSendMusic(){

    }

    async tts(args){
        // const text = args.ONE;
        // const utterance = new SpeechSynthesisUtterance(text);
        // utterance.lang = 'zh-CN';
        
        // // åˆ›å»ºä¸€ä¸ªæ–°çš„ AudioContext
        // const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // // åˆ›å»ºä¸€ä¸ªéŸ³é¢‘æºï¼Œå…è®¸ä» SpeechSynthesis è¾“å‡ºéŸ³é¢‘
        // const source = audioContext.createMediaStreamDestination();
        
        // // é€šè¿‡ MediaRecorder æ•è·éŸ³é¢‘
        // const mediaRecorder = new MediaRecorder(source.stream);
        // let audioChunks = [];
        
        // mediaRecorder.ondataavailable = function(event) {
        //     audioChunks.push(event.data);
        // };
        
        // mediaRecorder.onstop = function() {
        //     const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
        //     const audioUrl = URL.createObjectURL(audioBlob);
            
        //     // å°†éŸ³é¢‘ URL ä¿å­˜åˆ°å˜é‡
        //     console.log("éŸ³é¢‘å·²ä¿å­˜:", audioUrl);
            
        //     // ä½ å¯ä»¥é€šè¿‡éŸ³é¢‘ URL åˆ›å»ºä¸€ä¸ª <audio> å…ƒç´ è¿›è¡Œæ’­æ”¾
        //     const audioElement = new Audio(audioUrl);
        //     audioElement.play();
        // };
        
        // // å¼€å§‹å½•åˆ¶éŸ³é¢‘
        // mediaRecorder.start();
        
        // // å¼€å§‹åˆæˆè¯­éŸ³
        // speechSynthesis.speak(utterance);
        
        // // åœæ­¢å½•åˆ¶å
        // utterance.onend = function() {
        //     mediaRecorder.stop();
        // };
    }

    async addSound(){
        if(this.mode){
            // this.currentVol+=args.ONE
            let jsonData={
                "command":"speaker",
                "params":{
                    "mode":5,
                    "vol":0,
                    "name":''
                }
            }
            // let str0=`${args.TWO.split('.')[0]} = robot.read_wav('/flash/${args.TWO}')\r`
            // let str = `robot.play_music(${args.ONE},${args.TWO.split('.')[0]})\r`;

            let str = JSON.stringify(jsonData)
            if(socket.checkWebSocketStatus()==4 || socket.checkWebSocketStatus()==0){
                console.log('æ–­å¼€è¿æ¥ï¼Œå°è¯•é‡è¿')
                let context=[]
                // context.push(str0)
                context.push(str)
                await socket.setSocket(context)
            }else if(socket.checkWebSocketStatus()==2){
                // socket.getSocket().send(str0);
                // await new Promise(resolve => setTimeout(resolve, 50));  // ç­‰å¾…1ç§’
                socket.getSocket().send(str);
                await new Promise(resolve => setTimeout(resolve, 50));  // ç­‰å¾…1ç§’
            }
            socket.setLastPostTime(Date.now())
        }
    }


    async subSound(){
        if(this.mode){
            // this.currentVol+=args.ONE
            let jsonData={
                "command":"speaker",
                "params":{
                    "mode":6,
                    "vol":0,
                    "name":''
                }
            }
            // let str0=`${args.TWO.split('.')[0]} = robot.read_wav('/flash/${args.TWO}')\r`
            // let str = `robot.play_music(${args.ONE},${args.TWO.split('.')[0]})\r`;

            let str = JSON.stringify(jsonData)
            if(socket.checkWebSocketStatus()==4 || socket.checkWebSocketStatus()==0){
                console.log('æ–­å¼€è¿æ¥ï¼Œå°è¯•é‡è¿')
                let context=[]
                // context.push(str0)
                context.push(str)
                await socket.setSocket(context)
            }else if(socket.checkWebSocketStatus()==2){
                // socket.getSocket().send(str0);
                // await new Promise(resolve => setTimeout(resolve, 50));  // ç­‰å¾…1ç§’
                socket.getSocket().send(str);
                await new Promise(resolve => setTimeout(resolve, 50));  // ç­‰å¾…1ç§’
            }
            socket.setLastPostTime(Date.now())
        }
    }

}


module.exports = RobotSound;
