const BlockType = require('../../extension-support/block-type');
const ArgumentType = require('../../extension-support/argument-type')
const socket=require('../../util/socket-connect')

let newSocket;
let isConnectEventSource=false
let eventSource
let scratchGet=[]
let socketSound

class RobotSound {
    constructor(runtime){
        this.runtime=runtime


        this.flag='0'
        this.channel = new BroadcastChannel('flag_channel');
        this.channel.addEventListener('message', (event) => {
            console.log('Received flag data:', event.data);
            this.flag=event.data
            // if(event.data=='1'){
            //     eventSource = new EventSource('http://192.168.4.1:8083/stream');
            //     eventSource.onerror = function(error) {
            //         console.error('Error:', error);
            //         eventSource.close();
            //     };
            //     eventSource.onmessage = function(event) {
            //         // output.innerHTML = "Received from server: " + event.data;
            //         // console.log(event.data)
            //         // console.log(Date.now())

            //         scratchGet=JSON.parse(event.data)
                    
            //     };
            // }else if(event.data=='0'){
            //     try{
            //         eventSource.close();
            //     }catch(e){

            //     }
            // }
        });
        this.mode=true
        this.channelMode=new BroadcastChannel('mode')
        this.channelMode.addEventListener('message',(event)=>{
            this.mode=event.data
        })


        this.line;


        this.currentVol=0

        this.musicTime={
            'alarm.wav':1000,
            'ambulance.wav':2000,
            'background.wav':15000,
            'bicycle.wav':1000,
            'bird.wav':1000,
            'car.wav':1000,
            'cat.wav':1000,
            'cock.wav':1000,
            'cow.wav':1000,
            'dog.wav':1000,
            'failure.wav':1000,
            'fireEngine.wav':5000,
            'gunfire.wav':1000,
            'hit.wav':1000,
            'horse.wav':1000,
            'pig.wav':1000,
            'police.wav':1000,
            'sheep.wav':1000,
            'tiger.wav':1000,
            'train.wav':1000,
            'victory.wav':1000,
            'wowu_.wav':1000,

        }

        this.upLoadSound=[]
        this.isSendEnd=true
        this.shouldStopSending = false; // 默认不停止

        this.whatSendFun='net'
        this.channelPort = new BroadcastChannel('channelPort')
        this.channelPort.addEventListener('message',(event)=>{
            console.log(event.data)
            if(event.data){
                this.whatSendFun='port'
            }else{
                this.whatSendFun='net'
            }
            
        })


    }
  getInfo() {

    return {
      id: 'robotsound',
      name: '播放',
      color1: '#6a5acd',
    //   color3: '#ff0000',
      blocks: [

        {
            func:'selectSound',
            blockType:BlockType.BUTTON,
            text:'选择上传音频文件'
        },

        {
            func:'downLoadSound',
            blockType:BlockType.BUTTON,
            text:'下载音频文件至机器人'
        },

        {
            opcode: 'setVol',
            blockType: BlockType.COMMAND,
            text: '音量设置为[ONE]',
            arguments:{
                ONE:{
                    type: ArgumentType.STRING,
                    defaultValue:7
                },
            },
        },

        {
            opcode: 'musicUntil',
            blockType: BlockType.COMMAND,
            text: '播放音乐[ONE] 直到播放完毕',
            arguments:{
                ONE:{
                    type: ArgumentType.STRING,
                    menu:'MENU_MUSIC'
                },
            },
        },

        {
            opcode: 'music',
            blockType: BlockType.COMMAND,
            text: '播放音乐[ONE]',
            arguments:{
                ONE:{
                    type: ArgumentType.STRING,
                    menu:'MENU_MUSIC'
                },
            },
        },

        {
            opcode: 'musicStop',
            blockType: BlockType.COMMAND,
            text: '停止播放',
            arguments:{
                
            },
        },

        {
            opcode: 'playLocalMusic',
            blockType: BlockType.COMMAND,
            text: '[TWO]本地声音[ONE]',
            arguments:{
                ONE:{
                    type:ArgumentType.STRING,
                    menu:'MENU_SOUND'
                },
                TWO:{
                    type:ArgumentType.STRING,
                    menu:'MENU_LOCAL_STATE'
                }
            },
        },

        // {
        //     opcode: 'soundTurbo',
        //     blockType: BlockType.COMMAND,
        //     text: '本地声音[ONE]',
        //     arguments:{
        //         ONE:{
        //             type:ArgumentType.SOUND,
        //         },
        //     },
        // },

        // {
        //     opcode: 'sendMusic',
        //     blockType: BlockType.COMMAND,
        //     text: '开始发送声音',
        //     arguments:{
                
        //     },
        // },
        // {
        //     opcode: 'stopSendMusic',
        //     blockType: BlockType.COMMAND,
        //     text: '结束发送声音',
        //     arguments:{
                
        //     },
        // },

        // {
        //     opcode: 'tts',
        //     blockType: BlockType.COMMAND,
        //     text: '将[ONE]转为语音并发送',
        //     arguments:{
        //         ONE:{
        //             type: ArgumentType.STRING,
        //             defaultValue:'hello'
        //         },
        //     },
        // },


        // {
        //     opcode: 'addSound',
        //     blockType: BlockType.COMMAND,
        //     text: '将音量增加1',
        //     arguments:{
                
        //     },
        // },

        // {
        //     opcode: 'subSound',
        //     blockType: BlockType.COMMAND,
        //     text: '将音量减少1',
        //     arguments:{
                
        //     },
        // },
        

      ],

      menus: {
       
        MENU_COMPARE: {
            acceptReporters: false,
            items: [
                {
                    text: '>',
                    value: '>'
                },
                {
                    text: '<',
                    value: '<'
                },
                {
                    text: '=',
                    value: '='
                }
                
            ]
        },

        MENU_SOUND:{
            acceptReporters: false,
            items:'getSoundList'
        },

        MENU_LOCAL_STATE:{
            acceptReporters: false,
            items: [
                {
                    text: '播放',
                    value: '0'
                },
                {
                    text: '停止播放',
                    value: '1'
                },
            ]
        },

       
        MENU_MUSIC:{
            acceptReporters: false,
            items: [
                {
                    text: '汽车声',
                    value: 'car.wav'
                },
                {
                    text: '小猫叫',
                    value: 'cat.wav'
                },
                {
                    text: '小狗叫',
                    value: 'dog.wav'
                },

                {
                    text: '闹钟声',
                    value: 'alarm.wav'
                },
                {
                    text: '救护车',
                    value: 'ambulance.wav'
                },
                {
                    text: '背景音乐',
                    value: 'background.wav'
                },


                {
                    text: '自行车',
                    value: 'bicycle.wav'
                },
                {
                    text: '鸟叫声',
                    value: 'bird.wav'
                },
                {
                    text: '鸡叫',
                    value: 'cock.wav'
                },


                {
                    text: '牛叫',
                    value: 'cow.wav'
                },
                {
                    text: '失败',
                    value: 'failure.wav'
                },
                {
                    text: '消防车',
                    value: 'fireEngine.wav'
                },

                {
                    text: '发射',
                    value: 'gunfire.wav'
                },
                {
                    text: '打击',
                    value: 'hit.wav'
                },
                {
                    text: '马叫',
                    value: 'horse.wav'
                },

                {
                    text: '猪叫',
                    value: 'pig.wav'
                },
                {
                    text: '警车声',
                    value: 'police.wav'
                },
                {
                    text: '羊叫',
                    value: 'sheep.wav'
                },

                {
                    text: '火车鸣笛',
                    value: 'train.wav'
                },
                {
                    text: '成功',
                    value: 'victory.wav'
                },
                {
                    text: '欢呼',
                    value: 'wowu_.wav'
                },
                {
                    text: '自定义音频',
                    value: 'customize.wav'
                },


                
            ]
        },
    }
    };
  }

    async setVol(args){
        if(this.mode){
            this.currentVol=args.ONE

            let vol=Number(args.ONE)
            if(vol<0){
                vol=0
            }else if(vol>10){
                vol=10
            }
            let jsonData={
                "command":"speaker",
                "params":{
                    "mode":1,
                    "vol":vol,
                    "name":''
                }
            }
            // let str0=`${args.TWO.split('.')[0]} = robot.read_wav('/flash/${args.TWO}')\r`
            // let str = `robot.play_music(${args.ONE},${args.TWO.split('.')[0]})\r`;

            let str = JSON.stringify(jsonData)

            if(this.whatSendFun=='net'){
                if(socket.checkWebSocketStatus()==4 || socket.checkWebSocketStatus()==0){
                    console.log('断开连接，尝试重连')
                    let context=[]
                    // context.push(str0)
                    context.push(str)
                    await socket.setSocket(context)
                }else if(socket.checkWebSocketStatus()==2){
                    // socket.getSocket().send(str0);
                    // await new Promise(resolve => setTimeout(resolve, 50));  // 等待1秒
                    socket.getSocket().send(str);
                    await new Promise(resolve => setTimeout(resolve, 50));  // 等待1秒
                }
                socket.setLastPostTime(Date.now())
            }else{
                this.channelPort.postMessage(str)
            }
           
        }
    }

    async musicUntil(args){
        if(this.mode){

            let jsonData={
                "command":"speaker",
                "params":{
                    "mode":2,
                    "vol":0,
                    "name":`/flash/${args.ONE}`
                }
            }
            // let str0=`${args.TWO.split('.')[0]} = robot.read_wav('/flash/${args.TWO}')\r`
            // let str = `robot.play_music(${args.ONE},${args.TWO.split('.')[0]})\r`;

            let str = JSON.stringify(jsonData)
            if(this.whatSendFun=='net'){
                if(socket.checkWebSocketStatus()==4 || socket.checkWebSocketStatus()==0){
                    console.log('断开连接，尝试重连')
                    let context=[]
                    // context.push(str0)
                    context.push(str)
                    await socket.setSocket(context)
                }else if(socket.checkWebSocketStatus()==2){
                    // socket.getSocket().send(str0);
                    // await new Promise(resolve => setTimeout(resolve, 50));  // 等待1秒
                    socket.getSocket().send(str);
                    await new Promise(resolve => setTimeout(resolve, 50));  // 等待1秒
                }
                await new Promise(resolve => setTimeout(resolve, this.musicTime[args.ONE]));  // 等待1秒
                socket.setLastPostTime(Date.now())
            }else{
                this.channelPort.postMessage(str)
                await new Promise(resolve => setTimeout(resolve, this.musicTime[args.ONE]));  

            }
           
        }
    }

    async music(args){
        if(this.mode){

            let jsonData={
                "command":"speaker",
                "params":{
                    "mode":3,
                    "vol":0,
                    "name":`/flash/${args.ONE}`
                }
            }
            // let str0=`${args.TWO.split('.')[0]} = robot.read_wav('/flash/${args.TWO}')\r`
            // let str = `robot.play_music(${args.ONE},${args.TWO.split('.')[0]})\r`;

            let str = JSON.stringify(jsonData)

            if(this.whatSendFun=='net'){
                if(socket.checkWebSocketStatus()==4 || socket.checkWebSocketStatus()==0){
                    console.log('断开连接，尝试重连')
                    let context=[]
                    // context.push(str0)
                    context.push(str)
                    await socket.setSocket(context)
                }else if(socket.checkWebSocketStatus()==2){
                    // socket.getSocket().send(str0);
                    // await new Promise(resolve => setTimeout(resolve, 50));  // 等待1秒
                    socket.getSocket().send(str);
                    await new Promise(resolve => setTimeout(resolve, 50));  // 等待1秒
                }
                // await new Promise(resolve => setTimeout(resolve, 1000));  // 等待1秒
                socket.setLastPostTime(Date.now())
            }else{
                this.channelPort.postMessage(str)
            }
            
        }
    }

    async musicStop(){
        if(this.mode){

            let jsonData={
                "command":"speaker",
                "params":{
                    "mode":4,
                    "vol":0,
                    "name":''
                }
            }
            // let str0=`${args.TWO.split('.')[0]} = robot.read_wav('/flash/${args.TWO}')\r`
            // let str = `robot.play_music(${args.ONE},${args.TWO.split('.')[0]})\r`;

            let str = JSON.stringify(jsonData)
            if(this.whatSendFun=='net'){
                if(socket.checkWebSocketStatus()==4 || socket.checkWebSocketStatus()==0){
                    console.log('断开连接，尝试重连')
                    let context=[]
                    // context.push(str0)
                    context.push(str)
                    await socket.setSocket(context)
                }else if(socket.checkWebSocketStatus()==2){
                    // socket.getSocket().send(str0);
                    // await new Promise(resolve => setTimeout(resolve, 50));  // 等待1秒
                    socket.getSocket().send(str);
                    await new Promise(resolve => setTimeout(resolve, 50));  // 等待1秒
                }
                socket.setLastPostTime(Date.now())
            }else{
                this.channelPort.postMessage(str)
            }
           

            //  const Socket = new WebSocket(`ws://${socket.getIp()}:8084`);
                                
            // Socket.addEventListener('open', async (event) => {
            //     console.log('连接成功');
            //     Socket.send(str)
            //     await new Promise(resolve => setTimeout(resolve, 100));
            //     Socket.close()
    
                    
            // });
        }
    }


    async selectAndProcessAudio() {
        return new Promise((resolve, reject) => {
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = '.wav';
          input.style.display = 'none';
      
          input.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) {
              reject(new Error('未选择文件'));
              input.remove();
              return;
            }
      
            try {
              const processed = await this.processAudioFile(file);
              resolve(processed);
            } catch (err) {
              reject(err);
            } finally {
              input.remove(); // 清除 input
            }
          });
      
          document.body.appendChild(input);
          input.click(); // 自动触发文件选择
        });
    }

    async processAudioFile(file) {
        const arrayBuffer = await file.arrayBuffer();
        const audioContext = new AudioContext();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
      
        const inputData = audioBuffer.getChannelData(0); // 单通道
        const originalSampleRate = audioBuffer.sampleRate;
        const resampledData = this.resampleAudio(inputData, originalSampleRate, 8000);
        const pcm16 = this.floatTo16BitPCM(resampledData);
        return pcm16;
    }
      
    resampleAudio(inputData, srcRate, targetRate) {
        const ratio = srcRate / targetRate;
        const newLength = Math.floor(inputData.length / ratio);
        const output = new Float32Array(newLength);
        
        for (let i = 0; i < newLength; i++) {
            const idx = Math.floor(i * ratio);
            output[i] = inputData[idx];
        }
        
        return output;
    }
      
    floatTo16BitPCM(input) {
        const buffer = new ArrayBuffer(input.length * 2);
        const view = new DataView(buffer);
        
        for (let i = 0; i < input.length; i++) {
            const sample = Math.max(-1, Math.min(1, input[i]));
            view.setInt16(i * 2, sample * 0x7FFF, true);
        }
        
        return new Blob([view], { type: 'audio/wav' });
    }
      
      

    async selectSound(){
        try {
            const processedBlob = await this.selectAndProcessAudio();
            console.log('✅ 音频处理完成，Blob:', processedBlob);

            const arrayBuffer = await processedBlob.arrayBuffer();
            console.log(arrayBuffer)

            let name = await new Promise(resolve => {
                resolve(prompt('请输入音频名称'));  // 在异步函数中包装 prompt
            });

            this.upLoadSound.push({
                name:name,
                data:arrayBuffer
            })

            

        } catch (err) {
            console.error('❌ 处理失败:', err.message);
            alert('音频上传失败，请选择其他音频')
        }
    }
    async playLocalMusic(args){
        if(args.TWO=='0'){
            this.shouldStopSending = false;
            if(this.isSendEnd){
                try {
                    // const processedBlob = await this.selectAndProcessAudio();
                    // console.log('✅ 音频处理完成，Blob:', processedBlob);
        
                    // const arrayBuffer = await processedBlob.arrayBuffer();
                    // console.log(arrayBuffer)
        
        
                    this.isSendEnd=false
                    console.log(this.upLoadSound[Number(args.ONE)].data)
                    let arrayBuffer=this.upLoadSound[Number(args.ONE)].data
        
                    socketSound = new WebSocket(`ws://${socket.getIp()}:8080`)
                    
                    socketSound.addEventListener('open',async()=>{
                        console.log('连接成功')
                        const chunkSize = 2048;
                        let offset = 44; // ✅ 跳过 WAV 头部 44 字节
                      
                        const sendChunk = () => {

                            if (this.shouldStopSending) {
                                console.warn('⛔️ 发送被手动中断');
                                socketSound.close();
                                this.isSendEnd = true;
                                return;
                            }


                          if (offset >= arrayBuffer.byteLength) {
                            console.log('📤 所有音频数据发送完毕');
                            socketSound.close()
                            this.isSendEnd=true
                            return;
                          }
                      
                          const end = Math.min(offset + chunkSize, arrayBuffer.byteLength);
                          const chunk = arrayBuffer.slice(offset, end);
                          socketSound.send(chunk);
                          offset = end;
                      
                          setTimeout(sendChunk, 125); // 控制发送节奏
                          
                        };
                      
                        sendChunk();
                    })
        
                } catch (err) {
                    console.error('❌ 处理失败:', err.message);
                }
            }
        }else if(args.TWO=='1'){
            this.shouldStopSending = true;
        }
       
        
    }

    getSoundList(){
        let item=[];
        if(this.upLoadSound && this.upLoadSound.length > 0){
            console.log('新菜单')
            for(let i=0;i<this.upLoadSound.length;i++){
                let content={
                    text:this.upLoadSound[i].name,
                    value:`${i}`
                }
                item.push(content)
            }
        }else{
            console.log('旧菜单')
            item.push({
                text:' ',
                value:' '
            })
        }

        console.log(item)
        
        return item
    }

    async downLoadSound(){
        try {
            const processedBlob = await this.selectAndProcessAudio();
            console.log('✅ 音频处理完成，Blob:', processedBlob);

            const arrayBuffer = await processedBlob.arrayBuffer();
            console.log(arrayBuffer)


            socketSound = new WebSocket(`ws://${socket.getIp()}:8084`)
            let reciveData=''
            socketSound.addEventListener('open',async()=>{
                console.log('连接成功')
                const waitForMessage = () => {
                    return new Promise(resolve => {
                        const listener = (event) => {
                            console.log('收到消息:', event.data);
                            socketSound.removeEventListener('message', listener);
                            resolve(event.data);
                        };
                        socketSound.addEventListener('message', listener);
                    });
                };
            
                socketSound.send('music');
            
                let res = await waitForMessage();
                if (res === 'success') {
                    const chunkSize = 1024;
                    let offset = 44;
            
                    // while (offset < arrayBuffer.byteLength) {
                    //     const end = Math.min(offset + chunkSize, arrayBuffer.byteLength);
                    //     const chunk = arrayBuffer.slice(offset, end);
                    //     socketSound.send(chunk);
            
                    //     const result = await waitForMessage(); // 等待服务器回复
                    //     if (result !== 'success') {
                    //         alert('某段发送失败');
                    //         socketSound.close();
                    //         return;
                    //     }
            
                    //     offset = end;
                    // }

                    socketSound.send(arrayBuffer)
                    let result=await waitForMessage();
                    if(result=='success'){
                        console.log('📤 所有音频数据发送完毕');
                        socketSound.send('finished');
                
                        const finalRes = await waitForMessage();
                        if (finalRes === 'success') {
                            alert('下载完成');
                        } else {
                            alert('下载失败');
                        }
                        socketSound.close();
                    }else{
                        alert('数据发送失败')
                        socketSound.close();
                    }
            
                    
            
                    
                }
                
            })
    
            

            

        } catch (err) {
            console.error('❌ 处理失败:', err.message);
            alert('音频上传失败，请选择其他音频')
        }
    }

    async sendMusic(){

    }

    async stopSendMusic(){

    }

    async tts(args){
        // const text = args.ONE;
        // const utterance = new SpeechSynthesisUtterance(text);
        // utterance.lang = 'zh-CN';
        
        // // 创建一个新的 AudioContext
        // const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // // 创建一个音频源，允许从 SpeechSynthesis 输出音频
        // const source = audioContext.createMediaStreamDestination();
        
        // // 通过 MediaRecorder 捕获音频
        // const mediaRecorder = new MediaRecorder(source.stream);
        // let audioChunks = [];
        
        // mediaRecorder.ondataavailable = function(event) {
        //     audioChunks.push(event.data);
        // };
        
        // mediaRecorder.onstop = function() {
        //     const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
        //     const audioUrl = URL.createObjectURL(audioBlob);
            
        //     // 将音频 URL 保存到变量
        //     console.log("音频已保存:", audioUrl);
            
        //     // 你可以通过音频 URL 创建一个 <audio> 元素进行播放
        //     const audioElement = new Audio(audioUrl);
        //     audioElement.play();
        // };
        
        // // 开始录制音频
        // mediaRecorder.start();
        
        // // 开始合成语音
        // speechSynthesis.speak(utterance);
        
        // // 停止录制后
        // utterance.onend = function() {
        //     mediaRecorder.stop();
        // };
    }

    async addSound(){
        if(this.mode){
            // this.currentVol+=args.ONE
            let jsonData={
                "command":"speaker",
                "params":{
                    "mode":5,
                    "vol":0,
                    "name":''
                }
            }
            // let str0=`${args.TWO.split('.')[0]} = robot.read_wav('/flash/${args.TWO}')\r`
            // let str = `robot.play_music(${args.ONE},${args.TWO.split('.')[0]})\r`;

            let str = JSON.stringify(jsonData)
            if(socket.checkWebSocketStatus()==4 || socket.checkWebSocketStatus()==0){
                console.log('断开连接，尝试重连')
                let context=[]
                // context.push(str0)
                context.push(str)
                await socket.setSocket(context)
            }else if(socket.checkWebSocketStatus()==2){
                // socket.getSocket().send(str0);
                // await new Promise(resolve => setTimeout(resolve, 50));  // 等待1秒
                socket.getSocket().send(str);
                await new Promise(resolve => setTimeout(resolve, 50));  // 等待1秒
            }
            socket.setLastPostTime(Date.now())
        }
    }


    async subSound(){
        if(this.mode){
            // this.currentVol+=args.ONE
            let jsonData={
                "command":"speaker",
                "params":{
                    "mode":6,
                    "vol":0,
                    "name":''
                }
            }
            // let str0=`${args.TWO.split('.')[0]} = robot.read_wav('/flash/${args.TWO}')\r`
            // let str = `robot.play_music(${args.ONE},${args.TWO.split('.')[0]})\r`;

            let str = JSON.stringify(jsonData)
            if(socket.checkWebSocketStatus()==4 || socket.checkWebSocketStatus()==0){
                console.log('断开连接，尝试重连')
                let context=[]
                // context.push(str0)
                context.push(str)
                await socket.setSocket(context)
            }else if(socket.checkWebSocketStatus()==2){
                // socket.getSocket().send(str0);
                // await new Promise(resolve => setTimeout(resolve, 50));  // 等待1秒
                socket.getSocket().send(str);
                await new Promise(resolve => setTimeout(resolve, 50));  // 等待1秒
            }
            socket.setLastPostTime(Date.now())
        }
    }

}


module.exports = RobotSound;
